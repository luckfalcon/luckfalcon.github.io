<!doctype html>
<html lang="en-us">
  <head>
    <title>Effectivecpp // My New Hugo Site</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.118.2">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Effectivecpp"/>
<meta name="twitter:description" content="luckfalcon的博客 C&#43;&#43;编程注意条款 拷贝构造函数&mdash;初始化&mdash;&ndash;A(B)&mdash;只发生在对象创建时 拷贝赋值运算符&ndash;同类型对象值赋值给创建对象&ndash;A=B 值传递（pass-by-value）&ndash;调用构造函数 引用传递(passed-by-reference)&ndash;不调用构造函数 C&#43;&#43;四大次级语言
c语言部分编程 class类编程 template模板编程 STL标准库编程 条款2：尽量以const,enum,inline 替换#define #define 没有作用域概念，且不做类型检查，仅仅是变量替换(包括变量的前后缀，表达式代入) #define max(a,b) f((a)&gt;(b)?(a):(b)) int a = 5,b = 0; max(&#43;&#43;a,b);	//a被累加2次 max(&#43;&#43;a,b&#43;10);	//a被累加1次 enum hack(枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术 class test {	static const int num=1;//此处仅为声明而非定义 int arr[num]; } const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; } 小结
const 对象替换define 常量 inline函数替换define 形似函数 条款3：尽可能使用const 令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性 //有理数operator* class Rational{} const Rational operator*(const Rational &amp;lhs,const Rational &amp;rhs); //可以避免客户暴力行为如: Rational a,b,c; (a * b) = c;//在a*b的结果上调用赋值运算符operator = const成员函数，可确保类的const对象可被操作 如过函数的返回类型是内置类型，改动函数返回值是非法的 class text { public: const &amp;char operator[](std::size_t position)const//处理const对象，不可修改对象 {return st[position];} &amp;char operator[](std::size_t position)//处理非const对象,可修改对象 {return st[position];} private: std::string st; } 将类成员声明为mutable类型，可以实现在const对象内修改对象的值，但并能完全解决const与non-const的全部问题 class text { public: std::size_t length()const; private: char *ptex; mutable std::size_t textlength;//这些变量可以被修改，即使在const对象内部 mutable bool LengthIsValid; } std::size_t text:: length()const { if(!"/>

    <meta property="og:title" content="Effectivecpp" />
<meta property="og:description" content="luckfalcon的博客 C&#43;&#43;编程注意条款 拷贝构造函数&mdash;初始化&mdash;&ndash;A(B)&mdash;只发生在对象创建时 拷贝赋值运算符&ndash;同类型对象值赋值给创建对象&ndash;A=B 值传递（pass-by-value）&ndash;调用构造函数 引用传递(passed-by-reference)&ndash;不调用构造函数 C&#43;&#43;四大次级语言
c语言部分编程 class类编程 template模板编程 STL标准库编程 条款2：尽量以const,enum,inline 替换#define #define 没有作用域概念，且不做类型检查，仅仅是变量替换(包括变量的前后缀，表达式代入) #define max(a,b) f((a)&gt;(b)?(a):(b)) int a = 5,b = 0; max(&#43;&#43;a,b);	//a被累加2次 max(&#43;&#43;a,b&#43;10);	//a被累加1次 enum hack(枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术 class test {	static const int num=1;//此处仅为声明而非定义 int arr[num]; } const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; } 小结
const 对象替换define 常量 inline函数替换define 形似函数 条款3：尽可能使用const 令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性 //有理数operator* class Rational{} const Rational operator*(const Rational &amp;lhs,const Rational &amp;rhs); //可以避免客户暴力行为如: Rational a,b,c; (a * b) = c;//在a*b的结果上调用赋值运算符operator = const成员函数，可确保类的const对象可被操作 如过函数的返回类型是内置类型，改动函数返回值是非法的 class text { public: const &amp;char operator[](std::size_t position)const//处理const对象，不可修改对象 {return st[position];} &amp;char operator[](std::size_t position)//处理非const对象,可修改对象 {return st[position];} private: std::string st; } 将类成员声明为mutable类型，可以实现在const对象内修改对象的值，但并能完全解决const与non-const的全部问题 class text { public: std::size_t length()const; private: char *ptex; mutable std::size_t textlength;//这些变量可以被修改，即使在const对象内部 mutable bool LengthIsValid; } std::size_t text:: length()const { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://luckfalcon.github.io/post/effectivecpp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-09-13T11:26:19+08:00" />
<meta property="article:modified_time" content="2023-09-13T11:26:19+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://luckfalcon.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">My New Hugo Site</span>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Effectivecpp</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 13, 2023
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p><a href="luckfalcon.github.io">luckfalcon的博客</a>
<img src="" alt="test"></p>
<h1 id="c编程注意条款">C++编程注意条款</h1>
<ul>
<li>拷贝构造函数&mdash;初始化&mdash;&ndash;A(B)&mdash;只发生在对象创建时</li>
<li>拷贝赋值运算符&ndash;同类型对象值赋值给创建对象&ndash;A=B</li>
<li>值传递（pass-by-value）&ndash;调用构造函数</li>
<li>引用传递(passed-by-reference)&ndash;不调用构造函数</li>
</ul>
<p>C++四大次级语言</p>
<ul>
<li>c语言部分编程</li>
</ul>
<hr>
<ul>
<li>class类编程</li>
</ul>
<hr>
<ul>
<li>template模板编程</li>
</ul>
<hr>
<ul>
<li>STL标准库编程</li>
</ul>
<hr>
<h2 id="条款2尽量以constenuminline-替换define">条款2：尽量以const,enum,inline 替换#define</h2>
<ul>
<li>#define 没有作用域概念，且不做类型检查，仅仅是变量替换(包括变量的前后缀，表达式代入)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define max(a,b) f((a)&gt;(b)?(a):(b))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>,b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">max</span>(<span style="color:#f92672">++</span>a,b);	<span style="color:#75715e">//a被累加2次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">max</span>(<span style="color:#f92672">++</span>a,b<span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>);	<span style="color:#75715e">//a被累加1次
</span></span></span></code></pre></div><ul>
<li>enum hack(枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>{	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> num<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//此处仅为声明而非定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> arr[num];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> num;<span style="color:#75715e">//此处为定义,放在实现文件中而非头文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span>{num <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>}<span style="color:#75715e">//可代替上 static const int 
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> {arr_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>};<span style="color:#75715e">//在编译器不支持编译期间类内static初值时(仅限整数情况)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> arr[arr_size];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>const 对象替换define 常量</li>
<li>inline函数替换define 形似函数</li>
</ul>
<h2 id="条款3尽可能使用const">条款3：尽可能使用const</h2>
<ul>
<li>令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//有理数operator*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rational</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Rational <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">const</span> Rational <span style="color:#f92672">&amp;</span>lhs,<span style="color:#66d9ef">const</span> Rational <span style="color:#f92672">&amp;</span>rhs);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//可以避免客户暴力行为如:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Rational a,b,c;
</span></span><span style="display:flex;"><span>(a <span style="color:#f92672">*</span> b) <span style="color:#f92672">=</span> c;<span style="color:#75715e">//在a*b的结果上调用赋值运算符operator =
</span></span></span></code></pre></div><ul>
<li>const成员函数，可确保类的const对象可被操作</li>
<li>如过函数的返回类型是内置类型，改动函数返回值是非法的</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">text</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">operator</span>[](std<span style="color:#f92672">::</span>size_t position)<span style="color:#66d9ef">const</span><span style="color:#75715e">//处理const对象，不可修改对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{<span style="color:#66d9ef">return</span> st[position];}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">operator</span>[](std<span style="color:#f92672">::</span>size_t position)<span style="color:#75715e">//处理非const对象,可修改对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{<span style="color:#66d9ef">return</span> st[position];}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string st;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>将类成员声明为mutable类型，可以实现在const对象内修改对象的值，但并能完全解决const与non-const的全部问题</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">text</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>size_t length()<span style="color:#66d9ef">const</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptex;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">mutable</span> std<span style="color:#f92672">::</span>size_t textlength;<span style="color:#75715e">//这些变量可以被修改，即使在const对象内部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">bool</span> LengthIsValid;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>size_t text<span style="color:#f92672">::</span> length()<span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>LengthIsValid)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		textlength <span style="color:#f92672">=</span> strlen(ptex);
</span></span><span style="display:flex;"><span>		LengthIsValid <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> textlength;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>在const和non-const 成员函数中避免重复使用，策略是利用non-const调用const的版本来实现</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">operator</span>[](std<span style="color:#f92672">::</span>size_t position)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;&gt;</span>(		<span style="color:#75715e">//将op[]返回值去除const
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> text <span style="color:#f92672">&amp;&gt;</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>)<span style="color:#75715e">//为this加上const，调用const op[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		)<span style="color:#75715e">//若不给this加const，则会无限递归自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>将某些东西声明为const可以帮助编译器检查错误用法。const可以被加在任何作用域内的对象、函数参数、函数返回类型、成员函数。</li>
<li>编译器强制bitwise constness(位常量性)，但你编程时应使用&quot;概念上的常量性&quot;(conceptual constness)。</li>
<li>当const函数与non-const函数有等价的实现时，用non-const版本调用const版本可避免代码重复。</li>
</ul>
<h2 id="条款4确定对象被使用前已先被初始化">条款4：确定对象被使用前已先被初始化</h2>
<ul>
<li>未初始化对象可导致未定义行为(undefined behavior)，最终导致程序错误。</li>
<li>永远在对象使用之前对其初始化，内置类型直接初始化，类类型由其构造函数完成初始化(类成员初始化发生在构造函数体之前，构造函数体内为赋值，初始化类成员应使用类成员初始化列表)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	obj(<span style="color:#66d9ef">int</span> i_nit,<span style="color:#66d9ef">char</span> c_init,<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>s_init)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">:</span>i(i_nit),c(c_init),s(s_init){}<span style="color:#75715e">//初始化，通常效率更高
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	obj(<span style="color:#66d9ef">int</span> i_nit,<span style="color:#66d9ef">char</span> c_init,<span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>s_init)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> i_nit;<span style="color:#75715e">//赋值，会先调用default构造函数，再进行拷贝赋值=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		c <span style="color:#f92672">=</span> c_init;
</span></span><span style="display:flex;"><span>		s <span style="color:#f92672">=</span> s_init;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>	string s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>c++对&quot;定义于不同编译单元内的non-local static 对象&quot;的初始化<strong>次序</strong>并无明确定义。通过设计消除这种情况，做法是，将每个non-local static对象搬到自己的专属函数内(该对象在此函数内被声明为static)。这些函数返回一个reference指向它所含的对象。用户调用这些函数获得static对象的引用，而非直接使用static对象本身。</li>
</ul>
<blockquote>
<p>编译单元(translation unit)是指产出单一目标文件(sigle object file)的源码。基本上它是单一源码文件加上其所含入的头文件(#include file)。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Ob1</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	Ob1 <span style="color:#f92672">&amp;</span>obj()<span style="color:#75715e">//在类外定义为内联函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">static</span> Ob ob;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ob;<span style="color:#75715e">//指向static对象的reference，而不再使用static对象自身
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>内置类型手动初始化。</li>
<li>构造函数使用成员的初始化列表初始化，而非构造函数体内进行赋值，成员初始化次序最好与声明次序相同。</li>
<li>为免除&quot;跨编译单元初始化次序&quot;问题，以local static对象替换non-local static对象。</li>
</ul>
<h2 id="条款5了解c默默写并调用哪些函数">条款5：了解c++默默写并调用哪些函数</h2>
<ul>
<li>空类，编译器默认生成一个无实参的default构造函数、一个有实参拷贝构造函数、一个拷贝赋值运算符、一个析构函数。</li>
<li>用户自定义构造函数后，default构造函数不指定则编译器不再提供。</li>
<li>对于成员类型为引用的类，编译器默认不生成拷贝赋值运算符(原因是c++不允许改变引用的对象)。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>编译器可以暗自为class创建default构造函数、copy构造函数、copy assighnment操作符，以及析构函数。</li>
</ul>
<h2 id="条款6若不想使用编译器自动生成的函数就该明确拒绝">条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2>
<ul>
<li>为了阻止类的拷贝赋值行为，你可以通过继承一个基类的拷贝复制操作是private的类来实现。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">uncopy</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	uncopy();
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>uncopy();<span style="color:#75715e">//由于非虚函数，会带来多重继承的问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	uncopy(<span style="color:#66d9ef">const</span> uncopy<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>	uncopy <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> uncopy<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">obj</span><span style="color:#f92672">:</span><span style="color:#66d9ef">private</span> uncopy{};<span style="color:#75715e">//此时class不再生命copy函数或copy assighnment操作符
</span></span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>为驳回编译器自动提供的技能，可将相应的成员函数声明为privateb并且不予实现，如uncopy基类的做法。</li>
</ul>
<h2 id="条款7为多态基类声明virtual析构函数">条款7：为多态基类声明virtual析构函数</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">base</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	base();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">virtual</span> <span style="color:#a6e22e">function</span>();<span style="color:#75715e">//带有虚成员函数的类才需要虚析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>base();<span style="color:#75715e">//析构函数声明为虚函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">derivedA</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> base{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">derivedB</span><span style="color:#f92672">:</span><span style="color:#66d9ef">protected</span> base{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">derivedC</span> <span style="color:#f92672">:</span><span style="color:#66d9ef">private</span> base{};
</span></span></code></pre></div><ul>
<li>每个带有virtual函数的class都有一个相应的vtbl(virtual table)，在运行时，由vptr(virtual table pointer)指出，从而实现带virtual函数。将不含virtual函数的类的析构函数声明为virtual会影响类的可移植性。</li>
<li>基类的析构函数非virtual的时，不要使用基类指针指向派生类，否则在销毁基类指针时无法调用派生类的析构函数，从而造成内存泄漏。</li>
<li>pure virtual析构函数的类为抽象类，无法实例化,只适合做基类。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>obj()<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//纯虚函数,该类为抽象类，无法实例化，只适合做基类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>obj<span style="color:#f92672">::~</span>obj(){};<span style="color:#75715e">//纯虚函数的定义,不做这个定义，连接器会出错
</span></span></span></code></pre></div><ul>
<li>并非所有的基类设计都是为多态用途，即不是所有的基类都需要virtual析构函数。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>polymorphic(带有多态性质的)base classes应该声明一个virtual析构函数。如何class带有virtual函数，那么应该声明virtual析构函数。</li>
<li>classes的设计目的如果不是作为base classes使用，或者不是为了具备多态性(polymorphically)，就不应该声明virtual析构函数。</li>
</ul>
<h2 id="条款8别让异常逃离析构函数">条款8：别让异常逃离析构函数</h2>
<ul>
<li>c++不希望在类的析构函数中抛出异常(这会导致一些容器由于多个类对象析构异常而导致不明确行为)</li>
<li>转接给客户一次处理异常的机会</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> obj create();<span style="color:#75715e">//返回一个obj对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">closed</span>();<span style="color:#75715e">//关闭，失败会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">manageobj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> closed()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		closed();<span style="color:#75715e">//非析构函数抛出异常可供用户选择处理,若在析构函数内，用户无法处理，只能选择终止或者忽略异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		closed<span style="color:#f92672">=</span>true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">~</span>manageobj()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>closed)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				closed();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">catch</span>()
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//记录close调用失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			};
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	obj oj;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> closed;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(阻止不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通的函数(而非在析构函数中)执行该操作。</li>
</ul>
<h2 id="条款9绝不在构造和析构过程中调用virtual函数">条款9：绝不在构造和析构过程中调用virtual函数</h2>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
