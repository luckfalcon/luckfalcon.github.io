<!DOCTYPE html>
<html><head>
<title>Effectivecpp</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="Effectivecpp" />
<meta property="og:description" content="luckfalcon的github page
C&#43;&#43;编程注意条款 拷贝构造函数 &mdash; 初始化 &mdash;&ndash;A(B)&mdash; 只发生在对象创建时 拷贝赋值运算符 &ndash; 同类型对象值赋值给创建对象 &ndash;A=B 值传递（pass-by-value）&ndash; 调用构造函数 引用传递 (passed-by-reference) &ndash; 不调用构造函数 C&#43;&#43;四大次级语言
c 语言部分编程 class 类编程 template 模板编程 STL 标准库编程 条款2：尽量以 const，enum，inline 替换 #define #define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。 #define max(a,b) f((a) &gt; (b)? (a) : (b)) int a = 5,b = 0; max(&#43;&#43;a, b);	//a被累加2次 max(&#43;&#43;a, b&#43;10);	//a被累加1次 enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。 class Test {	static const int num = 1;//此处仅为声明而非定义 int arr[num]; }; const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class Test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; }; 小结" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://luckfalcon.github.io/post/effectivecpp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-23T01:47:59+08:00" />
<meta property="article:modified_time" content="2023-10-23T01:47:59+08:00" /><meta property="og:site_name" content="My Blog" />





<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Effectivecpp"/>
<meta name="twitter:description" content="luckfalcon的github page
C&#43;&#43;编程注意条款 拷贝构造函数 &mdash; 初始化 &mdash;&ndash;A(B)&mdash; 只发生在对象创建时 拷贝赋值运算符 &ndash; 同类型对象值赋值给创建对象 &ndash;A=B 值传递（pass-by-value）&ndash; 调用构造函数 引用传递 (passed-by-reference) &ndash; 不调用构造函数 C&#43;&#43;四大次级语言
c 语言部分编程 class 类编程 template 模板编程 STL 标准库编程 条款2：尽量以 const，enum，inline 替换 #define #define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。 #define max(a,b) f((a) &gt; (b)? (a) : (b)) int a = 5,b = 0; max(&#43;&#43;a, b);	//a被累加2次 max(&#43;&#43;a, b&#43;10);	//a被累加1次 enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。 class Test {	static const int num = 1;//此处仅为声明而非定义 int arr[num]; }; const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class Test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; }; 小结"/>









<script type="text/javascript">
  (function(c,l,a,r,i,t,y){
      c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
      t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
      y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
  })(window, document, "clarity", "script", "abcdefghzd");
</script>



  






      <script src="/js/toc.js"></script>
    
    <link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">

<link rel="stylesheet" href="/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css" integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media="screen">


<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Material+Icons">



















</head>
<body>
    	<div id="app"><div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/post">
                    归档
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    分类
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    关于
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS Feed
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#c%e7%bc%96%e7%a8%8b%e6%b3%a8%e6%84%8f%e6%9d%a1%e6%ac%be" class="nav-c编程注意条款">
									C&#43;&#43;编程注意条款
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be2%e5%b0%bd%e9%87%8f%e4%bb%a5-constenuminline-%e6%9b%bf%e6%8d%a2-define" class="nav-条款2尽量以-constenuminline-替换-define">
									条款2：尽量以 const，enum，inline 替换 #define
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be3%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8-const" class="nav-条款3尽可能使用-const">
									条款3：尽可能使用 const
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be4%e7%a1%ae%e5%ae%9a%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%89%8d%e5%b7%b2%e5%85%88%e8%a2%ab%e5%88%9d%e5%a7%8b%e5%8c%96" class="nav-条款4确定对象被使用前已先被初始化">
									条款4：确定对象被使用前已先被初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be5%e4%ba%86%e8%a7%a3c%e9%bb%98%e9%bb%98%e5%86%99%e5%b9%b6%e8%b0%83%e7%94%a8%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0" class="nav-条款5了解c默默写并调用哪些函数">
									条款5：了解c&#43;&#43;默默写并调用哪些函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be6%e8%8b%a5%e4%b8%8d%e6%83%b3%e4%bd%bf%e7%94%a8%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0%e5%b0%b1%e8%af%a5%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d" class="nav-条款6若不想使用编译器自动生成的函数就该明确拒绝">
									条款6：若不想使用编译器自动生成的函数，就该明确拒绝
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be7%e4%b8%ba%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e5%a3%b0%e6%98%8evirtual%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" class="nav-条款7为多态基类声明virtual析构函数">
									条款7：为多态基类声明virtual析构函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be8%e5%88%ab%e8%ae%a9%e5%bc%82%e5%b8%b8%e9%80%83%e7%a6%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" class="nav-条款8别让异常逃离析构函数">
									条款8：别让异常逃离析构函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be9%e7%bb%9d%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8virtual%e5%87%bd%e6%95%b0" class="nav-条款9绝不在构造和析构过程中调用virtual函数">
									条款9：绝不在构造和析构过程中调用virtual函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be10%e4%bb%a4operator--%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aareference-to-this" class="nav-条款10令operator--返回一个reference-to-this">
									条款10：令operator = 返回一个reference to *this
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be11%e5%9c%a8-operator--%e4%b8%ad%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc" class="nav-条款11在-operator--中处理自我赋值">
									条款11：在 operator = 中处理“自我赋值”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e6%97%b6%e5%8b%bf%e5%bf%98%e5%85%b6%e6%af%8f%e4%b8%80%e4%b8%aa%e6%88%90%e5%88%86" class="nav-条款12复制对象时勿忘其每一个成分">
									条款12：复制对象时勿忘其每一个成分
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90" class="nav-条款13以对象管理资源">
									条款13：以对象管理资源
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e5%b0%8f%e5%bf%83coping%e8%a1%8c%e4%b8%ba" class="nav-条款14在资源管理类中小心coping行为">
									条款14：在资源管理类中小心coping行为
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae" class="nav-条款15在资源管理类中提供对原始资源的访问">
									条款15：在资源管理类中提供对原始资源的访问
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be16%e6%88%90%e5%af%b9%e4%bd%bf%e7%94%a8new%e5%92%8cdelete%e6%97%b6%e8%a6%81%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f" class="nav-条款16成对使用new和delete时要采用相同形式">
									条款16：成对使用new和delete时要采用相同形式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be17%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86-newed-%e5%af%b9%e8%b1%a1%e7%bd%ae%e5%85%a5%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="nav-条款17以独立语句将-newed-对象置入智能指针">
									条款17：以独立语句将 newed 对象置入智能指针
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e5%ae%b9%e6%98%93%e8%a2%ab%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e4%b8%8d%e6%98%93%e8%a2%ab%e8%af%af%e7%94%a8" class="nav-条款18让接口容易被正确使用不易被误用">
									条款18：让接口容易被正确使用，不易被误用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be19%e8%ae%be%e8%ae%a1-class-%e7%8a%b9%e5%a6%82%e8%ae%be%e8%ae%a1-type" class="nav-条款19设计-class-犹如设计-type">
									条款19：设计 class 犹如设计 type
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be20%e5%ae%81%e5%8f%af%e4%bb%a5-passed-by-reference-to-const-%e6%9b%bf%e6%8d%a2-passed-by-value" class="nav-条款20宁可以-passed-by-reference-to-const-替换-passed-by-value">
									条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be21%e5%bf%85%e9%a1%bb%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e6%97%b6%e5%88%ab%e5%a6%84%e6%83%b3%e8%bf%94%e5%9b%9e%e5%85%b6reference" class="nav-条款21必须返回对象时别妄想返回其reference">
									条款21：必须返回对象时，别妄想返回其reference
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be22%e5%b0%86%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e4%b8%ba-private" class="nav-条款22将成员变量声明为-private">
									条款22：将成员变量声明为 private
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be23%e5%ae%81%e4%bb%a5-non-membernon-friend-%e6%9b%bf%e6%8d%a2-member-%e5%87%bd%e6%95%b0" class="nav-条款23宁以-non-membernon-friend-替换-member-函数">
									条款23：宁以 non-member、non-friend 替换 member 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be24%e8%8b%a5%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e7%9a%86%e9%9c%80%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%af%b7%e4%b8%ba%e6%ad%a4%e9%87%87%e7%94%a8-non-member-%e5%87%bd%e6%95%b0" class="nav-条款24若所有参数皆需类型转换请为此采用-non-member-函数">
									条款24：若所有参数皆需类型转换，请为此采用 non-member 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be25%e8%80%83%e8%99%91%e5%86%99%e5%87%ba%e4%b8%80%e4%b8%aa%e4%b8%8d%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8%e7%9a%84-swap-%e5%87%bd%e6%95%b0" class="nav-条款25考虑写出一个不抛出异常的-swap-函数">
									条款25：考虑写出一个不抛出异常的 swap 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be26%e5%b0%bd%e5%8f%af%e8%83%bd%e5%bb%b6%e5%90%8e%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89%e5%bc%8f%e7%9a%84%e5%87%ba%e7%8e%b0%e6%97%b6%e9%97%b4" class="nav-条款26尽可能延后变量定义式的出现时间">
									条款26：尽可能延后变量定义式的出现时间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be27%e5%b0%bd%e9%87%8f%e5%b0%91%e5%81%9a%e8%bd%ac%e5%9e%8b%e5%8a%a8%e4%bd%9c" class="nav-条款27尽量少做转型动作">
									条款27：尽量少做转型动作
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9e-handles-%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e6%88%90%e5%88%86" class="nav-条款28避免返回-handles-指向对象内部成分">
									条款28：避免返回 handles 指向对象内部成分
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be29%e4%b8%ba%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e8%80%8c%e5%8a%aa%e5%8a%9b%e6%98%af%e5%80%bc%e5%be%97%e7%9a%84" class="nav-条款29为异常安全而努力是值得的">
									条款29：为&#34;异常安全&#34;而努力是值得的
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be30%e9%80%8f%e5%bd%bb%e4%ba%86%e8%a7%a3-inlining-%e7%9a%84%e9%87%8c%e9%87%8c%e5%a4%96%e5%a4%96" class="nav-条款30透彻了解-inlining-的里里外外">
									条款30：透彻了解 inlining 的里里外外
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be31%e5%b0%86%e6%96%87%e4%bb%b6%e9%97%b4%e7%9a%84%e7%bc%96%e8%af%91%e4%be%9d%e5%ad%98%e5%85%b3%e7%b3%bb%e9%99%8d%e8%87%b3%e6%9c%80%e4%bd%8e" class="nav-条款31将文件间的编译依存关系降至最低">
									条款31：将文件间的编译依存关系降至最低
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be32%e7%a1%ae%e5%ae%9a%e4%bd%a0%e7%9a%84-public-%e7%bb%a7%e6%89%bf%e5%a1%91%e6%a8%a1%e5%87%ba-is-a-%e5%85%b3%e7%b3%bb" class="nav-条款32确定你的-public-继承塑模出-is-a-关系">
									条款32：确定你的 public 继承塑模出 is-a 关系
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-33%e9%81%bf%e5%85%8d%e9%81%ae%e6%8e%a9%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e5%90%8d%e7%a7%b0" class="nav-条款-33避免遮掩继承而来的名称">
									条款 33：避免遮掩继承而来的名称
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf" class="nav-条款-34区分接口继承和实现继承">
									条款 34：区分接口继承和实现继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-35%e8%80%83%e8%99%91-virtual-%e5%87%bd%e6%95%b0%e4%bb%a5%e5%a4%96%e7%9a%84%e5%85%b6%e4%bb%96%e9%80%89%e6%8b%a9" class="nav-条款-35考虑-virtual-函数以外的其他选择">
									条款 35：考虑 virtual 函数以外的其他选择
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-36%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84-non-virtual-%e5%87%bd%e6%95%b0" class="nav-条款-36绝不重新定义继承而来的-non-virtual-函数">
									条款 36：绝不重新定义继承而来的 non-virtual 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-37-%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e7%bc%ba%e7%9c%81%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0%e5%80%bc" class="nav-条款-37-绝不重新定义继承而来的缺省默认参数值">
									条款 37: 绝不重新定义继承而来的缺省(默认)参数值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-38-%e9%80%9a%e8%bf%87%e5%a4%8d%e5%90%88%e5%a1%91%e6%a8%a1%e5%87%ba-has-a-%e6%88%96--%e6%a0%b9%e6%8d%ae%e6%9f%90%e7%89%a9%e5%ae%9e%e7%8e%b0%e5%87%ba-" class="nav-条款-38-通过复合塑模出-has-a-或--根据某物实现出-">
									条款 38: 通过复合塑模出 has-a 或 “ 根据某物实现出 ”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-39-%e6%98%8e%e6%99%ba%e8%80%8c%e5%ae%a1%e6%85%8e%e5%9c%b0%e4%bd%bf%e7%94%a8-private-%e7%bb%a7%e6%89%bf" class="nav-条款-39-明智而审慎地使用-private-继承">
									条款 39: 明智而审慎地使用 Private 继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-40-%e6%98%8e%e6%99%ba%e8%80%8c%e5%ae%a1%e6%85%8e%e5%9c%b0%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf" class="nav-条款-40-明智而审慎地使用多重继承">
									条款 40: 明智而审慎地使用多重继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-41%e4%ba%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81" class="nav-条款-41了解隐式接口和编译期多态">
									条款 41：了解隐式接口和编译期多态
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-42%e4%ba%86%e8%a7%a3-typename-%e7%9a%84%e5%8f%8c%e9%87%8d%e6%84%8f%e4%b9%89" class="nav-条款-42了解-typename-的双重意义">
									条款 42：了解 typename 的双重意义
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-43%e5%ad%a6%e4%b9%a0%e5%a4%84%e7%90%86%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0" class="nav-条款-43学习处理模板化基类内的名称">
									条款 43：学习处理模板化基类内的名称
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-44%e5%b0%86%e4%b8%8e%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e6%8a%bd%e7%a6%bb-templates" class="nav-条款-44将与参数无关的代码抽离-templates">
									条款 44：将与参数无关的代码抽离 templates
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-45%e8%bf%90%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b" class="nav-条款-45运用成员函数模板接受所有兼容类型">
									条款 45：运用成员函数模板接受所有兼容类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e6%97%b6%e8%af%b7%e4%b8%ba%e6%a8%a1%e6%9d%bf%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" class="nav-条款-46需要类型转换时请为模板定义非成员函数">
									条款 46：需要类型转换时请为模板定义非成员函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-47%e8%af%b7%e4%bd%bf%e7%94%a8-traits-classes-%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af" class="nav-条款-47请使用-traits-classes-表现类型信息">
									条款 47：请使用 traits classes 表现类型信息
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-48%e8%ae%a4%e8%af%86-template-%e5%85%83%e7%bc%96%e7%a8%8b" class="nav-条款-48认识-template-元编程">
									条款 48：认识 template 元编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-49%e4%ba%86%e8%a7%a3-new-handler-%e7%9a%84%e8%a1%8c%e4%b8%ba" class="nav-条款-49了解-new-handler-的行为">
									条款 49：了解 new-handler 的行为
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-50%e4%ba%86%e8%a7%a3-new-%e5%92%8c-qelete-%e7%9a%84%e5%90%88%e7%90%86%e6%9b%bf%e6%8d%a2%e6%97%b6%e6%9c%ba" class="nav-条款-50了解-new-和-qelete-的合理替换时机">
									条款 50：了解 new 和 qelete 的合理替换时机
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-51%e7%bc%96%e5%86%99new-%e5%92%8c-delete-%e6%97%b6%e9%9c%80%e5%9b%ba%e5%ae%88%e5%b8%b8%e8%a7%84" class="nav-条款-51编写new-和-delete-时需固守常规">
									条款 51：编写new 和 delete 时需固守常规
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be52%e5%86%99%e4%ba%86-placement-new-%e4%b9%9f%e8%a6%81%e5%86%99-placement-delete" class="nav-条款52写了-placement-new-也要写-placement-delete">
									条款52：写了 placement new 也要写 placement delete
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-53%e4%b8%8d%e8%a6%81%e8%bd%bb%e5%bf%bd%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e8%ad%a6%e5%91%8a" class="nav-条款-53不要轻忽编译器的警告">
									条款 53：不要轻忽编译器的警告
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-54%e8%ae%a9%e8%87%aa%e5%b7%b1%e7%86%9f%e6%82%89%e5%8c%85%e6%8b%ac-tr1-%e5%9c%a8%e5%86%85%e7%9a%84%e6%a0%87%e5%87%86%e7%a8%8b%e5%ba%8f%e5%ba%93" class="nav-条款-54让自己熟悉包括-tr1-在内的标准程序库">
									条款 54：让自己熟悉包括 TR1 在内的标准程序库
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-55%e8%ae%a9%e8%87%aa%e5%b7%b1%e7%86%9f%e6%82%89-boost" class="nav-条款-55让自己熟悉-boost">
									条款 55：让自己熟悉 Boost
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://luckfalcon.github.io/">
            主页
        </a>
        
        <button type="button" class="nav-darkmode-toggle" id="darkModeToggleButton2">
            <i class="material-icons" id="darkModeToggleIcon2">
                dark_mode
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://luckfalcon.github.io/">
        <div class="single-column-header-title">主页</div>
        
        <div class="single-column-header-subtitle">luckfalcon的博客</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    Effectivecpp
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2023-10-23 01:47
                        </time>
                        

                        

                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p><a href="http://luckfalcon.github.io">luckfalcon的github page</a></p>
<h1 id="c编程注意条款">C++编程注意条款</h1>
<ul>
<li>拷贝构造函数 &mdash; 初始化 &mdash;&ndash;A(B)&mdash; 只发生在对象创建时</li>
<li>拷贝赋值运算符 &ndash; 同类型对象值赋值给创建对象 &ndash;A=B</li>
<li>值传递（pass-by-value）&ndash; 调用构造函数</li>
<li>引用传递 (passed-by-reference) &ndash; 不调用构造函数</li>
</ul>
<p>C++四大次级语言</p>
<ul>
<li>c 语言部分编程</li>
</ul>
<hr>
<ul>
<li>class 类编程</li>
</ul>
<hr>
<ul>
<li>template 模板编程</li>
</ul>
<hr>
<ul>
<li>STL 标准库编程</li>
</ul>
<hr>
<h2 id="条款2尽量以-constenuminline-替换-define">条款2：尽量以 const，enum，inline 替换 #define</h2>
<ul>
<li>#define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#1e889b">#define max(a,b) f((a) &gt; (b)? (a) : (b))
</span></span></span><span style="display:flex;"><span><span style="color:#1e889b"></span><span style="color:#00688b;font-weight:bold">int</span> a = <span style="color:#b452cd">5</span>,b = <span style="color:#b452cd">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#008b45">max</span>(++a, b);	<span style="color:#228b22">//a被累加2次
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#008b45">max</span>(++a, b+<span style="color:#b452cd">10</span>);	<span style="color:#228b22">//a被累加1次
</span></span></span></code></pre></div><ul>
<li>enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Test</span>
</span></span><span style="display:flex;"><span>{	
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#8b008b;font-weight:bold">const</span> <span style="color:#00688b;font-weight:bold">int</span> num = <span style="color:#b452cd">1</span>;<span style="color:#228b22">//此处仅为声明而非定义
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#00688b;font-weight:bold">int</span> arr[num];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">const</span> <span style="color:#00688b;font-weight:bold">int</span> num;<span style="color:#228b22">//此处为定义,放在实现文件中而非头文件中
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">enum</span>{num = <span style="color:#b452cd">5</span>}<span style="color:#228b22">//可代替上 static const int 
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Test</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">enum</span> {arr_size = <span style="color:#b452cd">10</span>};<span style="color:#228b22">//在编译器不支持编译期间类内static初值时(仅限整数情况)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#8b008b;font-weight:bold">const</span> <span style="color:#00688b;font-weight:bold">int</span> arr[arr_size];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>const 对象替换 define 常量</li>
<li>inline 函数替换 define 形似函数</li>
</ul>
<h2 id="条款3尽可能使用-const">条款3：尽可能使用 const</h2>
<ul>
<li>令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">//有理数operator*
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Rational</span>{}
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">const</span> Rational <span style="color:#8b008b;font-weight:bold">operator</span>*(<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;lhs,<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;rhs);
</span></span><span style="display:flex;"><span><span style="color:#228b22">//可以避免客户暴力行为如:
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>Rational a,b,c;
</span></span><span style="display:flex;"><span>(a * b) = c;<span style="color:#228b22">//在a*b的结果上调用赋值运算符operator =
</span></span></span></code></pre></div><ul>
<li>const 成员函数，可确保类的 const 对象可被操作</li>
<li>如过函数的返回类型是内置类型，改动函数返回值是非法的</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">text</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">const</span> &amp;<span style="color:#00688b;font-weight:bold">char</span> <span style="color:#8b008b;font-weight:bold">operator</span>[](std::size_t position)<span style="color:#8b008b;font-weight:bold">const</span><span style="color:#228b22">//处理const对象，不可修改对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	{<span style="color:#8b008b;font-weight:bold">return</span> st[position];}
</span></span><span style="display:flex;"><span>	&amp;<span style="color:#00688b;font-weight:bold">char</span> <span style="color:#8b008b;font-weight:bold">operator</span>[](std::size_t position)<span style="color:#228b22">//处理非const对象,可修改对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	{<span style="color:#8b008b;font-weight:bold">return</span> st[position];}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	std::string st;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>将类成员声明为 mutable 类型，可以实现在 const 对象内修改对象的值，但并能完全解决 const 与 non-const 的全部问题。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Text</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	std::size_t length()<span style="color:#8b008b;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">char</span> *ptex;
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">mutable</span> std::size_t textlength;<span style="color:#228b22">//这些变量可以被修改，即使在const对象内部
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">mutable</span> <span style="color:#00688b;font-weight:bold">bool</span> LengthIsValid;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>std::size_t Text:: length()<span style="color:#8b008b;font-weight:bold">const</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">if</span>(!LengthIsValid)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		textlength = strlen(ptex);
</span></span><span style="display:flex;"><span>		LengthIsValid = <span style="color:#658b00">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">return</span> textlength;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>在 const 和 non-const 成员函数中避免重复使用，策略是利用 non-const 调用 const 的版本来实现。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">char</span> <span style="color:#8b008b;font-weight:bold">operator</span>[](std::size_t position)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">return</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">const_cast</span>&lt;<span style="color:#00688b;font-weight:bold">char</span> &amp;&gt;(		<span style="color:#228b22">//将op[]返回值去除const
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>		<span style="color:#8b008b;font-weight:bold">static_cast</span>&lt;<span style="color:#8b008b;font-weight:bold">const</span> text &amp;&gt;(*<span style="color:#8b008b;font-weight:bold">this</span>)<span style="color:#228b22">//为this加上const，调用const op[]
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>		)<span style="color:#228b22">//若不给this加const，则会无限递归自己
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>将某些东西声明为 const 可以帮助编译器检查错误用法。const 可以被加在任何作用域内的对象、函数参数、函数返回类型、成员函数。</li>
<li>编译器强制 bitwise constness (位常量性)，但你编程时应使用 &ldquo;概念上的常量性&rdquo; (conceptual constness)。</li>
<li>当 const 函数与 non-const 函数有等价的实现时，用 non-const 版本调用 const 版本可避免代码重复。</li>
</ul>
<h2 id="条款4确定对象被使用前已先被初始化">条款4：确定对象被使用前已先被初始化</h2>
<ul>
<li>未初始化对象可导致未定义行为 (undefined behavior)，最终导致程序错误。</li>
<li>永远在对象使用之前对其初始化，内置类型直接初始化，类类型由其构造函数完成初始化(类成员初始化发生在构造函数体之前，构造函数体内为赋值，初始化类成员应使用类成员初始化列表)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Obj(<span style="color:#00688b;font-weight:bold">int</span> i_nit,<span style="color:#00688b;font-weight:bold">char</span> c_init,<span style="color:#8b008b;font-weight:bold">const</span> string &amp;s_init)
</span></span><span style="display:flex;"><span>		:i(i_nit),c(c_init),s(s_init){}<span style="color:#228b22">//初始化，通常效率更高
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	Obj(<span style="color:#00688b;font-weight:bold">int</span> i_nit,<span style="color:#00688b;font-weight:bold">char</span> c_init,<span style="color:#8b008b;font-weight:bold">const</span> string &amp;s_init)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		i = i_nit;<span style="color:#228b22">//赋值，会先调用default构造函数，再进行拷贝赋值=
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>		c = c_init;
</span></span><span style="display:flex;"><span>		s = s_init;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">char</span> c;
</span></span><span style="display:flex;"><span>	string s;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>c++对&quot;定义于不同编译单元内的 non-local static 对象&quot;的初始化<strong>次序</strong>并无明确定义。通过设计消除这种情况，做法是，将每个 non-local static 对象搬到自己的专属函数内(该对象在此函数内被声明为 static)。这些函数返回一个 reference 指向它所含的对象。用户调用这些函数获得 static 对象的引用，而非直接使用 static 对象本身。</li>
</ul>
<blockquote>
<p>编译单元 (translation unit) 是指产出单一目标文件 (sigle object file) 的源码。基本上它是单一源码文件加上其所含入的头文件 (#include file)。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Ob1</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Ob1 &amp;obj()<span style="color:#228b22">//在类外定义为内联函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">static</span> Ob1 ob;
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> ob;<span style="color:#228b22">//指向static对象的reference，而不再使用static对象自身
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>内置类型手动初始化。</li>
<li>构造函数使用成员的初始化列表初始化，而非构造函数体内进行赋值，成员初始化次序最好与声明次序相同。</li>
<li>为免除&quot;跨编译单元初始化次序&quot;问题，以 local static 对象替换 non-local static 对象。</li>
</ul>
<h2 id="条款5了解c默默写并调用哪些函数">条款5：了解c++默默写并调用哪些函数</h2>
<ul>
<li>空类，编译器默认生成一个无实参的 default 构造函数、一个有实参拷贝构造函数、一个拷贝赋值运算符、一个析构函数。</li>
<li>用户自定义构造函数后，default 构造函数不指定则编译器不再提供。</li>
<li>对于成员类型为引用的类，编译器默认不生成拷贝赋值运算符(原因是 c++不允许改变引用的对象)。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assighnment 操作符，以及析构函数。</li>
</ul>
<h2 id="条款6若不想使用编译器自动生成的函数就该明确拒绝">条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2>
<ul>
<li>为了阻止类的拷贝赋值行为，你可以通过继承一个基类的拷贝复制操作是 private 的类来实现。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Uncopy</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Uncopy();
</span></span><span style="display:flex;"><span>	~Uncopy();<span style="color:#228b22">//由于非虚函数，会带来多重继承的问题
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	Uncopy(<span style="color:#8b008b;font-weight:bold">const</span> Uncopy&amp;);
</span></span><span style="display:flex;"><span>	Uncopy &amp;<span style="color:#8b008b;font-weight:bold">operator</span> = (<span style="color:#8b008b;font-weight:bold">const</span> Uncopy&amp;);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>:<span style="color:#8b008b;font-weight:bold">private</span> Uncopy{};<span style="color:#228b22">//此时class Obj不再声明copy函数或copy assighnment操作符
</span></span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>为驳回编译器自动提供的技能，可将相应的成员函数声明为 private 并且不予实现，如 uncopy 基类的做法。</li>
</ul>
<h2 id="条款7为多态基类声明virtual析构函数">条款7：为多态基类声明virtual析构函数</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Base</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Base();
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#008b45">function</span>();<span style="color:#228b22">//带有虚成员函数的类才需要虚析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">virtual</span> ~Base();<span style="color:#228b22">//析构函数声明为虚函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">DerivedA</span>:<span style="color:#8b008b;font-weight:bold">public</span> Base{};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">DerivedB</span>:<span style="color:#8b008b;font-weight:bold">protected</span> Base{};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">DerivedC</span> :<span style="color:#8b008b;font-weight:bold">private</span> Base{};
</span></span></code></pre></div><ul>
<li>每个带有 virtual 函数的 class 都有一个相应的 vtbl(virtual table)，在运行时，由 vptr(virtual table pointer) 指出，从而实现带 virtual 函数。将不含 virtual 函数的类的析构函数声明为 virtual 会影响类的可移植性。</li>
<li>基类的析构函数非 virtual 的时，不要使用基类指针指向派生类，否则在销毁基类指针时无法调用派生类的析构函数，从而造成内存泄漏。</li>
<li>pure virtual 析构函数的类为抽象类，无法实例化，只适合做基类。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">virtual</span> ~Obj() = <span style="color:#b452cd">0</span>;<span style="color:#228b22">//纯虚函数,该类为抽象类，无法实例化，只适合做基类
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span><span style="display:flex;"><span>Obj::~Obj(){};<span style="color:#228b22">//纯虚函数的定义,不做这个定义，连接器会出错
</span></span></span></code></pre></div><ul>
<li>并非所有的基类设计都是为多态用途，即不是所有的基类都需要 virtual 析构函数。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>polymorphic (带有多态性质的) base classes应该声明一个 virtual 析构函数。如何 class 带有 virtual 函数，那么应该声明 virtual 析构函数。</li>
<li>classes 的设计目的如果不是作为 base classes 使用，或者不是为了具备多态性 (polymorphically) ，就不应该声明 virtual 析构函数。</li>
</ul>
<h2 id="条款8别让异常逃离析构函数">条款8：别让异常逃离析构函数</h2>
<ul>
<li>c++不希望在类的析构函数中抛出异常(这会导致一些容器由于多个类对象析构异常而导致不明确行为)</li>
<li>转接给客户一次处理异常的机会</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">static</span> obj create();<span style="color:#228b22">//返回一个obj对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">closed</span>();<span style="color:#228b22">//关闭，失败会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Manageobj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> closed()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		closed();<span style="color:#228b22">//非析构函数抛出异常可供用户选择处理,若在析构函数内，用户无法处理，只能选择终止或者忽略异常
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>		closed = <span style="color:#658b00">true</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	~Manageobj()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">if</span>(!closed)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#8b008b;font-weight:bold">try</span>
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>				closed();
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#8b008b;font-weight:bold">catch</span>()
</span></span><span style="display:flex;"><span>			{
</span></span><span style="display:flex;"><span>			<span style="color:#228b22">//记录close调用失败
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>			};
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	Obj oj;
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">bool</span> closed;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(阻止不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通的函数(而非在析构函数中)执行该操作。</li>
</ul>
<h2 id="条款9绝不在构造和析构过程中调用virtual函数">条款9：绝不在构造和析构过程中调用virtual函数</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class (比起当前执行构造函数和析构函数的那层)。</li>
</ul>
<h2 id="条款10令operator--返回一个reference-to-this">条款10：令operator = 返回一个reference to *this</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Obj &amp;<span style="color:#8b008b;font-weight:bold">operator</span> = (<span style="color:#8b008b;font-weight:bold">const</span> Obj&amp;rhs)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#228b22">//...
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>		<span style="color:#8b008b;font-weight:bold">return</span> *<span style="color:#8b008b;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>	}<span style="color:#228b22">//为了实现 x = y = z = Value;
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>令赋值(assignment)操作符返回一个reference to *this。</li>
</ul>
<h2 id="条款11在-operator--中处理自我赋值">条款11：在 operator = 中处理“自我赋值”</h2>
<ul>
<li>让 operator = 具备&quot;异常安全性&quot;同时也会获得&quot;自我赋值安全&quot;。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Op</span>{};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	Op *ptr; <span style="color:#228b22">//类成员含有指针或引用
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span><span style="display:flex;"><span>Obj &amp;Obj::<span style="color:#8b008b;font-weight:bold">operator</span> = (<span style="color:#8b008b;font-weight:bold">const</span> Obj &amp;rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Op *p = ptr;		<span style="color:#228b22">//记住原先的ptr
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	ptr = <span style="color:#8b008b;font-weight:bold">new</span> Op(rhs.ptr);<span style="color:#228b22">//令ptr指向*ptr的一个副本
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">delete</span> p;			<span style="color:#228b22">//删除原先的ptr
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">return</span> *<span style="color:#8b008b;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>复制交换 (copy and swap) 技术，可以作为上述方案的替代方案。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Op</span>{};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> swap(Obj &amp;rhs);
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	Op *ptr; <span style="color:#228b22">//类成员含有指针或引用
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span><span style="display:flex;"><span>Obj &amp;Obj::<span style="color:#8b008b;font-weight:bold">operator</span> = (<span style="color:#8b008b;font-weight:bold">const</span> Obj &amp;rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Op <span style="color:#008b45">temp</span>(rhs);<span style="color:#228b22">//将rhs数据制作一份副本
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	swap(temp);<span style="color:#228b22">//将*this数据和上述副本的数据交换
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">return</span> *<span style="color:#8b008b;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#228b22">//值传递(passed by value)--有时候可令编译器生成高效的代码
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>Obj &amp;Obj::<span style="color:#8b008b;font-weight:bold">operator</span> = (Obj rhs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	swap(ths);
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">return</span> *<span style="color:#8b008b;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>确保当对象自我赋值时 perator = 有良好的行为。其中的技术包括比较&quot;来源对象&quot;和&quot;目标对象&quot;的地址、精心周到的语句顺寻、以及 copy-and-swap。</li>
<li>确定任何函数如何操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
<h2 id="条款12复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</h2>
<ul>
<li>derived class 的 base class 成分在 derived class 的构造函数中应调用 base class 的构造函数完成。</li>
<li>不应该令 copy assignment 操作符调用 copy 构造函数，反之也同样没有意义。</li>
<li>如果 copy assignment 操作符和 copy 构造函数有相同重复的代码，通常在 private 区设置一个 init 函数将相同部分代码包含进去。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li><em><strong>copy</strong></em>函数 (copy assignment 操作符和 copy 构造函数统称) 应该确保复制&quot;对象内的所有成员变量&quot;及&quot;所有 base class 成分&quot;。</li>
<li>不要尝试以某个 copy 函数实现另一个 copy 函数。应该将共同机能放进第三个函数中，并由两个 copy 函数共同调用。</li>
</ul>
<h2 id="条款13以对象管理资源">条款13：以对象管理资源</h2>
<ul>
<li>获取资源后立即放进管理对象内，管理对象运用析构函数确保资源被释放。以对象管理资源常被称为资源取得时机便是初始化时机 (Resource Acquisition Is Initialization,<em><strong>RAII</strong></em>)。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	Obj *create();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">f</span>()
</span></span><span style="display:flex;"><span>{		<span style="color:#228b22">//c++11后已经弃用auto_ptr,用unique_ptr代替
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#228b22">//这样做的前提是绝对没有一个以上的auto_ptr同时指向该对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	std::auto_ptr&lt;Obj&gt;p_Obj(create());<span style="color:#228b22">//auto_ptr为一个类指针对象模板
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#228b22">//...
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><ul>
<li>auto_ptrs 一个特殊性质：若通过 (copy assignment 操作符和 copy 构造函数复制它们，它们会变成 null，而复制所得的指针将取得资源的唯一拥有权。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std::auto_ptr1&lt;Obj&gt;p_Obj(create());<span style="color:#228b22">//ptr1指向create返回对象
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	std::auto_ptr2(ptr1);		<span style="color:#228b22">//ptr2指向该对象，ptr1被置为null
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	ptr1 = ptr2;			<span style="color:#228b22">//ptr1指向该对象，ptr2被置为null
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><ul>
<li>克服 auto_ptr 的弊端，改用引用计数智能指针 (reference-counting smart pointer,RCSP)，如 shared_ptr。</li>
<li>没有针对 &ldquo;c++动态分配数组&rdquo; 的智能指针，因为 vector 和 string 几乎可以完全代替动态分配数组。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获取资源并在析构函数中释放资源。</li>
<li>两个常用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr(c++11后用 unique_ptr)。前者通常是最佳选择，因为其 copy 行为比较直观。若选择 auto_ptr，复制动作会使它 (被复制物) 指向 null。</li>
</ul>
<h2 id="条款14在资源管理类中小心coping行为">条款14：在资源管理类中小心coping行为</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为 (通常需要深拷贝) 决定 RAII 对象的 copying 行为。</li>
<li>普通而常见的 RAII class copying 行为：抑制 copying、(可用 shared_ptr) 施行引用计数方法 (reference counting)。不过其他行为也都可能实现。</li>
</ul>
<h2 id="条款15在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>APIs 往往要求访问原始资源 (raw resources)，所以每个 RAII class 应该提供一个&quot;取得其所管理之资源&quot;的办法。</li>
<li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
<h2 id="条款16成对使用new和delete时要采用相同形式">条款16：成对使用new和delete时要采用相同形式</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>new 表达式中使用 []，必须在相应的 delete 表达式中也使用[]。new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。</li>
</ul>
<h2 id="条款17以独立语句将-newed-对象置入智能指针">条款17：以独立语句将 newed 对象置入智能指针</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>{};
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">int</span> <span style="color:#008b45">func1</span>();
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">func2</span>(shared_ptr&lt;obj&gt;,<span style="color:#00688b;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span>func2(shared_ptr&lt;obj&gt;(<span style="color:#8b008b;font-weight:bold">new</span> obj),func1());
</span></span><span style="display:flex;"><span><span style="color:#228b22">//此处编译器要进行三个过程，new Obj、调用shared_ptr初始化指针、调用func1,
</span></span></span><span style="display:flex;"><span><span style="color:#228b22">//但三者没有固定顺序，若func1发生在其它两个过程之间，且发生异常，则会导致new Obj发生泄漏
</span></span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>以独立语句将 newed 对象存入(置入)智能指针内。如果不这样，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</li>
</ul>
<h2 id="条款18让接口容易被正确使用不易被误用">条款18：让接口容易被正确使用，不易被误用</h2>
<ul>
<li>尽量让你的 types 的行为与内置 types 一致。</li>
<li>返回 shared_ptr 让接口设计者得以阻止大部分资源泄漏错误。</li>
<li>智能指针管理非 new 的资源时需要手动传入一个删除器。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达到这个性质。</li>
<li>&ldquo;促进争取使用&quot;的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>&ldquo;阻止误用&quot;的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>shared_ptr 支持定制型删除器 (custom deleter)。这可防止 DLL (动态链接库)问题，可被用来自动解除互斥锁 (mutexes) 等等。</li>
</ul>
<blockquote>
<p>所谓的 &ldquo;cross-DLL problem&rdquo;，这个问题发生于&quot;对象在动态连接程序库 (DLL) 中被 new 创建，却在另一个 DLL 内被 delete
销毁&rdquo;。</p>
</blockquote>
<h2 id="条款19设计-class-犹如设计-type">条款19：设计 class 犹如设计 type</h2>
<blockquote>
<p>新 class 设计规范问题：</p>
</blockquote>
<ul>
<li>新的 type 应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新 type 对象如果被 passed by value (以值传递)，意味着什么？</li>
<li>什么是新 type 的&quot;合法值&rdquo;？</li>
<li>你的新 type 需要配合某个继承图系 (inheritance graph) 吗？</li>
<li>你的新 type 需要什么样的转换？</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新 type 的成员？</li>
<li>什么是新 type 的&quot;未声明接口&quot;？</li>
<li>你的新 type 有多么一般化？</li>
<li>你真的需要一个新 type 吗？</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>class 的设计就是 type 的设计。在定义一个新type时请考虑以上问题。</li>
</ul>
<h2 id="条款20宁可以-passed-by-reference-to-const-替换-passed-by-value">条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value</h2>
<ul>
<li>缺省情况下 C++ 以 by value 方式传递对象至函数。</li>
<li>一般而言，pass by value 唯一对象是内置类型和 STL 的迭代器和函数对象。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>尽量以 passed-by-reference-to-const 替换 passed-by-value。前者通常高效，并可避免切割问题 (slicing problem)。</li>
<li>以上规则不适合内置类型，以及STL的迭代器和函数对象。对它们而已，passed-by-value往往比较适当。</li>
</ul>
<h2 id="条款21必须返回对象时别妄想返回其reference">条款21：必须返回对象时，别妄想返回其reference</h2>
<ul>
<li>一个&quot;必须返回新对象&quot;的正确写法：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Rational</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	 Rational(<span style="color:#00688b;font-weight:bold">int</span> numerator = <span style="color:#b452cd">0</span>,<span style="color:#00688b;font-weight:bold">int</span> denominator = <span style="color:#b452cd">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">int</span> n;<span style="color:#228b22">//分子(numerator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#00688b;font-weight:bold">int</span> d;<span style="color:#228b22">//分母(denominator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">friend</span> <span style="color:#8b008b;font-weight:bold">const</span> Rational <span style="color:#8b008b;font-weight:bold">operator</span>*(<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;lhs,<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;rhs)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">Rational</span>(lhs.n*rhs.n,lhs.d*rhs.d);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。</li>
</ul>
<h2 id="条款22将成员变量声明为-private">条款22：将成员变量声明为 private</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected 并不比 public 更具封装性。</li>
</ul>
<h2 id="条款23宁以-non-membernon-friend-替换-member-函数">条款23：宁以 non-member、non-friend 替换 member 函数</h2>
<ul>
<li>将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以扩展这一组便利函数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">// class_def.h
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">namespace</span> name
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span> 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> fun1();
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">fun2</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">fun3</span>();
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">do_fun1</span>(Obj &amp;oj){oj.fun1();}<span style="color:#228b22">//核心机能，包含客户都需要的non-member函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">do_fun3</span>(Obj &amp;oj){oj.fun3();}<span style="color:#228b22">//非成员函数可以进一步提高class的封装性
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span><span style="display:flex;"><span><span style="color:#228b22">//fun1_use.h//客户扩展头文件
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">namespace</span> name
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">fun1</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>宁以拿 non-member、non-friend 替换 member 函数。这样可以增加封装性、包裹弹性 (packaging flexibility) 和机能扩充性。</li>
</ul>
<h2 id="条款24若所有参数皆需类型转换请为此采用-non-member-函数">条款24：若所有参数皆需类型转换，请为此采用 non-member 函数</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Rational</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	 Rational(<span style="color:#00688b;font-weight:bold">int</span> numerator = <span style="color:#b452cd">0</span>,<span style="color:#00688b;font-weight:bold">int</span> denominator = <span style="color:#b452cd">1</span>);
</span></span><span style="display:flex;"><span>	 <span style="color:#00688b;font-weight:bold">int</span> <span style="color:#008b45">numerator</span>()<span style="color:#8b008b;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>	 <span style="color:#00688b;font-weight:bold">int</span> <span style="color:#008b45">denominator</span>()<span style="color:#8b008b;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">int</span> n;<span style="color:#228b22">//分子(numerator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#00688b;font-weight:bold">int</span> d;<span style="color:#228b22">//分母(denominator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span><span style="display:flex;"><span><span style="color:#228b22">//非成员友元函数声明方式
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">const</span> Rational <span style="color:#8b008b;font-weight:bold">operator</span>*(<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;lhs,<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;rhs)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">Rational</span>(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator());
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>如果你需要为某个函数的所有参数 (包括被 this 指针所指的那个隐喻参数) 进行类型转换，那么这个函数必须是 non-member 函数。</li>
</ul>
<h2 id="条款25考虑写出一个不抛出异常的-swap-函数">条款25：考虑写出一个不抛出异常的 swap 函数</h2>
<ul>
<li>所有的 STL 容器都提供有一个 public swap 成员函数和 std::swap 特化版本 (用以调用前者)。</li>
<li>c++ 只允许对 class template 偏特化 (partially specialize)，但不能对 function template 偏特化。</li>
<li>c++ std 空间可以全特化所有内含 template，但不可以添加新的 template 进去。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">namespace</span> name_obj
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#00688b;font-weight:bold">void</span> swap(<span style="color:#8b008b;font-weight:bold">const</span> Obj &amp;b){<span style="color:#8b008b;font-weight:bold">using</span> std::swap;};
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">swap</span>(Obj&lt;T&gt; &amp;a,Obj&lt;T&gt; &amp;b){a.swap(b);}<span style="color:#228b22">//合法
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">namespace</span> std<span style="color:#228b22">//在std内特化
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>{
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;&gt;
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> swap&lt;Obj&gt;(obj &amp;a,Obj &amp;b){a.swap(b);};<span style="color:#228b22">//特例化某个类，合法
</span></span></span><span style="display:flex;"><span><span style="color:#228b22">//Obj成为类模板的时
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> swap&lt;Obj&lt;T&gt;&gt;(Obj&lt;T&gt; &amp;a,Obj&lt;T&gt; &amp;b){a.swap(b);}<span style="color:#228b22">//函数模板偏特化，错误，不合法
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> swap(Obj&lt;T&gt; &amp;a,Obj&lt;T&gt; &amp;b){a.swap(b);}<span style="color:#228b22">//也不合法
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><blockquote>
<p>pimpl 是 &ldquo;pointer to implementation&rdquo; 的缩写。</p>
</blockquote>
<ul>
<li>swap 的版本包含，default swap (适合不含指针成员的类或类模板)、member swap、non-member swap、std::swap 特化版。</li>
<li>如果缺省 swap 效率不足 (class 或 template 使用了某种 pimpl 手法)，可试以下方法：</li>
</ul>
<blockquote>
<ol>
<li>提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值。该函数不应抛出异常。</li>
<li>在你的 class 或 template 所在的命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。</li>
<li>如果你正编写一个 class (而非 class template)，为你的 class 特化 std::swap。并令它调用你的 swap 成员函数。</li>
</ol>
</blockquote>
<ul>
<li>swap 一个最好的应用是帮助 classes( 和 class templates) 提供强烈的异常 (exception-safety) 保障。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>当 std::swap 对你的类型效率不高时，提供一个成员 swap 函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于 class (而非 template)，也请特化 std::swap。</li>
<li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何&quot;命名空间资格修饰&quot;。</li>
<li>为&quot;用户定义类型&quot;进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。</li>
</ul>
<blockquote>
<p><del><em><strong>实现 (implementations)</strong></em></del></p>
</blockquote>
<h2 id="条款26尽可能延后变量定义式的出现时间">条款26：尽可能延后变量定义式的出现时间</h2>
<ul>
<li>目的是减少不必要的对象构造和析构</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Obj</span>{};
</span></span><span style="display:flex;"><span>Obj oj;	<span style="color:#228b22">//A：1次构造+1次析构+n次赋值				
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">for</span>(<span style="color:#00688b;font-weight:bold">int</span> i;i &lt; n;++i)	
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	oj = i;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#228b22">//
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">for</span>(<span style="color:#00688b;font-weight:bold">int</span> i;i &lt; n;++i)	
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Obj oj;	<span style="color:#228b22">//B：n次构造+n次析构，通常B比A更高效一点，除非，赋值比构造+析构成本低
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	oj = i;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
<h2 id="条款27尽量少做转型动作">条款27：尽量少做转型动作</h2>
<ul>
<li>c++ 类型转换形式 :</li>
</ul>
<table>
<thead>
<tr>
<th>const_cast<!-- raw HTML omitted -->(expression)</th>
<th>dynamic_cast<!-- raw HTML omitted -->(expression)</th>
<th>reinterpret_cast<!-- raw HTML omitted -->(expression)</th>
<th>static_cast<!-- raw HTML omitted -->(expression)</th>
</tr>
</thead>
<tbody>
<tr>
<td>const 到 non-const 转换</td>
<td>运行时，安全向下类型转换</td>
<td>执行低级转型</td>
<td>除去 const 到 non-const 的转换，其他一般类型转换</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码内。</li>
<li>宁可使用 C++-style (新式) 转型，不要使用旧式转型。前者容易辨识出来，而且也比较有着分门别类的执掌。</li>
</ul>
<h2 id="条款28避免返回-handles-指向对象内部成分">条款28：避免返回 handles 指向对象内部成分</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>避免 handles (包括 references、指针、迭代器)指向对象内部。遵守这个条款可以增加封装性，帮助 const 成员函数的行为像个 const，并将发生&quot;虚吊号码牌&quot;(dangling handles) 可能降到最低。</li>
</ul>
<blockquote>
<p>虚吊号码牌：使用已经销毁的对象的引用、指针或迭代器。</p>
</blockquote>
<h2 id="条款29为异常安全而努力是值得的">条款29：为&quot;异常安全&quot;而努力是值得的</h2>
<ul>
<li>异常安全性两个条件：</li>
</ul>
<blockquote>
<ol>
<li>异常抛出时，不泄漏任何资源。</li>
<li>异常抛出时，不允许数据败坏。</li>
</ol>
</blockquote>
<ul>
<li>异常安全函数提供三种不同级别保证：</li>
</ul>
<table>
<thead>
<tr>
<th>基本保证</th>
<th>强烈保证</th>
<th>不抛保证</th>
</tr>
</thead>
<tbody>
<tr>
<td>异常抛出后，程序内所有事物保持有效状态，这些状态是未预知的</td>
<td>异常抛出后，程序状态不改变，回到被调用前状态</td>
<td>承诺不抛出异常，因其总能完成原有的功能。作用于内置类型所有操作应提供 nothrow 保证</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>异常安全函数 (Exception-safty functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>&ldquo;强烈保证&rdquo; 往往能够以 copy-and-swap 实现出来，但&quot;强烈保证&quot;并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供 &ldquo;异常安全保证&rdquo; 通常最高只等于其所调用之各个函数的&quot;异常安全保证&quot;中的最弱者。</li>
</ul>
<h2 id="条款30透彻了解-inlining-的里里外外">条款30：透彻了解 inlining 的里里外外</h2>
<ul>
<li>inlining 在大多数 c++ 程序中是编译期行为。</li>
<li>inline 函数通常一定被置于头文件中，通常置于函数本体小的函数前，向编译器申请在调用处替换展开本体，但非强制命令，编译器可忽略。</li>
<li>对于函数本体较大的函数 inlining 会引发代码膨胀。</li>
<li>编译器通常不会对 &ldquo;通过函数指针而进行的调用&rdquo; 实施 inlining。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 (binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为 function templates 出现在头文件，就将它们声明为 inline。</li>
</ul>
<h2 id="条款31将文件间的编译依存关系降至最低">条款31：将文件间的编译依存关系降至最低</h2>
<ul>
<li>将接口与实现分离。</li>
<li>编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其
他文件内的声明式〈而非定义式) 相依 &ndash; 该设计策略如下：</li>
</ul>
<blockquote>
<ol>
<li>如果使用 object references 或 object pointers 可以完成任务，就不要使用
objects。</li>
<li>如果能够，尽量以 class 声明式替换 class 定义式。</li>
<li>为声明式和定义式提供不同的头文件。</li>
</ol>
</blockquote>
<ul>
<li>Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性〈compilation dependencies) 。</li>
</ul>
<blockquote>
<ol>
<li>在 Handle classes 身上，成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。</li>
<li>至于 Interface classes，由于每个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃 〈indirect jump) 成本(见条款 7) 。</li>
</ol>
</blockquote>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>支持 &quot; 编译依存性最小化 &quot; 的一般构想是: 相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。</li>
<li>程序库头文件应该以 &quot; 完全且仅有声明式 &quot; (full and declaration-only forms) 的形式存在。这种做法不论是否涉及templates 都适用。</li>
</ul>
<blockquote>
<p>六、继承与面向对象</p>
</blockquote>
<h2 id="条款32确定你的-public-继承塑模出-is-a-关系">条款32：确定你的 public 继承塑模出 is-a 关系</h2>
<ul>
<li>以 C++ 进行面向对象编程，最重要的一个规则是：public inheritance (公开继承) 意味 &ldquo;is-a&rdquo;〈是一种) 的关系。</li>
<li>is-a 并非是唯一存在于 classes 之间的关系。另两个常见的关系是 has-a(有一个) 和 is-implemented-in-terms-of (根据某物实现出)。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>&ldquo;public 继承&quot;意味 is-a。适用于 base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</li>
</ul>
<h2 id="条款-33避免遮掩继承而来的名称">条款 33：避免遮掩继承而来的名称</h2>
<ul>
<li>内层作用域的名称会遮掩 (遮蔽) 外围作用域的名称。</li>
<li>编译器查找名称规则由内层作用域查找到名称后即停止查找，并不关注类型。</li>
<li>derived class 作用域被嵌套在 base class 作用域内。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>derived classes 内的名称会遮掩 base classes 内的名称。 在 public 继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数 (forwarding functions) 。</li>
</ul>
<blockquote>
<p>using 声明式和转交函数：</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">base</span>{ <span style="color:#8b008b;font-weight:bold">public</span>: <span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> fun1(<span style="color:#00688b;font-weight:bold">int</span> x);};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived1</span> : <span style="color:#8b008b;font-weight:bold">public</span> base
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#8b008b;font-weight:bold">using</span> base::fun1;
</span></span><span style="display:flex;"><span>   <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">fun1</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived1</span> : <span style="color:#8b008b;font-weight:bold">private</span> base
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> fun1()<span style="color:#228b22">//转交函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>   {
</span></span><span style="display:flex;"><span>   	base::fun1();
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="条款-34区分接口继承和实现继承">条款 34：区分接口继承和实现继承</h2>
<ul>
<li>pure virtual 函数有两个最突出的特性：它们必须被任何 &quot; 继承了它们 &quot; 的具象 class 重新声明，而且它们在抽象 class 中通常没有定义。</li>
</ul>
<blockquote>
<p>声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。</p>
</blockquote>
<ul>
<li>derived classes 继承其函数接口, 但 impure virtual 函数会提供一份实现代码, derived classes 可能覆写 (override) 它。</li>
</ul>
<blockquote>
<p>声明简朴的(非纯) impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。</p>
</blockquote>
<ul>
<li>声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。</li>
</ul>
<table>
<thead>
<tr>
<th>pure virtual 函数</th>
<th>simple (impure) virtual 函数</th>
<th>non-virtual 函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>只继承接口</td>
<td>继承接口和一份缺省实现</td>
<td>继承接口和一份强制实现</td>
</tr>
</tbody>
</table>
<ul>
<li>&quot; 80 - 20 &quot; 法则：一个典型的程序有 80% 的执行时间花费在 20 % 的代码身上。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。</li>
<li>pure virtual 函数只具体指定接口继承。</li>
<li>简朴的(非纯) impure virtual 函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h2 id="条款-35考虑-virtual-函数以外的其他选择">条款 35：考虑 virtual 函数以外的其他选择</h2>
<ul>
<li>通过 Non-Virtual Interface 手法实现 Template Method 模式：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Base</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">int</span> fun()<span style="color:#8b008b;font-weight:bold">const</span><span style="color:#228b22">//这个no-virtual 函数为 virtual 函数的外覆器 (wrapper)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#00688b;font-weight:bold">int</span> relval=dofun();
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> relval;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">int</span> dofun()<span style="color:#8b008b;font-weight:bold">const</span>{...};
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>令客户通过 public non-virtual 成员函数间接调用 private virtual 函数 &ndash; 为 non-virtual interface (NVI) 手法。</p>
</blockquote>
<blockquote>
<p>derived classes 可重新定义继承而来的 private virtual 函数。</p>
</blockquote>
<ul>
<li>通过 Function Pointers 实现 Strategy 模式</li>
<li>通过 函数模板 function &lt; T &gt; 完成 Strategy 模式</li>
</ul>
<blockquote>
<p>trl1: :bind，可改变可调对象入口参数个数和顺序，同时返回一个新的可调对象。</p>
</blockquote>
<ul>
<li>古典的 Strategy 模式 (设计模式 (design patterns))。</li>
</ul>
<blockquote>
<p>几种 virtual 函数替代方案如下：</p>
</blockquote>
<ol>
<li>使用 non-virtual interface (NVI) 手法，那是 Template Method 设计模式的一种特殊形式。它以 public non-virtual 成员函数包庄较低访问性(private 或 protected)的 virtual 函数。</li>
<li>将 virtual 函数替换为 &quot; 函数指针成员变量 &ldquo;，这是 Strategy 设计模式的一种分解表现形式。</li>
<li>以 trl::function 成员变量替换 virtual 函数，因而允许使用任何可调用物(callable entity ) 搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。</li>
<li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 Strategy 设计模式的传统实现手法。</li>
</ol>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>virtual 函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式。NVI手法自身是一个特殊形式的 Template Method 设计模式。</li>
<li>将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public 成员。</li>
<li>trl::function 对象的行为就像一般函数指针。这样的对象可接纳 &quot; 与给定之目标签名式 (target signature) 兼容 &quot; 的所有可调用物(callable entities)。</li>
</ul>
<h2 id="条款-36绝不重新定义继承而来的-non-virtual-函数">条款 36：绝不重新定义继承而来的 non-virtual 函数</h2>
<ul>
<li>derived classes 绝对不该重新定义一个继承而来的non-virtual 函数〈此处指的是 base class 析构函数) 。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>绝对不要重新定义继承而来的 non-virtual 函数。</li>
</ul>
<h2 id="条款-37-绝不重新定义继承而来的缺省默认参数值">条款 37: 绝不重新定义继承而来的缺省(默认)参数值</h2>
<ul>
<li>只能继承两种函数: virtual 和 non-virtual 函数。</li>
<li>virtual 函数系动态绑定(dynamically bound) ，而缺省(默认)参数值却是静态绑定〈statically bound) 。</li>
</ul>
<blockquote>
<p>对象的所谓静态类型 〈static type) ，就是它在程序中被声明时所采用的类型。</p>
</blockquote>
<blockquote>
<p>对象的所谓动态类型(dynamic tvpe) 则是指 &quot; 目前所指对象的类型 &ldquo;。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">base</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> set(base b = bs)<span style="color:#8b008b;font-weight:bold">const</span> = <span style="color:#b452cd">0</span>;<span style="color:#228b22">//带有默认参数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}<span style="color:#a61717;background-color:#e3d2d2">；</span>
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived</span>:<span style="color:#8b008b;font-weight:bold">public</span> base
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> set(base b = bs)<span style="color:#8b008b;font-weight:bold">const</span>;<span style="color:#228b22">//会出现重复定义
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">set</span>(base b = ds)<span style="color:#8b008b;font-weight:bold">const</span>;<span style="color:#228b22">//默认参数不一样
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">set</span>(base b)<span style="color:#8b008b;font-weight:bold">const</span>;<span style="color:#228b22">//动态绑定(base指针引用访问时)时才会继承base默认参数，
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#228b22">//静态绑定(derived对象访问)时不会继承默认参数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span></code></pre></div><ul>
<li>条款35列了不少 virtual 函数的替代设计，其中之一是 NVI (non-virtual interface) 手法令 base class 内的一个 public non-virtual 函数调用 private virtual 函
数，后者可被 derived classes 重新定义。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数一一你唯一应该覆写的东西一一却是动态绑定。</li>
</ul>
<h2 id="条款-38-通过复合塑模出-has-a-或--根据某物实现出-">条款 38: 通过复合塑模出 has-a 或 “ 根据某物实现出 ”</h2>
<ul>
<li>复合(composition) 是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系</li>
</ul>
<blockquote>
<p>复合(composition) 这个术语有许多同义词，包括 layering (分层) ，constainment(内含) , aggregation (聚合) 和 embedding (内嵌)。</p>
</blockquote>
<ul>
<li>应用域(appjicarion domain)与实现域(implementation domain)</li>
</ul>
<blockquote>
<ol>
<li>程序中的对象其实相当于你所塑造的世界中的某些事物(如人、汽车)，这样的对象属于应用域 (appjicarion domain) 部分。</li>
<li>其他对象则纯粹是实现细节上的人工制品(如缓冲区、互斥锁)，这些对象相当于你的软件的实现域。</li>
<li>当复合发生于应用域内的对象之间，表现出 has-a 的关系; 当它发生于实现域内则是表现 is-implemented-in-terms-of 的关系。</li>
</ol>
</blockquote>
<ul>
<li>set 和 list 的关系非 is-a 关系，而是 is-implemented-in-terms-of 关系。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>复合(composition) 的意义和 public 继承完全不同。</li>
<li>在应用域 (application domain) ，复合意味 has-a (有一个)。在实现域(implementation domain) ，复合意味 is-implemented-in-terms-of (根据某物实现出) 。</li>
</ul>
<h2 id="条款-39-明智而审慎地使用-private-继承">条款 39: 明智而审慎地使用 Private 继承</h2>
<ul>
<li>Private 继承意味 is-implemented-in-terms-of (根据某物实现出)。</li>
<li>尽可能使用复合，必要时才使用 private 继承。</li>
<li>private 继承主要用于 &quot; 当一个意欲成为 derived class 者想访问一个意欲成为 base class 者的 protected 成分，或为了重新定义一或多个 virtual 函数 &ldquo;。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">empty</span>{};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">sizeof</span>(empty) = <span style="color:#b452cd">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived</span>:<span style="color:#8b008b;font-weight:bold">private</span> empty
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#00688b;font-weight:bold">int</span> x;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">sizeof</span>(derived)==<span style="color:#8b008b;font-weight:bold">sizeof</span>(<span style="color:#00688b;font-weight:bold">int</span>);
</span></span><span style="display:flex;"><span><span style="color:#228b22">//编译器 EBO (empty base optimization; 空白基类最优化)，一般发生在单一继承才可行，多继承则不会发生。
</span></span></span></code></pre></div><blockquote>
<ul>
<li>现实中的 &quot; empty &quot; classes 并不真的是 empty，往往内含 typedefs，enums， static 成员变量，或 non-virtual 函数。</li>
<li>许多技术用途的 empty classes，其中内含有用的成员 (通常是 typedefs)，包括 base classes unary_function 和 binary_function，这些是 &quot; 用户自定义之函数对象 &quot; 通常会继承的 classes。</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>Private 继承意味 is-implemented-in-terms of (根据某物实现出) 。它通常比复合(composition) 的级别低。但是当 derived class 需要访问 protected base class 的
成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
<li>和复合(composition) 不同，private 继承可以造成 empty base 最优化。这对致力于 &quot; 对象尺寸最小化 &quot; 的程序库开发者而言，可能很重要。</li>
</ul>
<h2 id="条款-40-明智而审慎地使用多重继承">条款 40: 明智而审慎地使用多重继承</h2>
<ul>
<li>多重继承(multiple inheritance；MI)，单一继承 (single inheritance; SI)。</li>
<li>C++ 用来解析 (resolving)重载函数调用的规则：在看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。</li>
<li>多重继承会导致二义性问题(避免继承得来的成员变量重复)，通常采用 virtual 继承:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived</span>:<span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#8b008b;font-weight:bold">public</span> base1, <span style="color:#8b008b;font-weight:bold">virtual</span> <span style="color:#8b008b;font-weight:bold">public</span> base2{};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li>
<li>virtual 继承会增加大小、速度、初始化〈及赋值) 复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及 &quot; public 继承某个 Interface class &quot; 和 &quot; private 继承某个协助实现的 class &quot; 的两相组合。</li>
</ul>
<blockquote>
<p>七、模板与泛型编程</p>
</blockquote>
<h2 id="条款-41了解隐式接口和编译期多态">条款 41：了解隐式接口和编译期多态</h2>
<ul>
<li>面向对象编程世界总是以显式接口 (explicit interfaces) 和运行期多态 (runtime polymorphism) 解决问题。</li>
<li>Templates 及泛型编程的世界以隐式接口 (implicit interfaces) 和编译期多态 (compile-time polymorphism) 为主。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>classes 和 templates 都支持接口 (interfaces) 和多态 (polymorphism) 。</li>
<li>对 classes 而言接口是显式的(explicit), 以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li>
<li>对 template 参数而言，接口是隐式的 (implicit) ，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析 (function overloading resolution ) 发生于编译期。</li>
</ul>
<h2 id="条款-42了解-typename-的双重意义">条款 42：了解 typename 的双重意义</h2>
<ul>
<li>C++ 有个规则可以解析 (resoive) 此一歧义状态：如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。</li>
</ul>
<blockquote>
<ul>
<li>template 内出现的名称如果相依于某个 template 参数，称之为从属名称 (dependent names)。</li>
<li>如果从属名称在 class 内呈嵌套状，我们称它为嵌套从属名称 (nested dependent rame) 。</li>
</ul>
</blockquote>
<ul>
<li>只要在嵌套从属名称之前放置关键字 typename，即可告知解析器该名称为类型。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">typename</span> T::const_iterator it();<span style="color:#228b22">//告知解析器T::const_iterator 为类型
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>T t;
</span></span><span style="display:flex;"><span><span style="color:#228b22">//T 非嵌套从属名称
</span></span></span></code></pre></div><ul>
<li>typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 mermber initialization list (成员初值列) 中作为 base class 修饰符。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">derived</span>:<span style="color:#8b008b;font-weight:bold">public</span> base&lt;T&gt;::nested <span style="color:#228b22">// base classes list
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">explicit</span> derived(<span style="color:#00688b;font-weight:bold">int</span> x):base&lt;T&gt;::nested(x)	<span style="color:#228b22">//成员列表初始化
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">typename</span>  base&lt;T&gt;::nested temp;
</span></span><span style="display:flex;"><span>		<span style="color:#228b22">//...
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>声明 template 参数时，前缀关键字 class 和typename 可互换。</li>
<li>请使用关键字 typename 标识嵌套从属类型名称; 但不得在 base class lists (基类列) 或 member initialization list (成员初值列) 内以它作为 base class 修饰符。</li>
</ul>
<h2 id="条款-43学习处理模板化基类内的名称">条款 43：学习处理模板化基类内的名称</h2>
<ul>
<li>模板化基类 (templatized base classes )内的函数名称会被 derived classes 掩盖。</li>
<li>若基类模板存在特例化版本，则在 derived class template 的时候会发生编译错误，这时可以将 derived class template 涉及 base class template 的成员函数前加 &quot; this-&gt; &quot; 来指涉 base class template 内的函数。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>可在 derived class templates 内通过 &ldquo;this-&gt;&rdquo; 指涉 base class templates 内的成员名称，或通过一个明白写出的 &quot; base class 资格修饰符 &quot; 完成。</li>
</ul>
<h2 id="条款-44将与参数无关的代码抽离-templates">条款 44：将与参数无关的代码抽离 templates</h2>
<ul>
<li>共性与变性分析 (commonality and variability analysis)</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数 (non-type template parameters) 而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数 (type parameters) 而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述 (binary representations) 的具现类型 (instantiation types) 共享实现码。</li>
</ul>
<h2 id="条款-45运用成员函数模板接受所有兼容类型">条款 45：运用成员函数模板接受所有兼容类型</h2>
<ul>
<li>如果以带有 base-derived 关系的 B, D 两类型分别具现化某个 template，产生出来的两个具现体并不带有 base-derived 关系。</li>
<li>Templates 和泛型编程 ( Generic Programming )</li>
<li>泛化(generalized) copy构造函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">SmartPtr</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#228b22">//泛化copy构造函数,并保证只根据U生成T对象,保证public继承的隐式转换
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#228b22">//泛化copy构造函数不等于copy构造函数，如果需要控制copy行为，还需自定义copy构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	SmartPtr(<span style="color:#8b008b;font-weight:bold">const</span> SmartPtr &amp;sptr);<span style="color:#228b22">//普通copy构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> U&gt;		<span style="color:#228b22">//泛化copy构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	SmartPtr(<span style="color:#8b008b;font-weight:bold">const</span> SmartPtr&lt;U&gt; &amp;other):heldPtr(other.get())
</span></span><span style="display:flex;"><span>	{...}
</span></span><span style="display:flex;"><span>	T *<span style="color:#008b45">get</span>()<span style="color:#8b008b;font-weight:bold">const</span> {<span style="color:#8b008b;font-weight:bold">return</span> heldPtr;}
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	T *heldPtr;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>请使用 member function templates (成员函数模板) 生成 &quot; 可接受所有兼容类型 &quot; 的函数。</li>
<li>如果你声明 member templates 用于 &quot; 泛化 copy构造函数 &quot; 或 &quot; 泛化 assigmment操作 &ldquo;，你还是需要声明正常的 copy 构造函数和 copy assigmmenmt 操作符。</li>
</ul>
<h2 id="条款-46需要类型转换时请为模板定义非成员函数">条款 46：需要类型转换时请为模板定义非成员函数</h2>
<ul>
<li>在 function template 实参推导过程中从不进行隐式类型转换。</li>
<li>Class templates 并不倚赖 tetmplate 实参推导 ( 后者只施行于 function templates 身上) ，所以编译器总是能够在 class template 具现化时得知 T。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#8b008b;font-weight:bold">typename</span> T&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">Rational</span><span style="color:#228b22">//template class
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	 Rational(T numerator = <span style="color:#b452cd">0</span>,T denominator = <span style="color:#b452cd">1</span>);
</span></span><span style="display:flex;"><span>	 T <span style="color:#008b45">numerator</span>()<span style="color:#8b008b;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>	 T <span style="color:#008b45">denominator</span>()<span style="color:#8b008b;font-weight:bold">const</span>;
</span></span><span style="display:flex;"><span>	 <span style="color:#8b008b;font-weight:bold">friend</span> <span style="color:#8b008b;font-weight:bold">const</span> Rational <span style="color:#8b008b;font-weight:bold">operator</span>*(<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;lhs,<span style="color:#8b008b;font-weight:bold">const</span> Rational &amp;rhs)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">Rational</span>(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator());
</span></span><span style="display:flex;"><span>	}<span style="color:#228b22">//定义在外部时，将只可通过编译却无法连接
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	<span style="color:#8b008b;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>	T n;<span style="color:#228b22">//分子(numerator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	T d;<span style="color:#228b22">//分母(denominator)
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>};
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>当我们编写一个 class template，而它所提供之 &quot; 与此 template 相关的 &quot; 函数支持 &quot; 所有参数之隐式类型转换 &quot; 时，请将那些函数定义为 &quot; class template 内部的 friend 函数 &ldquo;。</li>
</ul>
<h2 id="条款-47请使用-traits-classes-表现类型信息">条款 47：请使用 traits classes 表现类型信息</h2>
<ul>
<li>STL 主要由 &quot; 用以表现容器、迭代器和算法 &quot; 的 templates 构成，以及若干工具性 templates。</li>
<li>STL 共有 5 种迭代器分类</li>
</ul>
<table>
<thead>
<tr>
<th>Input 迭代器</th>
<th>Output 迭代器</th>
<th>Forward 迭代器</th>
<th>Bidirectional迭代器</th>
<th>Random access 迭代器</th>
</tr>
</thead>
<tbody>
<tr>
<td>Istream_iterators</td>
<td>Ostream_iterators</td>
<td>不支持linked list</td>
<td>STL list, set, multiset, map, multimap 的迭代器</td>
<td>vector,deque, string 的迭代器</td>
</tr>
<tr>
<td>只能向前最多一次读操作</td>
<td>只能向前最多一次写操作</td>
<td>向前多次操作</td>
<td>可以向前移动，还可以向后移动</td>
<td>支持迭代器算术，双向</td>
</tr>
</tbody>
</table>
<blockquote>
<p>is-a关系：</p>
<ul>
<li>input、output</li>
<li>forward : public input</li>
<li>bidirectional : public forward</li>
<li>random : public bidirectional</li>
</ul>
</blockquote>
<ul>
<li>advance(Iter, Disance)</li>
<li>设计并实现一个 traits class：</li>
</ul>
<blockquote>
<ul>
<li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类 (category) 。</li>
<li>为该信息选择一个名称 ( 例如 iterator_category) 。</li>
<li>提供一个 template 和一组特化版本 ( 例如稍早说的 iterator_traits) ，内含你希望支持的类型相关信息。</li>
</ul>
</blockquote>
<ul>
<li>如何使用一个 traits class：</li>
</ul>
<blockquote>
<ul>
<li>建立一组重载函数 (身份像劳工) 或函数模板 (例如 doadvance) ，彼此间的差异只在于各自的 traits 参数。令每个函数实现码与其接受之 traits 信息相应和。</li>
<li>建立一个控制函数〈身份像工头) 或函数模板 (例如 advance) ，它调用上述那些 &quot; 劳工函数 &quot; 并传递 traits class 所提供的信息。</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>Traits classes 使得 &quot; 类型相关信息 &quot; 在编译期可用。 它们以 templates 和 &quot; templates 特化 &quot; 完成实现。</li>
<li>整合重载技术 (overloading ) 后，traits classes 有可能在编译期对类型执行 if&hellip;else 测试。</li>
</ul>
<h2 id="条款-48认识-template-元编程">条款 48：认识 template 元编程</h2>
<ul>
<li>Template metaprogramming (TMP，模板元编程) 是编写 template-based C++ 程序并执行于编译期的过程。</li>
<li>template metaprogram (模板元程序) 是以 C++ 写成、执行于 C++ 编译器内的程序。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">//阶层(factorial)模板元编程,递归模板具现化实现循环
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">template</span>&lt;<span style="color:#00688b;font-weight:bold">unsigned</span> n&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">Factorial</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">enum</span>{value = n*Factorial&lt;n-<span style="color:#b452cd">1</span>&gt;::value};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">template</span>&lt;&gt;
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">Factorial</span>&lt;<span style="color:#b452cd">0</span>&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">enum</span>{Value = <span style="color:#b452cd">1</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#228b22">//main.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>cout&lt;&lt;Factorial&lt;<span style="color:#b452cd">5</span>&gt;::value&lt;&lt;endl;<span style="color:#228b22">//计算5的阶层
</span></span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>Template metaprogramming (TMP，模板元编程) 可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP 可被用来生成 &quot; 基于政策选择组合 &quot; (based on combinations of policy choices) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
<blockquote>
<p>第八章 定制 new 和 delete</p>
</blockquote>
<h2 id="条款-49了解-new-handler-的行为">条款 49：了解 new-handler 的行为</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配; 后继的构造函数调用还是可能抛出异常。</li>
</ul>
<h2 id="条款-50了解-new-和-qelete-的合理替换时机">条款 50：了解 new 和 qelete 的合理替换时机</h2>
<ul>
<li>何时可在 &quot; 全局性的 &quot; 或 &quot; class 专属的 &quot; 基础上合理替换缺省的 new 和 delete:</li>
</ul>
<blockquote>
<ul>
<li>为了检测运用错误。</li>
<li>为了收集动态分配内存之使用统计信息。</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省内存管理器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位 (suboptimal atignment) 。</li>
<li>为了将相关对象成簇集中。new 和 delete 的 &quot; placement 版本 &quot; (见条款52) 有可能完成这样的集簇行为。</li>
<li>为了获得非传统的行为。</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>有许多理由需要写个自定的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。</li>
</ul>
<h2 id="条款-51编写new-和-delete-时需固守常规">条款 51：编写new 和 delete 时需固守常规</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>OPerator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。Class 专属版本则还应该处理 &quot; 比正确大小更大的( 错误 ) 申请 &quot; 。</li>
<li>operator delete 应该在收到 null 指针时不做任何事。Class 专属版本则还应该处理 &quot; 比正确大小更大的 ( 错误 ) 申请 &quot; 。</li>
</ul>
<h2 id="条款52写了-placement-new-也要写-placement-delete">条款52：写了 placement new 也要写 placement delete</h2>
<ul>
<li>如果 operator new接受的参数除了一定会有的那个 size_t之外还有其他，这便是个所谓的 placerment new。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#1e889b">#include</span><span style="color:#1e889b">&lt;new&gt;//标准库</span><span style="color:#1e889b">
</span></span></span><span style="display:flex;"><span><span style="color:#1e889b"></span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">new</span>(std: :size_t, <span style="color:#00688b;font-weight:bold">void</span>* PMemory) <span style="color:#8b008b;font-weight:bold">throw</span>(); <span style="color:#228b22">//纳入标准库内的pacement new
</span></span></span><span style="display:flex;"><span><span style="color:#228b22">//非标准
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">new</span>(std: :size_t, std::ostream &amp;) <span style="color:#8b008b;font-weight:bold">throw</span>(std::bad_alloc);
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">delete</span>(<span style="color:#00688b;font-weight:bold">void</span> *, std::ostream &amp;) <span style="color:#8b008b;font-weight:bold">throw</span>();<span style="color:#228b22">//placement delete
</span></span></span></code></pre></div><ul>
<li>缺省情况下 C++ 在 global 作用域内提供以下形式的 operator new：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#1e889b">#include</span><span style="color:#1e889b">&lt;new&gt;</span><span style="color:#1e889b">
</span></span></span><span style="display:flex;"><span><span style="color:#1e889b"></span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">new</span>(std: :size_t)<span style="color:#8b008b;font-weight:bold">throw</span>();<span style="color:#228b22">//正常的new
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">new</span>(std: :size_t, <span style="color:#00688b;font-weight:bold">void</span> *) <span style="color:#8b008b;font-weight:bold">throw</span>();<span style="color:#228b22">//placement new
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#008b45">new</span>(std: :size_t, <span style="color:#8b008b;font-weight:bold">const</span> std::nothrow_t &amp;) <span style="color:#8b008b;font-weight:bold">throw</span>();<span style="color:#228b22">//nothrow new
</span></span></span></code></pre></div><ul>
<li>如果你在 class 内声明任何 operator news，它会遮掩上述这些标准形式。为使这些函数有着平常的行为，只要令你的 class 专属版本调用 global 版本即可：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">//将标准形式放在一个class中，然后让客户继承及using声明式取得标准形式
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">standard</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">static</span> <span style="color:#00688b;font-weight:bold">void</span>* <span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#8b008b;font-weight:bold">new</span>(std::size_t size)<span style="color:#8b008b;font-weight:bold">throw</span>(std::bad_alloc)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#8b008b;font-weight:bold">return</span> ::<span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#8b008b;font-weight:bold">new</span>(size);<span style="color:#228b22">//分别调用标准形式
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>	}
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">wiget</span>:<span style="color:#8b008b;font-weight:bold">public</span> standard
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#8b008b;font-weight:bold">using</span> standard::<span style="color:#8b008b;font-weight:bold">operator</span> <span style="color:#8b008b;font-weight:bold">new</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#228b22">//定义自己的operator new
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>}
</span></span></code></pre></div><blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>当你写一个 placement operator new，请确定也写出了对应的 placerment operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。</li>
<li>当你声明 placement new 和 placement delete，请确定不要无意识 ( 非故意 )  地遮掩了它们的正常版本。</li>
</ul>
<blockquote>
<p>第九章杂项讨论</p>
</blockquote>
<h2 id="条款-53不要轻忽编译器的警告">条款 53：不要轻忽编译器的警告</h2>
<ul>
<li>警告信息天生和编译器相依，不同的编译器有不同的警告标准。</li>
</ul>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高 ( 最严苛 ) 警告级别下争取 &quot; 无任何警告 &quot; 的荣誉 。</li>
<li>不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。</li>
</ul>
<h2 id="条款-54让自己熟悉包括-tr1-在内的标准程序库">条款 54：让自己熟悉包括 TR1 在内的标准程序库</h2>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>C++ 标准程序库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。</li>
<li>TR1 添加了智能指针 (例如 trl: :shared_ptr) 、一般化函数指针 (trl: :function) 、hash-based 容器、正则表达式 (regular expressions) 以及另外 10个组件的支持。</li>
<li>TR1 自身只是一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。</li>
</ul>
<h2 id="条款-55让自己熟悉-boost">条款 55：让自己熟悉 Boost</h2>
<ul>
<li>Boost 是一个 C++ 开发者集结的社群, 也是一个可自由下载的 C++ 程序库群。<a href="http://boost.org">boost网址</a></li>
<li>Boost Graph Library (用于编写任意 graph 结构)。</li>
<li>Boost MPL Library (一个元编程程序库，metaprogramming library)。</li>
<li>Boost 程序库内包含种类：</li>
</ul>
<blockquote>
<ul>
<li>字符串与文本处理。</li>
<li>容器。</li>
<li>函数对象和高级编程。</li>
<li>泛型编程 (Generic programming)。</li>
<li>模板元编程(Template metaprogramming，TMP)。</li>
<li>数学和数值 (Math and numerics)。</li>
<li>正确性与测试 (Correctness and testing)。</li>
<li>数据结构。</li>
<li>语言间的支持 (Inter-language support)。</li>
<li>内存。</li>
<li>等等</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>小结</strong></em></p>
</blockquote>
<ul>
<li>Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li>
<li>Boost 提供许多 TR1 组件实现品，以及其他许多程序库。</li>
</ul>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2023-10-23</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="/post/markdown/">
			Next<br>Markdown
                </a>
                
                
                
                <a class="older-posts">
			Previous<br>No older posts.
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                












<script src="https://giscus.app/client.js"
        data-repo="username/repo"
        data-repo-id="**************************"
        data-category="General"
        data-category-id="*********************"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>

            </div>
        </div>
    </div>


                    </div>
            </div><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://luckfalcon.github.io/">
    
        <div class="nav-title">
            主页
        </div>
        
        <div class="nav-subtitle">
            luckfalcon的博客
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/post">
                归档
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                分类
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                关于
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS Feed
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	This is a customized copyright.
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    <div class="toc-wrapper">
        

        
        <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#c%e7%bc%96%e7%a8%8b%e6%b3%a8%e6%84%8f%e6%9d%a1%e6%ac%be" class="nav-c编程注意条款">
									C&#43;&#43;编程注意条款
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be2%e5%b0%bd%e9%87%8f%e4%bb%a5-constenuminline-%e6%9b%bf%e6%8d%a2-define" class="nav-条款2尽量以-constenuminline-替换-define">
									条款2：尽量以 const，enum，inline 替换 #define
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be3%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8-const" class="nav-条款3尽可能使用-const">
									条款3：尽可能使用 const
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be4%e7%a1%ae%e5%ae%9a%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%89%8d%e5%b7%b2%e5%85%88%e8%a2%ab%e5%88%9d%e5%a7%8b%e5%8c%96" class="nav-条款4确定对象被使用前已先被初始化">
									条款4：确定对象被使用前已先被初始化
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be5%e4%ba%86%e8%a7%a3c%e9%bb%98%e9%bb%98%e5%86%99%e5%b9%b6%e8%b0%83%e7%94%a8%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0" class="nav-条款5了解c默默写并调用哪些函数">
									条款5：了解c&#43;&#43;默默写并调用哪些函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be6%e8%8b%a5%e4%b8%8d%e6%83%b3%e4%bd%bf%e7%94%a8%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0%e5%b0%b1%e8%af%a5%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d" class="nav-条款6若不想使用编译器自动生成的函数就该明确拒绝">
									条款6：若不想使用编译器自动生成的函数，就该明确拒绝
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be7%e4%b8%ba%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e5%a3%b0%e6%98%8evirtual%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" class="nav-条款7为多态基类声明virtual析构函数">
									条款7：为多态基类声明virtual析构函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be8%e5%88%ab%e8%ae%a9%e5%bc%82%e5%b8%b8%e9%80%83%e7%a6%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" class="nav-条款8别让异常逃离析构函数">
									条款8：别让异常逃离析构函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be9%e7%bb%9d%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8virtual%e5%87%bd%e6%95%b0" class="nav-条款9绝不在构造和析构过程中调用virtual函数">
									条款9：绝不在构造和析构过程中调用virtual函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be10%e4%bb%a4operator--%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aareference-to-this" class="nav-条款10令operator--返回一个reference-to-this">
									条款10：令operator = 返回一个reference to *this
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be11%e5%9c%a8-operator--%e4%b8%ad%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc" class="nav-条款11在-operator--中处理自我赋值">
									条款11：在 operator = 中处理“自我赋值”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e6%97%b6%e5%8b%bf%e5%bf%98%e5%85%b6%e6%af%8f%e4%b8%80%e4%b8%aa%e6%88%90%e5%88%86" class="nav-条款12复制对象时勿忘其每一个成分">
									条款12：复制对象时勿忘其每一个成分
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90" class="nav-条款13以对象管理资源">
									条款13：以对象管理资源
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e5%b0%8f%e5%bf%83coping%e8%a1%8c%e4%b8%ba" class="nav-条款14在资源管理类中小心coping行为">
									条款14：在资源管理类中小心coping行为
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae" class="nav-条款15在资源管理类中提供对原始资源的访问">
									条款15：在资源管理类中提供对原始资源的访问
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be16%e6%88%90%e5%af%b9%e4%bd%bf%e7%94%a8new%e5%92%8cdelete%e6%97%b6%e8%a6%81%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f" class="nav-条款16成对使用new和delete时要采用相同形式">
									条款16：成对使用new和delete时要采用相同形式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be17%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86-newed-%e5%af%b9%e8%b1%a1%e7%bd%ae%e5%85%a5%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="nav-条款17以独立语句将-newed-对象置入智能指针">
									条款17：以独立语句将 newed 对象置入智能指针
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e5%ae%b9%e6%98%93%e8%a2%ab%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e4%b8%8d%e6%98%93%e8%a2%ab%e8%af%af%e7%94%a8" class="nav-条款18让接口容易被正确使用不易被误用">
									条款18：让接口容易被正确使用，不易被误用
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be19%e8%ae%be%e8%ae%a1-class-%e7%8a%b9%e5%a6%82%e8%ae%be%e8%ae%a1-type" class="nav-条款19设计-class-犹如设计-type">
									条款19：设计 class 犹如设计 type
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be20%e5%ae%81%e5%8f%af%e4%bb%a5-passed-by-reference-to-const-%e6%9b%bf%e6%8d%a2-passed-by-value" class="nav-条款20宁可以-passed-by-reference-to-const-替换-passed-by-value">
									条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be21%e5%bf%85%e9%a1%bb%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e6%97%b6%e5%88%ab%e5%a6%84%e6%83%b3%e8%bf%94%e5%9b%9e%e5%85%b6reference" class="nav-条款21必须返回对象时别妄想返回其reference">
									条款21：必须返回对象时，别妄想返回其reference
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be22%e5%b0%86%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e%e4%b8%ba-private" class="nav-条款22将成员变量声明为-private">
									条款22：将成员变量声明为 private
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be23%e5%ae%81%e4%bb%a5-non-membernon-friend-%e6%9b%bf%e6%8d%a2-member-%e5%87%bd%e6%95%b0" class="nav-条款23宁以-non-membernon-friend-替换-member-函数">
									条款23：宁以 non-member、non-friend 替换 member 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be24%e8%8b%a5%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e7%9a%86%e9%9c%80%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%af%b7%e4%b8%ba%e6%ad%a4%e9%87%87%e7%94%a8-non-member-%e5%87%bd%e6%95%b0" class="nav-条款24若所有参数皆需类型转换请为此采用-non-member-函数">
									条款24：若所有参数皆需类型转换，请为此采用 non-member 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be25%e8%80%83%e8%99%91%e5%86%99%e5%87%ba%e4%b8%80%e4%b8%aa%e4%b8%8d%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8%e7%9a%84-swap-%e5%87%bd%e6%95%b0" class="nav-条款25考虑写出一个不抛出异常的-swap-函数">
									条款25：考虑写出一个不抛出异常的 swap 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be26%e5%b0%bd%e5%8f%af%e8%83%bd%e5%bb%b6%e5%90%8e%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89%e5%bc%8f%e7%9a%84%e5%87%ba%e7%8e%b0%e6%97%b6%e9%97%b4" class="nav-条款26尽可能延后变量定义式的出现时间">
									条款26：尽可能延后变量定义式的出现时间
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be27%e5%b0%bd%e9%87%8f%e5%b0%91%e5%81%9a%e8%bd%ac%e5%9e%8b%e5%8a%a8%e4%bd%9c" class="nav-条款27尽量少做转型动作">
									条款27：尽量少做转型动作
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9e-handles-%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e6%88%90%e5%88%86" class="nav-条款28避免返回-handles-指向对象内部成分">
									条款28：避免返回 handles 指向对象内部成分
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be29%e4%b8%ba%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e8%80%8c%e5%8a%aa%e5%8a%9b%e6%98%af%e5%80%bc%e5%be%97%e7%9a%84" class="nav-条款29为异常安全而努力是值得的">
									条款29：为&#34;异常安全&#34;而努力是值得的
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be30%e9%80%8f%e5%bd%bb%e4%ba%86%e8%a7%a3-inlining-%e7%9a%84%e9%87%8c%e9%87%8c%e5%a4%96%e5%a4%96" class="nav-条款30透彻了解-inlining-的里里外外">
									条款30：透彻了解 inlining 的里里外外
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be31%e5%b0%86%e6%96%87%e4%bb%b6%e9%97%b4%e7%9a%84%e7%bc%96%e8%af%91%e4%be%9d%e5%ad%98%e5%85%b3%e7%b3%bb%e9%99%8d%e8%87%b3%e6%9c%80%e4%bd%8e" class="nav-条款31将文件间的编译依存关系降至最低">
									条款31：将文件间的编译依存关系降至最低
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be32%e7%a1%ae%e5%ae%9a%e4%bd%a0%e7%9a%84-public-%e7%bb%a7%e6%89%bf%e5%a1%91%e6%a8%a1%e5%87%ba-is-a-%e5%85%b3%e7%b3%bb" class="nav-条款32确定你的-public-继承塑模出-is-a-关系">
									条款32：确定你的 public 继承塑模出 is-a 关系
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-33%e9%81%bf%e5%85%8d%e9%81%ae%e6%8e%a9%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e5%90%8d%e7%a7%b0" class="nav-条款-33避免遮掩继承而来的名称">
									条款 33：避免遮掩继承而来的名称
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf" class="nav-条款-34区分接口继承和实现继承">
									条款 34：区分接口继承和实现继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-35%e8%80%83%e8%99%91-virtual-%e5%87%bd%e6%95%b0%e4%bb%a5%e5%a4%96%e7%9a%84%e5%85%b6%e4%bb%96%e9%80%89%e6%8b%a9" class="nav-条款-35考虑-virtual-函数以外的其他选择">
									条款 35：考虑 virtual 函数以外的其他选择
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-36%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84-non-virtual-%e5%87%bd%e6%95%b0" class="nav-条款-36绝不重新定义继承而来的-non-virtual-函数">
									条款 36：绝不重新定义继承而来的 non-virtual 函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-37-%e7%bb%9d%e4%b8%8d%e9%87%8d%e6%96%b0%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e8%80%8c%e6%9d%a5%e7%9a%84%e7%bc%ba%e7%9c%81%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0%e5%80%bc" class="nav-条款-37-绝不重新定义继承而来的缺省默认参数值">
									条款 37: 绝不重新定义继承而来的缺省(默认)参数值
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-38-%e9%80%9a%e8%bf%87%e5%a4%8d%e5%90%88%e5%a1%91%e6%a8%a1%e5%87%ba-has-a-%e6%88%96--%e6%a0%b9%e6%8d%ae%e6%9f%90%e7%89%a9%e5%ae%9e%e7%8e%b0%e5%87%ba-" class="nav-条款-38-通过复合塑模出-has-a-或--根据某物实现出-">
									条款 38: 通过复合塑模出 has-a 或 “ 根据某物实现出 ”
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-39-%e6%98%8e%e6%99%ba%e8%80%8c%e5%ae%a1%e6%85%8e%e5%9c%b0%e4%bd%bf%e7%94%a8-private-%e7%bb%a7%e6%89%bf" class="nav-条款-39-明智而审慎地使用-private-继承">
									条款 39: 明智而审慎地使用 Private 继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-40-%e6%98%8e%e6%99%ba%e8%80%8c%e5%ae%a1%e6%85%8e%e5%9c%b0%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf" class="nav-条款-40-明智而审慎地使用多重继承">
									条款 40: 明智而审慎地使用多重继承
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-41%e4%ba%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81" class="nav-条款-41了解隐式接口和编译期多态">
									条款 41：了解隐式接口和编译期多态
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-42%e4%ba%86%e8%a7%a3-typename-%e7%9a%84%e5%8f%8c%e9%87%8d%e6%84%8f%e4%b9%89" class="nav-条款-42了解-typename-的双重意义">
									条款 42：了解 typename 的双重意义
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-43%e5%ad%a6%e4%b9%a0%e5%a4%84%e7%90%86%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0" class="nav-条款-43学习处理模板化基类内的名称">
									条款 43：学习处理模板化基类内的名称
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-44%e5%b0%86%e4%b8%8e%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e6%8a%bd%e7%a6%bb-templates" class="nav-条款-44将与参数无关的代码抽离-templates">
									条款 44：将与参数无关的代码抽离 templates
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-45%e8%bf%90%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b" class="nav-条款-45运用成员函数模板接受所有兼容类型">
									条款 45：运用成员函数模板接受所有兼容类型
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e6%97%b6%e8%af%b7%e4%b8%ba%e6%a8%a1%e6%9d%bf%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" class="nav-条款-46需要类型转换时请为模板定义非成员函数">
									条款 46：需要类型转换时请为模板定义非成员函数
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-47%e8%af%b7%e4%bd%bf%e7%94%a8-traits-classes-%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af" class="nav-条款-47请使用-traits-classes-表现类型信息">
									条款 47：请使用 traits classes 表现类型信息
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-48%e8%ae%a4%e8%af%86-template-%e5%85%83%e7%bc%96%e7%a8%8b" class="nav-条款-48认识-template-元编程">
									条款 48：认识 template 元编程
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-49%e4%ba%86%e8%a7%a3-new-handler-%e7%9a%84%e8%a1%8c%e4%b8%ba" class="nav-条款-49了解-new-handler-的行为">
									条款 49：了解 new-handler 的行为
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-50%e4%ba%86%e8%a7%a3-new-%e5%92%8c-qelete-%e7%9a%84%e5%90%88%e7%90%86%e6%9b%bf%e6%8d%a2%e6%97%b6%e6%9c%ba" class="nav-条款-50了解-new-和-qelete-的合理替换时机">
									条款 50：了解 new 和 qelete 的合理替换时机
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-51%e7%bc%96%e5%86%99new-%e5%92%8c-delete-%e6%97%b6%e9%9c%80%e5%9b%ba%e5%ae%88%e5%b8%b8%e8%a7%84" class="nav-条款-51编写new-和-delete-时需固守常规">
									条款 51：编写new 和 delete 时需固守常规
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be52%e5%86%99%e4%ba%86-placement-new-%e4%b9%9f%e8%a6%81%e5%86%99-placement-delete" class="nav-条款52写了-placement-new-也要写-placement-delete">
									条款52：写了 placement new 也要写 placement delete
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-53%e4%b8%8d%e8%a6%81%e8%bd%bb%e5%bf%bd%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e8%ad%a6%e5%91%8a" class="nav-条款-53不要轻忽编译器的警告">
									条款 53：不要轻忽编译器的警告
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-54%e8%ae%a9%e8%87%aa%e5%b7%b1%e7%86%9f%e6%82%89%e5%8c%85%e6%8b%ac-tr1-%e5%9c%a8%e5%86%85%e7%9a%84%e6%a0%87%e5%87%86%e7%a8%8b%e5%ba%8f%e5%ba%93" class="nav-条款-54让自己熟悉包括-tr1-在内的标准程序库">
									条款 54：让自己熟悉包括 TR1 在内的标准程序库
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e6%9d%a1%e6%ac%be-55%e8%ae%a9%e8%87%aa%e5%b7%b1%e7%86%9f%e6%82%89-boost" class="nav-条款-55让自己熟悉-boost">
									条款 55：让自己熟悉 Boost
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
        
    </div>
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top"
            :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a type="button" class="pagination-action" id="darkModeToggleButton">
            <span class="material-icons pagination-action-icon" id="darkModeToggleIcon">
                dark_mode
            </span>
        </a>
        
        
    </div>
</div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	This is a customized copyright.
	
</div>
            </div>
    
    <script src="/js/journal.js"></script></body>
</html>
