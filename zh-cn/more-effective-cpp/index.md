# More effective C++ 总结


<!--more-->
# 基础议题
- 指针、引用、类型转换、数组、构造
## 条款1：指针与引用的区别
- 一个引用必须指向某个对象，任何情况下都不可以使用指向空值的引用。设计不允许变量为空时，可以把变量声明为引用。
- 不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。
- 指针可以被重新赋值以指向另一个不同的对象，引用则总是指向在初始化时被指定的对象，以后不能改变。
- 使用指针的情况：
>1. 考虑到存在不指向任何对象的可能 ( 在这种情况下，你能够设置指针为空 )。
>2. 需要能够在不同的时刻指向不同的对象 ( 在这种情况下，你能改变指的指向 )。
- 使用引用的情况：
>1. 总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。
>2. 当你重载某个操作符时，你应该使用引用。如何操作符[ ]返回对象引用
- ***总结***
>当你知道你必须指向一个对象并且不想改变其指向时, 或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。而在除此之外的其他情况下，则应使用指针。
## 条款2：尽量使用 C++ 风格的类型转换
- C++ 四种类型转换操作符：static_cast，const_cast，dynamic_cast，和 reinterpret_cast。
- 使用格式：操作符<要转换的类型>(表达式)-->表达式括号必需。
- reinterpret_cast 使用这个操作符的类型转换，其转换结果几乎都是执行期定义 （ implementation-defined ）。因此 ，使用reinterpret_casts 的代码很难移植。
- ***总结***
> 新的类型转换符缺乏美感才能使它弥补了在含义精确性和可辨认性上的缺点，使用新类型转换符的程序更容易被解析，它们允许编译器检测出原来不能发现的错误。
- ## 条款3：不要对数组使用多态 
- 通过一个基类指针来删除一个含有派生类对象的数组，结果将是不确定的。
- 在基类内操作基类对象数组时的大小是确定的，而在使用基类指针操作派生类对象数组时则会因派生类对象大小发生改变，从而无法确定对象数组的大小。
```c++
class Base{...}
class Derived : public Base{...}
void Base::printarry(&ostream o, Base arr[], int n)
{
  for(int i = 0; i< n; ++i)
  o<< arr[i];
}
Base b[10];
printarry(cout,b,10);// n 的值是正确的
Derived d[10];
printarry(cout,d,10);//因派生类对象大小发生改变，从而导致 n 的计算错误
```
- 多态和指针算法不能混合在一起来用，所以数组与多态也不能用在一起，因为数组调用的本质是调用指针。
- 是如果你不从一个具体类（concrete classes），派生出另一个具体类，那么你就不太可能犯这种使用多态性数组的错误。
- ## 条款4：避免无用的缺省构造函数 
- **如果一个类没有缺省构造函数，则无法直接建立该类的对象数组，也不可以使用非堆数组 ( new 数组 )。**
```c++
class Obj
{
  public:
  Obj(int n):num(n){}//没用默认构造函数
  private:
  int num;
}
Obj arr[10];//没有默认构造函数，无法直接建立数组
Obj arr[10] = {Obj(1),Obj(2)...};//可行，不过数组大时不现实
Obj *ptr = new Obj[10]; //没有默认构造函数，无法建立堆数组
```
- 可以指针方式避免调用构造函数。这种方法有两个缺点，第一你必须删除数组里每个指针所指向的对象。如果你忘了，就会发生内存泄漏。第二增加了内存分配量，你需要空间来容纳指针。
```c++
typedef Obj* objarr;
objarr arr[10];//可行，没用调用构造函数
objarr *ptr = new objarr[10];//可行
```
- 为数组分配 raw memory ( 原始内存 )，可以避免浪费内存。使用 placement new 方法在内存中构造对象。
```c++
//operator new 函数
void *rawmemery = operator new( 10*sizeof(Obj));
Obj *best = static_cast<Obj*>(rawmemery);
//使用 placement new
for (int i = 0; i < 10; ++i) 
  new(&best[i])Obj(num);
```
- 使用 placement new 的缺点：当你不想让它继续存在使用时，必须手动调用数组对象的析构函数，然后调用操作符 delete[ ] 来释放 raw memory。
```c++
for (int i = 9; i >= 0; --i)
  best[i].~Obj();//析构对象
operator delete[](rawmemery);//回收内存
```
- **对于类里没有定义缺省构造函数所造成的第二个问题是它们无法在许多基于模板（template-based ）的容器类里使用。**
>- 在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。
- **设计虚基类时所面临的要提供缺省构造函数还是不提供缺省构造函数**
>- 几乎所有的派生类在实例化时都必须给虚基类构造函数提供参数。
>- 这就要求所有由没有缺省构造函数的虚基类继承下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。
- **提供无意义的缺省构造函数也会影响类的工作效率。**
>- 如果成员函数必须测试所有的部分是否都被正确地初始化，那么这些函数的调用者就得为此付出更多的时间。
>- 使用这种（没有缺省构造函数的）类的确有一些限制，但是当你使用它时，它也给你提供了一种保证：你能相信这个类被正确地建立和高效地实现。
- # 运算符
- 重载的运算符何时并且如何被调用，它们如何运作，它们应该如何彼此联系，以及如何获得这些方面的控制权。
- ## 条款5：谨慎定义类型转换函数
- C++ 编译器能够在两种数据类型之间进行隐式转换（implicit conversions）。
- C++ 编译器会为内置数据类型之间进行自动的隐式转换。继承于 C 语言。
-  自定义类型时，可以控制选择是否提供函数让编译器进行隐式类型转换。
-  有两种函数允许编译器进行这些的转换：
>- 单参数构造函数（ single-argument constructors）。  
>- 隐式类型转换运算符。


