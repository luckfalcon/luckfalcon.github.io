[{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r 将此页保存为书签，以备将来参考!\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat\r像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat\r稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["others"],"content":"搜索技术介绍","date":"2023-10-31","objectID":"/zh-cn/search-technology/","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["others"],"content":" AI Poe 免费的 AI，需要科学上网环境 ","date":"2023-10-31","objectID":"/zh-cn/search-technology/:0:0","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["others"],"content":"搜索技术介绍 为什么搜？ 知道 学习 创作 完工 知道怎么搜？ 去哪里搜？ 怎么搜？ 信息资讯 搜索效率： 谷歌 \u003e 短视频公众号 \u003e 短视频 \u003e 百度 谷歌搜索技巧 ( 谷歌搜不到微信公众号的文章 ) “\"，限定关键词,完全匹配搜索，示例 : \" 你好! \" intitle，限定标题，示例 ：intitle : 你好！ allintitle，限定多个标题，示例 ：allintitle : 你好！ 他好！ intext，限定内容 （ 可限制多个内容关键词 ），示例 ： intext : 你好！ inurl，限定网址关键字，示例 : inurl : CCTV，李子奇 inurl : CCTV site，限定网址来源，示例 ： site : zhihu.com imagesize，限定图片尺寸，示例 ： imagesize : 255 x 255 或者直接 图片名:255X255 filetype，限定文件格式， 示例 ： filetype : ppt/pdf… .. 符号,定位时间，示例：世界杯举办时间..2014 - 符号，用来屏蔽关键字，示例:中国国家税收贡献最高的省份 -广东 简单搜索，示例：牛肉面馆 附近 cache关键字，访问最近的缓存版本，示例：cache:www.blog.com 知识技能 知识存在地方： 组织内部 （ 同事的电脑、聊天记录、线上知识库 ） 组织外部 （ 网页、电子书、电子文档、学术论文、笔记、知识平台、视频网站、AI 大脑、牛人的大脑 ） 谷歌和 YouTube 是最好的知识获得平台 聚合具有某个头部的网站方法 filetype : pdf inurl : baogao SimilarSites : baogao.com，从 SimilarSites 网站获取头部相关的网站 学术论文搜索 谷歌学术 sci-hub ( 只能搜索论文的完整题目，无法关键字检索 ) 电子书搜索 鸠摩搜书 素材文件 素材类型 ：视频、音频、图片、文件 无版权视频素材网站 ( 谷歌搜索：best sites for free stock videos ) pexels pixabay ( 也包含图片音乐音效等 ) videvo mixkit YouTube 视频下载 save.tube www.9x ( YouTube 视频网址 ) 高清免费无版权图片网站 pexels pixabay ( 也包含图片音乐音效等 ) unsplash 有版权高清图片网站 gettyimages图片搜索地址 gettyimages 图片下载地址 图标 ( icons ) iconfont 阿里图片搜索库 PPT模板 iSlide canva 在线设计平台，可设计视频、PPT 等 工具软件 在线工具 –\u003e 下载软件 –\u003e 安装插件 谷歌搜索 ：需求 + online 在线抠图 在线文字转语音 腾讯智影 微软的 Azure 画脑图或概念图 miro 画脑图 canva 画概念图 影视剧台词 在线剪视频 Clipchamp FlexClip 测网速 检测陌生连接安全性 生成不存在人像头像 获取新奇的未知软件 得到 app ( 一个不错的 \" 搜索 + 学习 \" app ) ","date":"2023-10-31","objectID":"/zh-cn/search-technology/:0:1","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["documentation"],"content":"more effective C++ 总结","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"基础议题 指针、引用、类型转换、数组、构造 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:0:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 1：指针与引用的区别 一个引用必须指向某个对象，任何情况下都不可以使用指向空值的引用。设计不允许变量为空时，可以把变量声明为引用。 不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。 指针可以被重新赋值以指向另一个不同的对象，引用则总是指向在初始化时被指定的对象，以后不能改变。 使用指针的情况： 考虑到存在不指向任何对象的可能 ( 在这种情况下，你能够设置指针为空 )。 需要能够在不同的时刻指向不同的对象 ( 在这种情况下，你能改变指的指向 )。 使用引用的情况： 总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。 当你重载某个操作符时，你应该使用引用。如何操作符[ ]返回对象引用 总结 当你知道你必须指向一个对象并且不想改变其指向时, 或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。而在除此之外的其他情况下，则应使用指针。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:1:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 2：尽量使用 C++ 风格的类型转换 C++ 四种类型转换操作符：static_cast，const_cast，dynamic_cast，和 reinterpret_cast。 使用格式：操作符\u003c要转换的类型\u003e(表达式)–\u003e表达式括号必需。 reinterpret_cast 使用这个操作符的类型转换，其转换结果几乎都是执行期定义 （ implementation-defined ）。因此 ，使用reinterpret_casts 的代码很难移植。 总结 新的类型转换符缺乏美感才能使它弥补了在含义精确性和可辨认性上的缺点，使用新类型转换符的程序更容易被解析，它们允许编译器检测出原来不能发现的错误。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:2:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 3：不要对数组使用多态 通过一个基类指针来删除一个含有派生类对象的数组，结果将是不确定的。 在基类内操作基类对象数组时的大小是确定的，而在使用基类指针操作派生类对象数组时则会因派生类对象大小发生改变，从而无法确定对象数组的大小。 class Base{...} class Derived : public Base{...} void Base::printarry(\u0026ostream o, Base arr[], int n) { for(int i = 0; i\u003c n; ++i) o\u003c\u003c arr[i]; } Base b[10]; printarry(cout,b,10);// n 的值是正确的 Derived d[10]; printarry(cout,d,10);//因派生类对象大小发生改变，从而导致 n 的计算错误 多态和指针算法不能混合在一起来用，所以数组与多态也不能用在一起，因为数组调用的本质是调用指针。 是如果你不从一个具体类（concrete classes），派生出另一个具体类，那么你就不太可能犯这种使用多态性数组的错误。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:3:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 4：避免无用的缺省构造函数 如果一个类没有缺省构造函数，则无法直接建立该类的对象数组，也不可以使用非堆数组 ( new 数组 )。 class Obj { public: Obj(int n):num(n){}//没用默认构造函数 private: int num; } Obj arr[10];//没有默认构造函数，无法直接建立数组 Obj arr[10] = {Obj(1),Obj(2)...};//可行，不过数组大时不现实 Obj *ptr = new Obj[10]; //没有默认构造函数，无法建立堆数组 可以指针方式避免调用构造函数。这种方法有两个缺点，第一你必须删除数组里每个指针所指向的对象。如果你忘了，就会发生内存泄漏。第二增加了内存分配量，你需要空间来容纳指针。 typedef Obj* objarr; objarr arr[10];//可行，没用调用构造函数 objarr *ptr = new objarr[10];//可行 为数组分配 raw memory ( 原始内存 )，可以避免浪费内存。使用 placement new 方法在内存中构造对象。 //operator new 函数 void *rawmemery = operator new( 10*sizeof(Obj)); Obj *best = static_cast\u003cObj*\u003e(rawmemery); //使用 placement new for (int i = 0; i \u003c 10; ++i) new(\u0026best[i])Obj(num); 使用 placement new 的缺点：当你不想让它继续存在使用时，必须手动调用数组对象的析构函数，然后调用操作符 delete[ ] 来释放 raw memory。 for (int i = 9; i \u003e= 0; --i) best[i].~Obj(); //析构对象 operator delete[](rawmemery); //回收内存 对于类里没有定义缺省构造函数所造成的第二个问题是它们无法在许多基于模板（template-based ）的容器类里使用。 在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。 设计虚基类时所面临的要提供缺省构造函数还是不提供缺省构造函数 几乎所有的派生类在实例化时都必须给虚基类构造函数提供参数。 这就要求所有由没有缺省构造函数的虚基类继承下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。 提供无意义的缺省构造函数也会影响类的工作效率。 如果成员函数必须测试所有的部分是否都被正确地初始化，那么这些函数的调用者就得为此付出更多的时间。 使用这种（没有缺省构造函数的）类的确有一些限制，但是当你使用它时，它也给你提供了一种保证：你能相信这个类被正确地建立和高效地实现。 运算符 重载的运算符何时并且如何被调用，它们如何运作，它们应该如何彼此联系，以及如何获得这些方面的控制权。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:4:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 5：谨慎定义类型转换函数 C++ 编译器能够在两种数据类型之间进行隐式转换（implicit conversions）。 C++ 编译器会为内置数据类型之间进行自动的隐式转换。继承于 C 语言。 自定义类型时，可以控制选择是否提供函数让编译器进行隐式类型转换。 有两种函数允许编译器进行这些的转换： 单参数构造函数（ single-argument constructors）。 隐式类型转换运算符。即：operator 目标转换type() 注：单参数构造函数是指只用一个参数即可以调用的构造函数。该函数可以是只定义了一个参数，也可以是虽定义了多个参数但第一个参数以后的所有参数都有缺省值。 可以克服隐式类型转换运算符的缺点 – 它们的存在将导致错误的发生： 通过不声明运算符（operator）的方法。 防止编译器不加鉴别地调用单参数构造函数进行类型转换方法： 构造函数名字前加 explicit 关键字。 编译器不支持关键字 explicit 时，则不声明单一参数构造函数。 将单一单数用 proxy classes ( 代理类 ) 代替，可以阻止发生调用单一参数构造函数。 ( 编译器只能进行最多一次隐式类型转换。) ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:5:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别 前缀形式返回一个引用，后缀形式返回一个 const 类型。 C++ 规定后缀形式有一个 int 类型参数，当函数被调用时，编译器传递一个 0 做为 int 参数的值给该函数。 class Obj { public: Obj operator ++ ()//前缀形式,返回对象引用 { *this += 1; return *this; } const Obj opertor ++ ( int )//后缀形式，返回一个const 值, {//加 const 是为了与内置类型相一致，内置类型不允许执行连续两次++, 如 i++++ //返回 const 对象的意义实例 Obj old = *this; *this += 1; return old; } } ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:6:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 7：不要重载 “\u0026\u0026”, “||”, 或 “,” C++ 使用布尔表达式短路求值法( short-circuit evaluation )。这表示一旦确定了布尔表达式的真假值，即使还有部分表达式没有被测试，布尔表达式也停止运算。 C++ 语言规范没有定义函数参数的计算顺序。 不能重载的运算符 \" . “、 \" . * “、 \" : : “、 \" ? : “、 new、 delete、 sizeof、 typeid、 static_cast、 dynamic_cast、 const_cast、 reinterpret_cast 在遇到 \" \u0026\u0026 “, \" || \" 和 \" , \" 时，找到一个好理由是困难的，因为无论你怎么努力，也不能让它们的行为特性与所期望的一样。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:7:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 8：理解各种不同含义的 new 和 delete placement new ( 需要 include\u003cnew\u003e) 在已经被分配但是尚未处理的 ( raw ) 内存中构造一个对象。此时可使用一种特殊的 operator new，被称之为 placement new。见条款 4 placement new 使用 new 操作符（new operator）与 operator new 的关系： 在堆上建立一个对象，用 new 操作符，既分配内存又为对象调用构造函数。 仅分配内存，则该调用 operator new 函数；它不会调用构造函数。 定制自己的在堆对象被建立时的内存分配过程，写你自己的 operator new 函数，然后使用 new 操作符，new 操作符会调用你定制的 operator new。 在一块已经获得指针的内存里建立一个对象，应该用 placement new。 Deletion and Memory Deallocation 为了避免内存泄漏，每个动态内存分配必须与一个等同相反的 deallocation 对应。 Arrays new 和 delete 操作符是内置的，其行为不受你的控制，凡是它们调用的内存分配和释放函数则可以控制。 异常 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:8:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 9：使用析构函数防止资源泄漏 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:9:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"C++ primer 第五版 ","date":"2023-10-31","objectID":"/zh-cn/cppprimer5/:0:0","tags":["C++"],"title":"C++ primer总结","uri":"/zh-cn/cppprimer5/"},{"categories":["documentation"],"content":"C++ primer 第五版","date":"2023-10-31","objectID":"/zh-cn/cppprimer5/:0:1","tags":["C++"],"title":"C++ primer总结","uri":"/zh-cn/cppprimer5/"},{"categories":["Documentation"],"content":"这篇文章是对effective c++ 的总结.","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"luckfalcon 的 github page C++编程注意条款 拷贝构造函数与拷贝赋值运算符 拷贝构造函数 : 初始化 –\u003e A(B) –\u003e 只发生在对象创建时 拷贝赋值运算符 : 同类型对象值赋值给创建对象 –\u003e A=B 值传递与引用传递 值传递 ( pass-by-value ) : 调用构造函数 引用传递 (passed-by-reference) : 不调用构造函数 C++ 包含四大次级语言 c 语言部分编程 、class 类编程、template 模板编程、STL 标准库编程。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:0:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款2：尽量以 const，enum，inline 替换 #define #define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。 #define max(a,b) f((a) \u003e (b)? (a) : (b)) int a = 5,b = 0; max(++a, b); //a被累加2次 max(++a, b+10); //a被累加1次 enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。 class Test { static const int num = 1;//此处仅为声明而非定义 int arr[num]; }; const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class Test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; }; 小结 const 对象替换 define 常量 inline 函数替换 define 形似函数 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:1:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款3：尽可能使用 const 令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性 //有理数operator* class Rational{} const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs); //可以避免客户暴力行为如: Rational a,b,c; (a * b) = c;//在a*b的结果上调用赋值运算符operator = const 成员函数，可确保类的 const 对象可被操作 如过函数的返回类型是内置类型，改动函数返回值是非法的 class text { public: const \u0026char operator[](std::size_t position)const//处理const对象，不可修改对象 {return st[position];} \u0026char operator[](std::size_t position)//处理非const对象,可修改对象 {return st[position];} private: std::string st; }; 将类成员声明为 mutable 类型，可以实现在 const 对象内修改对象的值，但并能完全解决 const 与 non-const 的全部问题。 class Text { public: std::size_t length()const; private: char *ptex; mutable std::size_t textlength;//这些变量可以被修改，即使在const对象内部 mutable bool LengthIsValid; }; std::size_t Text:: length()const { if(!LengthIsValid) { textlength = strlen(ptex); LengthIsValid = true; } return textlength; } 在 const 和 non-const 成员函数中避免重复使用，策略是利用 non-const 调用 const 的版本来实现。 char operator[](std::size_t position) { return const_cast\u003cchar \u0026\u003e( //将op[]返回值去除const static_cast\u003cconst text \u0026\u003e(*this)//为this加上const，调用const op[] )//若不给this加const，则会无限递归自己 } 小结 将某些东西声明为 const 可以帮助编译器检查错误用法。const 可以被加在任何作用域内的对象、函数参数、函数返回类型、成员函数。 编译器强制 bitwise constness (位常量性)，但你编程时应使用 “概念上的常量性” ( conceptual constness ) 。 当 const 函数与 non-const 函数有等价的实现时，用 non-const 版本调用 const 版本可避免代码重复。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:2:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款4：确定对象被使用前已先被初始化 未初始化对象可导致未定义行为 ( undefined behavior )，最终导致程序错误。 永远在对象使用之前对其初始化，内置类型直接初始化，类类型由其构造函数完成初始化 ( 类成员初始化发生在构造函数体之前，构造函数体内为赋值，初始化类成员应使用类成员初始化列表 ) class Obj { public: Obj(int i_nit,char c_init,const string \u0026s_init) :i(i_nit),c(c_init),s(s_init){}//初始化，通常效率更高 Obj(int i_nit,char c_init,const string \u0026s_init) { i = i_nit;//赋值，会先调用default构造函数，再进行拷贝赋值= c = c_init; s = s_init; } private: int i; char c; string s; }; c++ 对 \" 定义于不同编译单元内的 non-local static 对象 \" 的初始化次序并无明确定义。通过设计消除这种情况，做法是，将每个 non-local static 对象搬到自己的专属函数内 ( 该对象在此函数内被声明为 static ) 。这些函数返回一个 reference 指向它所含的对象。用户调用这些函数获得 static 对象的引用，而非直接使用 static 对象本身。 编译单元 ( translation unit ) 是指产出单一目标文件 ( sigle object file ) 的源码。基本上它是单一源码文件加上其所含入的头文件 ( #include file )。 class Ob1 { public: Ob1 \u0026obj( )//在类外定义为内联函数 { static Ob1 ob; return ob;//指向static对象的reference，而不再使用static对象自身 } }; 小结 内置类型手动初始化。 构造函数使用成员的初始化列表初始化，而非构造函数体内进行赋值，成员初始化次序最好与声明次序相同。 为免除\"跨编译单元初始化次序\"问题，以 local static 对象替换 non-local static 对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:3:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款5：了解c++默默写并调用哪些函数 空类，编译器默认生成一个无实参的 default 构造函数、一个有实参拷贝构造函数、一个拷贝赋值运算符、一个析构函数。 用户自定义构造函数后，default 构造函数不指定则编译器不再提供。 对于成员类型为引用的类，编译器默认不生成拷贝赋值运算符 ( 原因是 c++不允许改变引用的对象 ) 。 小结 编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assighnment 操作符，以及析构函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:4:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款6：若不想使用编译器自动生成的函数，就该明确拒绝 为了阻止类的拷贝赋值行为，你可以通过继承一个基类的拷贝复制操作是 private 的类来实现。 class Uncopy { public: Uncopy(); ~Uncopy();//由于非虚函数，会带来多重继承的问题 private: Uncopy(const Uncopy\u0026); Uncopy \u0026operator = (const Uncopy\u0026); }; class Obj:private Uncopy{};//此时class Obj不再声明copy函数或copy assighnment操作符 小结 为阻止编译器自动提供的功能，可将相应的成员函数声明为 private 并且不予实现，如 uncopy 基类的做法。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:5:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款7：为多态基类声明 virtual 析构函数 class Base { public: Base(); virtual function();//带有虚成员函数的类才需要虚析构函数 virtual ~Base();//析构函数声明为虚函数 } class DerivedA:public Base{}; class DerivedB:protected Base{}; class DerivedC :private Base{}; 每个带有 virtual 函数的 class 都有一个相应的 vtbl ( virtual table ) ，在运行时，由 vptr ( virtual table pointer ) 指出，从而实现带 virtual 函数。将不含 virtual 函数的类的析构函数声明为 virtual 会影响类的可移植性。 基类的析构函数非 virtual 的时，不要使用基类指针指向派生类，否则在销毁基类指针时无法调用派生类的析构函数，从而造成内存泄漏。 pure virtual 析构函数的类为抽象类，无法实例化，只适合做基类。 class Obj { public: virtual ~Obj() = 0;//纯虚函数,该类为抽象类，无法实例化，只适合做基类 }; Obj::~Obj(){};//纯虚函数的定义,不做这个定义，连接器会出错 并非所有的基类设计都是为多态用途，即不是所有的基类都需要 virtual 析构函数。 小结 polymorphic ( 带有多态性质的 ) base classes应该声明一个 virtual 析构函数。如何 class 带有 virtual 函数，那么应该声明 virtual 析构函数。 classes 的设计目的如果不是作为 base classes 使用，或者不是为了具备多态性 ( polymorphically ) ，就不应该声明 virtual 析构函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:6:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款8：别让异常逃离析构函数 c++不希望在类的析构函数中抛出异常 ( 这会导致一些容器由于多个类对象析构异常而导致不明确行为 ) 转接给客户一次处理异常的机会 class Obj { public: static obj create();//返回一个obj对象 void closed();//关闭，失败会抛出异常 }; class Manageobj { public: void closed() { closed();//非析构函数抛出异常可供用户选择处理,若在析构函数内，用户无法处理，只能选择终止或者忽略异常 closed = true; } ~Manageobj() { if(!closed) { try { closed(); } catch() { //记录close调用失败 }; } } private: Obj oj; bool closed; }; 小结 析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们 ( 阻止不传播 ) 或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通的函数 ( 而非在析构函数中 ) 执行该操作。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:7:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款9：绝不在构造和析构过程中调用 virtual 函数 小结 在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class ( 比起当前执行构造函数和析构函数的那层 ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:8:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款10：令operator = 返回一个reference to *this class Obj { public: Obj \u0026operator = (const Obj\u0026rhs) { //... return *this; }//为了实现 x = y = z = Value; }; 小结 令赋值 ( assignment ) 操作符返回一个 reference to *this。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:9:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款11：在 operator = 中处理 \" 自我赋值 \" 让 operator = 具备 \" 异常安全性 \" 同时也会获得 \" 自我赋值安全 \" 。 class Op{}; class Obj { public: private: Op *ptr; //类成员含有指针或引用 }; Obj \u0026Obj::operator = (const Obj \u0026rhs) { Op *p = ptr; //记住原先的ptr ptr = new Op(rhs.ptr);//令ptr指向*ptr的一个副本 delete p; //删除原先的ptr return *this; } 复制交换 ( copy and swap ) 技术，可以作为上述方案的替代方案。 class Op{}; class Obj { public: void swap(Obj \u0026rhs); private: Op *ptr; //类成员含有指针或引用 }; Obj \u0026Obj::operator = (const Obj \u0026rhs) { Op temp(rhs);//将rhs数据制作一份副本 swap(temp);//将*this数据和上述副本的数据交换 return *this; } //值传递(passed by value)--有时候可令编译器生成高效的代码 Obj \u0026Obj::operator = (Obj rhs) { swap(ths); return *this; } 小结 确保当对象自我赋值时 perator = 有良好的行为。其中的技术包括比较 \" 来源对象 \" 和 \" 目标对象 \" 的地址、精心周到的语句顺寻、以及 copy-and-swap。 确定任何函数如何操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:10:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款12：复制对象时勿忘其每一个成分 derived class 的 base class 成分在 derived class 的构造函数中应调用 base class 的构造函数完成。 不应该令 copy assignment 操作符调用 copy 构造函数，反之也同样没有意义。 如果 copy assignment 操作符和 copy 构造函数有相同重复的代码，通常在 private 区设置一个 init 函数将相同部分代码包含进去。 小结 copy函数 ( copy assignment 操作符和 copy 构造函数统称 ) 应该确保复制 \" 对象内的所有成员变量 \" 及 \" 所有 base class 成分 \" 。 不要尝试以某个 copy 函数实现另一个 copy 函数。应该将共同机能放进第三个函数中，并由两个 copy 函数共同调用。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:11:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款13：以对象管理资源 获取资源后立即放进管理对象内，管理对象运用析构函数确保资源被释放。以对象管理资源常被称为资源取得时机便是初始化时机 ( Resource Acquisition Is Initialization, RAII ) 。 class Obj { public: Obj *create(); }; void f() { //c++11后已经弃用auto_ptr,用unique_ptr代替 //这样做的前提是绝对没有一个以上的auto_ptr同时指向该对象 std::auto_ptr\u003cObj\u003ep_Obj(create());//auto_ptr为一个类指针对象模板 //... } auto_ptrs 一个特殊性质：若通过 copy assignment 操作符和 copy 构造函数复制它们，它们会变成 null，而复制所得的指针将取得资源的唯一拥有权。 { std::auto_ptr1\u003cObj\u003ep_Obj(create());//ptr1指向create返回对象 std::auto_ptr2(ptr1); //ptr2指向该对象，ptr1被置为null ptr1 = ptr2; //ptr1指向该对象，ptr2被置为null } 克服 auto_ptr 的弊端，改用引用计数智能指针 ( reference-counting smart pointer,RCSP )，如 shared_ptr。 没有针对 \" c++动态分配数组 \" 的智能指针，因为 vector 和 string 几乎可以完全代替动态分配数组。 小结 为防止资源泄露，请使用 RAII 对象，它们在构造函数中获取资源并在析构函数中释放资源。 两个常用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr ( c++11 后用 unique_ptr ) 。前者通常是最佳选择，因为其 copy 行为比较直观。若选择 auto_ptr，复制动作会使它 ( 被复制物 ) 指向 null。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:12:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款14：在资源管理类中小心 copying 行为 小结 复制 RAII 对象必须一并复制它所管理的资源，所以资源的copying行为 ( 通常需要深拷贝 ) 决定 RAII 对象的 copying 行为。 普通而常见的 RAII class copying 行为：抑制 copying、(可用 shared_ptr) 施行引用计数方法 ( reference counting ) 。不过其他行为也都可能实现。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:13:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款15：在资源管理类中提供对原始资源的访问 小结 APIs 往往要求访问原始资源 ( raw resources )，所以每个 RAII class 应该提供一个 \" 取得其所管理之资源 \" 的办法。 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:14:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款16：成对使用 new 和 delete 时要采用相同形式 小结 new 表达式中使用 [ ]，必须在相应的 delete 表达式中也使用 [ ]。new 表达式中不使用 [ ]，一定不要在相应的 delete 表达式中使用 [ ]。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:15:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款17：以独立语句将 newed 对象置入智能指针 class Obj{}; int func1(); void func2(shared_ptr\u003cobj\u003e,int); func2(shared_ptr\u003cobj\u003e(new obj),func1()); //此处编译器要进行三个过程，new Obj、调用shared_ptr初始化指针、调用func1, //但三者没有固定顺序，若func1发生在其它两个过程之间，且发生异常，则会导致new Obj发生泄漏 小结 以独立语句将 newed 对象存入 ( 置入 ) 智能指针内。如果不这样，一旦异常被抛出，有可能导致难以察觉的资源泄漏。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:16:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款18：让接口容易被正确使用，不易被误用 尽量让你的 types 的行为与内置 types 一致。 返回 shared_ptr 让接口设计者得以阻止大部分资源泄漏错误。 智能指针管理非 new 的资源时需要手动传入一个删除器。 小结 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达到这个性质。 “促进争取使用\"的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用\"的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 shared_ptr 支持定制型删除器 ( custom deleter )。这可防止 DLL ( 动态链接库 ) 问题，可被用来自动解除互斥锁 ( mutexes ) 等等。 所谓的 \" cross-DLL problem “，这个问题发生于 \" 对象在动态连接程序库 ( DLL ) 中被 new 创建，却在另一个 DLL 内被 delete 销毁 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:17:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款19：设计 class 犹如设计 type 新 class 设计规范问题： 新的 type 应该如何被创建和销毁？ 对象的初始化和对象的赋值该有什么样的差别？ 新 type 对象如果被 passed by value ( 以值传递 )，意味着什么？ 什么是新 type 的 \" 合法值 \" ？ 你的新 type 需要配合某个继承图系 ( inheritance graph ) 吗？ 你的新 type 需要什么样的转换？ 什么样的操作符和函数对此新 type 而言是合理的？ 什么样的标准函数应该驳回？ 谁该取用新 type 的成员？ 什么是新 type 的\"未声明接口”？ 你的新 type 有多么一般化？ 你真的需要一个新 type 吗？ 小结 class 的设计就是 type 的设计。在定义一个新type时请考虑以上问题。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:18:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value 缺省情况下 C++ 以 by value 方式传递对象至函数。 一般而言，pass by value 唯一对象是内置类型和 STL 的迭代器和函数对象。 小结 尽量以 passed-by-reference-to-const 替换 passed-by-value。前者通常高效，并可避免切割问题 (slicing problem)。 以上规则不适合内置类型，以及STL的迭代器和函数对象。对它们而已，passed-by-value往往比较适当。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:19:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款21：必须返回对象时，别妄想返回其 reference 一个 \" 必须返回新对象 \" 的正确写法： class Rational { public: Rational(int numerator = 0,int denominator = 1); private: int n;//分子(numerator) int d;//分母(denominator) friend const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.n*rhs.n,lhs.d*rhs.d); } }; 小结 绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:20:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款22：将成员变量声明为 private 小结 切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性。 protected 并不比 public 更具封装性。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:21:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款23：宁以 non-member、non-friend 替换 member 函数 将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以扩展这一组便利函数。 // class_def.h namespace name { class Obj { public: void fun1(); void fun2(); void fun3(); }; void do_fun1(Obj \u0026oj){oj.fun1();}//核心机能，包含客户都需要的non-member函数 void do_fun3(Obj \u0026oj){oj.fun3();}//非成员函数可以进一步提高class的封装性 } //fun1_use.h//客户扩展头文件 namespace name { void fun1(); } 小结 宁以拿 non-member、non-friend 替换 member 函数。这样可以增加封装性、包裹弹性 ( packaging flexibility ) 和机能扩充性。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:22:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款24：若所有参数皆需类型转换，请为此采用 non-member 函数 class Rational { public: Rational(int numerator = 0,int denominator = 1); int numerator()const; int denominator()const; private: int n;//分子(numerator) int d;//分母(denominator) }; //非成员友元函数声明方式 const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } 小结 如果你需要为某个函数的所有参数 ( 包括被 this 指针所指的那个隐喻参数 ) 进行类型转换，那么这个函数必须是 non-member 函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:23:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款25：考虑写出一个不抛出异常的 swap 函数 所有的 STL 容器都提供有一个 public swap 成员函数和 std::swap 特化版本 ( 用以调用前者 )。 c++ 只允许对 class template 偏特化 ( partially specialize )，但不能对 function template 偏特化。 c++ std 空间可以全特化所有内含 template，但不可以添加新的 template 进去。 namespace name_obj { class Obj { public: void swap(const Obj \u0026b){using std::swap;}; } void swap(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//合法 } namespace std//在std内特化 { template\u003c\u003e void swap\u003cObj\u003e(obj \u0026a,Obj \u0026b){a.swap(b);};//特例化某个类，合法 //Obj成为类模板的时 template\u003ctypename T\u003e void swap\u003cObj\u003cT\u003e\u003e(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//函数模板偏特化，错误，不合法 template\u003ctypename T\u003e void swap(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//也不合法 } pimpl 是 “pointer to implementation” 的缩写。 swap 的版本包含，default swap (适合不含指针成员的类或类模板)、member swap、non-member swap、std::swap 特化版。 如果缺省 swap 效率不足 ( class 或 template 使用了某种 pimpl 手法 )，可试以下方法： 提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值。该函数不应抛出异常。 在你的 class 或 template 所在的命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。 如果你正编写一个 class ( 而非 class template )，为你的 class 特化 std::swap。并令它调用你的 swap 成员函数。 swap 一个最好的应用是帮助 classes( 和 class templates ) 提供强烈的异常 ( exception-safety ) 保障。 小结 当 std::swap 对你的类型效率不高时，提供一个成员 swap 函数，并确定这个函数不抛出异常。 如果你提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于 class ( 而非 template )，也请特化 std::swap。 调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何 \" 命名空间资格修饰 \" 。 为 \" 用户定义类型 \" 进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。 实现 (implementations) ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:24:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款26：尽可能延后变量定义式的出现时间 目的是减少不必要的对象构造和析构 class Obj{}; Obj oj; //A：1次构造+1次析构+n次赋值 for(int i;i \u003c n;++i) { oj = i; }; // for(int i;i \u003c n;++i) { Obj oj; //B：n次构造+n次析构，通常B比A更高效一点，除非，赋值比构造+析构成本低 oj = i; }; 小结 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:25:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款27：尽量少做转型动作 c++ 四类型转换形式 : const_cast(expression) dynamic_cast(expression) reinterpret_cast(expression) static_cast(expression) const 到 non-const 转换 运行时，安全向下类型转换 执行低级转型 除去 const 到 non-const 的转换，其他一般类型转换 小结 如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码内。 宁可使用 C++-style ( 新式 ) 转型，不要使用旧式转型。前者容易辨识出来，而且也比较有着分门别类的执掌。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:26:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款28：避免返回 handles 指向对象内部成分 小结 避免 handles ( 包括 references、指针、迭代器 ) 指向对象内部。遵守这个条款可以增加封装性，帮助 const 成员函数的行为像个 const，并将发生\"虚吊号码牌”( dangling handles ) 可能降到最低。 虚吊号码牌：使用已经销毁的对象的引用、指针或迭代器。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:27:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款29：为 \" 异常安全 \" 而努力是值得的 异常安全性两个条件： 异常抛出时，不泄漏任何资源。 异常抛出时，不允许数据败坏。 异常安全函数提供三种不同级别保证： 基本保证 强烈保证 不抛保证 异常抛出后，程序内所有事物保持有效状态，这些状态是未预知的|异常抛出后，程序状态不改变，回到被调用前状态 异常抛出后，程序状态不改变，回到被调用前状态 承诺不抛出异常，因其总能完成原有的功能。作用于内置类型所有操作应提供 nothrow 保证 小结 异常安全函数 ( Exception-safty functions ) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。 “强烈保证” 往往能够以 copy-and-swap 实现出来，但 \" 强烈保证 \" 并非对所有函数都可实现或具备现实意义。 函数提供 \" 异常安全保证 \" 通常最高只等于其所调用之各个函数的 \" 异常安全保证 \" 中的最弱者。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:28:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款30：透彻了解 inlining 的里里外外 inlining 在大多数 c++ 程序中是编译期行为。 inline 函数通常一定被置于头文件中，通常置于函数本体小的函数前，向编译器申请在调用处替换展开本体，但非强制命令，编译器可忽略。 对于函数本体较大的函数 inlining 会引发代码膨胀。 编译器通常不会对 \" 通过函数指针而进行的调用 \" 实施 inlining。 小结 将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 ( binary upgradability ) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为 function templates 出现在头文件，就将它们声明为 inline。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:29:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款31：将文件间的编译依存关系降至最低 将接口与实现分离。 编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其 他文件内的声明式 ( 而非定义式 ) 相依 – 该设计策略如下： 如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects。 如果能够，尽量以 class 声明式替换 class 定义式。 为声明式和定义式提供不同的头文件。 Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性 ( compilation dependencies ) 。 在 Handle classes 身上，成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。 至于 Interface classes，由于每个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃 ( indirect jump ) 成本 ( 见条款 7 ) 。 小结 支持 \" 编译依存性最小化 \" 的一般构想是: 相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。 程序库头文件应该以 \" 完全且仅有声明式 \" ( full and declaration-only forms ) 的形式存在。这种做法不论是否涉及 templates 都适用。 六、继承与面向对象 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:30:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款32：确定你的 public 继承塑模出 is-a 关系 以 C++ 进行面向对象编程，最重要的一个规则是：public inheritance ( 公有继承 ) 意味 \" is-a \" ( 是一种 ) 的关系。 is-a 并非是唯一存在于 classes 之间的关系。另两个常见的关系是 has-a ( 有一个 ) 和 is-implemented-in-terms-of ( 根据某物实现出 ) 。 小结 \" public 继承 \" 意味 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:31:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 33：避免遮掩继承而来的名称 内层作用域的名称会遮掩 ( 遮蔽 ) 外围作用域的名称。 编译器查找名称规则由内层作用域查找到名称后即停止查找，并不关注类型。 derived class 作用域被嵌套在 base class 作用域内。 小结 derived classes 内的名称会遮掩 base classes 内的名称。 在 public 继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数 ( forwarding functions ) 。 using 声明式和转交函数： class base{ public: virtual void fun1(int x);}; class derived1 : public base { public: using base::fun1; void fun1(); }; class derived1 : private base { public: virtual void fun1()//转交函数 { base::fun1(); } }; ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:32:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 34：区分接口继承和实现继承 pure virtual 函数有两个最突出的特性：它们必须被任何 \" 继承了它们 \" 的具象 class 重新声明，而且它们在抽象 class 中通常没有定义。 声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。 derived classes 继承其函数接口, 但 impure virtual 函数会提供一份实现代码, derived classes 可能覆写 ( override ) 它。 声明简朴的(非纯) impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。 声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。 pure virtual 函数 simple ( impure ) virtual 函数 non-virtual 函数 只继承接口 继承接口和一份缺省实现 继承接口和一份强制实现 \" 80 - 20 \" 法则：一个典型的程序有 80 % 的执行时间花费在 20 % 的代码身上 。 小结 接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。 pure virtual 函数只具体指定接口继承。 简朴的 ( 非纯 ) impure virtual 函数具体指定接口继承及缺省实现继承。 non-virtual 函数具体指定接口继承以及强制性实现继承。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:33:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 35：考虑 virtual 函数以外的其他选择 通过 Non-Virtual Interface 手法实现 Template Method 模式： class Base { public: int fun()const//这个no-virtual 函数为 virtual 函数的外覆器 (wrapper) { int relval=dofun(); return relval; } private: virtual int dofun()const{...}; }; 令客户通过 public non-virtual 成员函数间接调用 private virtual 函数 – 为 non-virtual interface ( NVI ) 手法。 derived classes 可重新定义继承而来的 private virtual 函数。 通过 Function Pointers 实现 Strategy 模式 通过 函数模板 function \u003c T \u003e 完成 Strategy 模式 trl1: :bind，可改变可调对象入口参数个数和顺序，同时返回一个新的可调对象。 古典的 Strategy 模式 (设计模式 ( design patterns ) ) 。 几种 virtual 函数替代方案如下： 使用 non-virtual interface ( NVI ) 手法，那是 Template Method 设计模式的一种特殊形式。它以 public non-virtual 成员函数包庄较低访问性 ( private 或 protected ) 的 virtual 函数。 将 virtual 函数替换为 \" 函数指针成员变量 “，这是 Strategy 设计模式的一种分解表现形式。 以 trl::function 成员变量替换 virtual 函数，因而允许使用任何可调用物 ( callable entity ) 搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。 将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 Strategy 设计模式的传统实现手法。 小结 virtual 函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式。NVI手法自身是一个特殊形式的 Template Method 设计模式。 将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public 成员。 trl::function 对象的行为就像一般函数指针。这样的对象可接纳 \" 与给定之目标签名式 ( target signature ) 兼容 \" 的所有可调用物 ( callable entities ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:34:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 36：绝不重新定义继承而来的 non-virtual 函数 derived classes 绝对不该重新定义一个继承而来的non-virtual 函数 ( 此处指的是 base class 析构函数 ) 。 小结 绝对不要重新定义继承而来的 non-virtual 函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:35:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 37: 绝不重新定义继承而来的缺省 ( 默认 ) 参数值 只能继承两种函数: virtual 和 non-virtual 函数。 virtual 函数系动态绑定 ( dynamically bound ) ，而缺省(默认)参数值却是静态绑定 ( statically bound ) 。 对象的所谓静态类型 ( static type ) ，就是它在程序中被声明时所采用的类型。 对象的所谓动态类型 ( dynamic tvpe ) 则是指 \" 目前所指对象的类型 “。 class base { public: virtual void set(base b = bs)const = 0;//带有默认参数 }； class derived:public base { public: virtual void set(base b = bs)const;//会出现重复定义 virtual void set(base b = ds)const;//默认参数不一样 virtual void set(base b)const;//动态绑定(base指针引用访问时)时才会继承base默认参数， //静态绑定(derived对象访问)时不会继承默认参数 }; 条款35列了不少 virtual 函数的替代设计，其中之一是 NVI ( non-virtual interface ) 手法令 base class 内的一个 public non-virtual 函数调用 private virtual 函 数，后者可被 derived classes 重新定义。 小结 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数一一你唯一应该覆写的东西一一却是动态绑定。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:36:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 38: 通过复合塑模出 has-a 或 \" 根据某物实现出 \" 复合 ( composition ) 是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系 复合 ( composition ) 这个术语有许多同义词，包括 layering ( 分层 ) ，constainment ( 内含 ) , aggregation ( 聚合 ) 和 embedding ( 内嵌 ) 。 应用域 ( appjicarion domain ) 与实现域 ( implementation domain ) 程序中的对象其实相当于你所塑造的世界中的某些事物 ( 如人、汽车 )，这样的对象属于应用域 ( appjicarion domain ) 部分。 其他对象则纯粹是实现细节上的人工制品(如缓冲区、互斥锁)，这些对象相当于你的软件的实现域。 当复合发生于应用域内的对象之间，表现出 has-a 的关系; 当它发生于实现域内则是表现 is-implemented-in-terms-of 的关系。 set 和 list 的关系非 is-a 关系，而是 is-implemented-in-terms-of 关系。 小结 复合 ( composition ) 的意义和 public 继承完全不同。 在应用域 ( application domain ) ，复合意味 has-a ( 有一个 )。在实现域 ( implementation domain ) ，复合意味 is-implemented-in-terms-of ( 根据某物实现出 ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:37:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 39: 明智而审慎地使用 Private 继承 Private 继承意味 is-implemented-in-terms-of ( 根据某物实现出 )。 尽可能使用复合，必要时才使用 private 继承。 private 继承主要用于 \" 当一个意欲成为 derived class 者想访问一个意欲成为 base class 者的 protected 成分，或为了重新定义一或多个 virtual 函数 “。 class empty{}; sizeof(empty) = 1; class derived:private empty { private: int x; }; sizeof(derived) == sizeof(int); //编译器 EBO (empty base optimization; 空白基类最优化)，一般发生在单一继承才可行，多继承则不会发生。 现实中的 \" empty \" classes 并不真的是 empty，往往内含 typedefs，enums， static 成员变量，或 non-virtual 函数。 许多技术用途的 empty classes，其中内含有用的成员 ( 通常是 typedefs )，包括 base classes unary_function 和 binary_function，这些是 \" 用户自定义之函数对象 \" 通常会继承的 classes。 小结 Private 继承意味 is-implemented-in-terms of ( 根据某物实现出 ) 。它通常比复合 ( composition ) 的级别低。但是当 derived class 需要访问 protected base class 的 成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。 和复合 ( composition ) 不同，private 继承可以造成 empty base 最优化。这对致力于 \" 对象尺寸最小化 \" 的程序库开发者而言，可能很重要。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:38:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 40: 明智而审慎地使用多重继承 多重继承 ( multiple inheritance；MI )，单一继承 ( single inheritance; SI ) 。 C++ 用来解析 ( resolving ) 重载函数调用的规则：在看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。 多重继承会导致二义性问题 ( 避免继承得来的成员变量重复 )，通常采用 virtual 继承: class derived:virtual public base1, virtual public base2{}; 小结 多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。 virtual 继承会增加大小、速度、初始化 ( 及赋值 ) 复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及 \" public 继承某个 Interface class \" 和 \" private 继承某个协助实现的 class \" 的两相组合。 七、模板与泛型编程 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:39:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 41：了解隐式接口和编译期多态 面向对象编程世界总是以显式接口 ( explicit interfaces ) 和运行期多态 ( runtime polymorphism ) 解决问题。 Templates 及泛型编程的世界以隐式接口 ( implicit interfaces ) 和编译期多态 ( compile-time polymorphism ) 为主。 小结 classes 和 templates 都支持接口 ( interfaces ) 和多态 ( polymorphism ) 。 对 classes 而言接口是显式的 ( explicit ), 以函数签名为中心。多态则是通过 virtual 函数发生于运行期。 对 template 参数而言，接口是隐式的 ( implicit ) ，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析 ( function overloading resolution ) 发生于编译期。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:40:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 42：了解 typename 的双重意义 C++ 有个规则可以解析 ( resoive ) 此一歧义状态：如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。 template 内出现的名称如果相依于某个 template 参数，称之为从属名称 ( dependent names ) 。 如果从属名称在 class 内呈嵌套状，我们称它为嵌套从属名称 ( nested dependent rame ) 。 只要在嵌套从属名称之前放置关键字 typename，即可告知解析器该名称为类型。 template\u003ctypename T\u003e typename T::const_iterator it();//告知解析器T::const_iterator 为类型 T t; //T 非嵌套从属名称 typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 mermber initialization list ( 成员初值列 ) 中作为 base class 修饰符。 template\u003ctypename T\u003e class derived:public base\u003cT\u003e::nested // base classes list { public: explicit derived(int x):base\u003cT\u003e::nested(x) //成员列表初始化 { typename base\u003cT\u003e::nested temp; //... } }; 小结 声明 template 参数时，前缀关键字 class 和typename 可互换。 请使用关键字 typename 标识嵌套从属类型名称; 但不得在 base class lists ( 基类列 ) 或 member initialization list ( 成员初值列 ) 内以它作为 base class 修饰符。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:41:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 43：学习处理模板化基类内的名称 模板化基类 ( templatized base classes )内的函数名称会被 derived classes 掩盖。 若基类模板存在特例化版本，则在 derived class template 的时候会发生编译错误，这时可以将 derived class template 涉及 base class template 的成员函数前加 \" this-\u003e \" 来指涉 base class template 内的函数。 小结 可在 derived class templates 内通过 \" this-\u003e \" 指涉 base class templates 内的成员名称，或通过一个明白写出的 \" base class 资格修饰符 \" 完成。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:42:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 44：将与参数无关的代码抽离 templates 共性与变性分析 ( commonality and variability analysis ) 小结 Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。 因非类型模板参数 ( non-type template parameters ) 而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。 因类型参数 ( type parameters ) 而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述 ( binary representations ) 的具现类型 ( instantiation types ) 共享实现码。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:43:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 45：运用成员函数模板接受所有兼容类型 如果以带有 base-derived 关系的 B, D 两类型分别具现化某个 template，产生出来的两个具现体并不带有 base-derived 关系。 Templates 和泛型编程 ( Generic Programming ) 泛化 ( generalized ) copy构造函数 template\u003ctypename T\u003e class SmartPtr { public: //泛化copy构造函数,并保证只根据U生成T对象,保证public继承的隐式转换 //泛化copy构造函数不等于copy构造函数，如果需要控制copy行为，还需自定义copy构造函数 SmartPtr(const SmartPtr \u0026sptr);//普通copy构造函数 template\u003ctypename U\u003e //泛化copy构造函数 SmartPtr(const SmartPtr\u003cU\u003e \u0026other):heldPtr(other.get()) {...} T *get()const {return heldPtr;} private: T *heldPtr; }; 小结 请使用 member function templates ( 成员函数模板 ) 生成 \" 可接受所有兼容类型 \" 的函数。 如果你声明 member templates 用于 \" 泛化 copy构造函数 \" 或 \" 泛化 assigmment操作 “，你还是需要声明正常的 copy 构造函数和 copy assigmmenmt 操作符。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:44:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 46：需要类型转换时请为模板定义非成员函数 在 function template 实参推导过程中从不进行隐式类型转换。 Class templates 并不倚赖 tetmplate 实参推导 ( 后者只施行于 function templates 身上 ) ，所以编译器总是能够在 class template 具现化时得知 T。 template\u003ctypename T\u003e class Rational//template class { public: Rational(T numerator = 0,T denominator = 1); T numerator()const; T denominator()const; friend const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); }//定义在外部时，将只可通过编译却无法连接 private: T n;//分子(numerator) T d;//分母(denominator) }; 小结 当我们编写一个 class template，而它所提供之 \" 与此 template 相关的 \" 函数支持 \" 所有参数之隐式类型转换 \" 时，请将那些函数定义为 \" class template 内部的 friend 函数 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:45:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 47：请使用 traits classes 表现类型信息 STL 主要由 \" 用以表现容器、迭代器和算法 \" 的 templates 构成，以及若干工具性 templates。 STL 共有 5 种迭代器分类 Input 迭代器 Output 迭代器 Forward 迭代器 Bidirectional迭代器 Random access 迭代器 Istream_iterators Ostream_iterators 不支持linked list STL list, set, multiset, map, multimap 的迭代器 vector,deque, string 的迭代器 只能向前最多一次读操作 只能向前最多一次写操作 向前多次操作 可以向前移动，还可以向后移动 支持迭代器算术，双向 is-a关系： input、output forward : public input bidirectional : public forward random : public bidirectional advance(Iter, Disance) 设计并实现一个 traits class： 确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类 ( category ) 。 为该信息选择一个名称 ( 例如 iterator_category ) 。 提供一个 template 和一组特化版本 ( 例如稍早说的 iterator_traits ) ，内含你希望支持的类型相关信息。 如何使用一个 traits class： 建立一组重载函数 ( 身份像劳工 ) 或函数模板 ( 例如 doadvance ) ，彼此间的差异只在于各自的 traits 参数。令每个函数实现码与其接受之 traits 信息相应和。 建立一个控制函数 ( 身份像工头 ) 或函数模板 ( 例如 advance ) ，它调用上述那些 \" 劳工函数 \" 并传递 traits class 所提供的信息。 小结 Traits classes 使得 \" 类型相关信息 \" 在编译期可用。 它们以 templates 和 \" templates 特化 \" 完成实现。 整合重载技术 ( overloading ) 后，traits classes 有可能在编译期对类型执行 if…else 测试。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:46:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 48：认识 template 元编程 Template metaprogramming ( TMP，模板元编程 ) 是编写 template-based C++ 程序并执行于编译期的过程。 template metaprogram ( 模板元程序 ) 是以 C++ 写成、执行于 C++ 编译器内的程序。 //阶层(factorial)模板元编程,递归模板具现化实现循环 template\u003cunsigned n\u003e struct Factorial { enum{value = n*Factorial\u003cn-1\u003e::value}; } template\u003c\u003e struct Factorial\u003c0\u003e { enum{Value = 1}; } //main.cpp cout\u003c\u003cFactorial\u003c5\u003e::value\u003c\u003cendl;//计算5的阶层 小结 Template metaprogramming ( TMP，模板元编程 ) 可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。 TMP 可被用来生成 \" 基于政策选择组合 \" ( based on combinations of policy choices ) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 第八章 定制 new 和 delete ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:47:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 49：了解 new-handler 的行为 小结 set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具，因为它只适用于内存分配; 后继的构造函数调用还是可能抛出异常。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:48:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 50：了解 new 和 qelete 的合理替换时机 何时可在 \" 全局性的 \" 或 \" class 专属的 \" 基础上合理替换缺省的 new 和 delete: 为了检测运用错误。 为了收集动态分配内存之使用统计信息。 为了增加分配和归还的速度。 为了降低缺省内存管理器带来的空间额外开销。 为了弥补缺省分配器中的非最佳齐位 ( suboptimal atignment ) 。 为了将相关对象成簇集中。new 和 delete 的 \" placement 版本 \" ( 见条款52 ) 有可能完成这样的集簇行为。 为了获得非传统的行为。 小结 有许多理由需要写个自定的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:49:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 51：编写new 和 delete 时需固守常规 小结 OPerator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。Class 专属版本则还应该处理 \" 比正确大小更大的 ( 错误 ) 申请 \" 。 operator delete 应该在收到 null 指针时不做任何事。Class 专属版本则还应该处理 \" 比正确大小更大的 ( 错误 ) 申请 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:50:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款52：写了 placement new 也要写 placement delete 如果 operator new 接受的参数除了一定会有的那个 size_t 之外还有其他，这便是个所谓的 placerment new。 #include\u003cnew\u003e//标准库 static void* operator new(std: :size_t, void* PMemory) throw(); //纳入标准库内的pacement new //非标准 static void* operator new(std: :size_t, std::ostream \u0026) throw(std::bad_alloc); static void operator delete(void *, std::ostream \u0026) throw();//placement delete 缺省情况下 C++ 在 global 作用域内提供以下形式的 operator new： #include\u003cnew\u003e static void* operator new(std: :size_t)throw();//正常的new static void* operator new(std: :size_t, void *) throw();//placement new static void* operator new(std: :size_t, const std::nothrow_t \u0026) throw();//nothrow new 如果你在 class 内声明任何 operator news，它会遮掩上述这些标准形式。为使这些函数有着平常的行为，只要令你的 class 专属版本调用 global 版本即可： //将标准形式放在一个class中，然后让客户继承及using声明式取得标准形式 class standard { public: static void* operator new(std::size_t size)throw(std::bad_alloc) { return ::operator new(size);//分别调用标准形式 } ... } class wiget:public standard { public: using standard::operator new; //定义自己的operator new } 小结 当你写一个 placement operator new，请确定也写出了对应的 placerment operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明 placement new 和 placement delete，请确定不要无意识 ( 非故意 ) 地遮掩了它们的正常版本。 第九章杂项讨论 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:51:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 53：不要轻忽编译器的警告 警告信息天生和编译器相依，不同的编译器有不同的警告标准。 小结 严肃对待编译器发出的警告信息。努力在你的编译器的最高 ( 最严苛 ) 警告级别下争取 \" 无任何警告 \" 的荣誉 。 不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:52:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 54：让自己熟悉包括 TR1 在内的标准程序库 小结 C++ 标准程序库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。 TR1 添加了智能指针 ( 例如 trl: :shared_ptr ) 、一般化函数指针 ( trl: :function ) 、hash-based 容器、正则表达式 ( regular expressions ) 以及另外 10个组件的支持。 TR1 自身只是一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:53:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 55：让自己熟悉 Boost Boost 是一个 C++ 开发者集结的社群, 也是一个可自由下载的 C++ 程序库群。boost网址 Boost Graph Library (用于编写任意 graph 结构)。 Boost MPL Library ( 一个元编程程序库，metaprogramming library )。 Boost 程序库内包含种类： 字符串与文本处理。 容器。 函数对象和高级编程。 泛型编程 ( Generic programming )。 模板元编程 ( Template metaprogramming，TMP ) 。 数学和数值 ( Math and numerics ) 。 正确性与测试 ( Correctness and testing ) 。 数据结构。 语言间的支持 ( Inter-language support ) 。 内存。 等等 小结 Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。 Boost 提供许多 TR1 组件实现品，以及其他许多程序库。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:54:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["documentation"],"content":"cmake 总结","date":"2023-11-10","objectID":"/zh-cn/cmake-sumary/","tags":["cmake"],"title":"Cmake 总结","uri":"/zh-cn/cmake-sumary/"},{"categories":["software"],"content":"Ubuntu(Linux) /Windows 配置 Linux 下编译运行命令 #切换至构建目录并编译文件 cd build cmake .. make #运行 ./demo #可执行文件名 Windows 下编译运行命令 cd build cmake -G \"MinGW Makefiles\" .. #指定生成编译文件类型为makefile，否则会调用vs编译成vs文件 mingw32-make.exe #生成可执行文件 launch.json { \"configurations\": [ { \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/demo\", #调试可执行文件所在路径及名字 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"description\": \"Set Disassembly Flavor to Intel\", \"text\": \"-gdb-set disassembly-flavor intel\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Build\", #调试前预处理生产可执行文件 \"miDebuggerPath\": \"/usr/bin/gdb\" #调试器运行路径 } ] } tasks.json { \"version\": \"2.0.0\", \"options\": { \"cwd\": \"${workspaceFolder}/build\" #项目构建路径 }, \"tasks\": [ { \"type\": \"shell\", \"label\": \"cmake\", \"command\": \"cmake\", \"args\": [ \"..\" #cmake 工程路径 ] }, { \"label\": \"make\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, #\"command\":\"mingw32-make.exe\", \"command\":\"make\", #linux 下为 make, windows 下为 mingw32-make.exe \"args\": [ ] }, { \"label\": \"Build\", \"dependsOrder\": \"sequence\",//按列出的顺序执行任务P \"dependsOn\":[ \"cmake\", \"make\" ] } ] } ","date":"2024-01-22","objectID":"/zh-cn/vscode-config/:1:0","tags":["vscode"],"title":"Vscode运行配置","uri":"/zh-cn/vscode-config/"},{"categories":["Documentation"],"content":"设计模式 设计模式 面向对象编程优点： 可维护 可复用 可扩展 灵活性好 面向对象三大特性：封装、继承、多态降低程序的耦合度 业务逻辑和界面逻辑分开降低两者间度耦合度 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:0:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"UML类图 用一个单独的类来创造实例的过程，这个类就是简单工厂类。 UML类图\rUML类图是一种强大的工具，可用于可视化和传达软件系统的结构和关系。 类图分三层： 类名(抽象类用斜体) 类的特性(通常是字段和属性) 类的操作(通常是方法和行为) 注意: ‘+’ 表示 pubilc, ‘-’ 表示 private, ‘#’ 表示 protected。 接口图 与类图区别在于顶端有 « interface »显示。 « interface » 接口名称 接口方法 还有一种表示方法叫做棒棒糖表示法。 继承关系用空三角 + 实线来表示。 实现接口用空三角 + 虚线来表示。 关联关系用实线箭头表示。 聚合 : 表示一种弱的”拥有“关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分。空心菱形 + 实心箭头表示。 合成(组合) : 是一种强的\"拥有\"关系，体现了严格的部分与整体关系，部分和整体的生命周期一样。实心菱形 + 实心箭头表示。合成关系两端各有一个基数表示该端可以有几个实例。 依赖关系用虚线箭头表示。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:1:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"策略模式 它定义了一个算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法到用户。 策略模式结构\r它允许在运行时选择算法的行为，而不是在编译时固定使用特定算法。该模式属于行为型设计模式，它通过将一组算法封装在可互换的策略对象中，以使算法的选择和使用与客户端代码解耦。 策略模式到核心是实现算法的封装 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:2:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"单一职责原则(SRP) 就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到当破坏。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。 如果你能想到多于一个动机去改变一个类，那么这个类就具有多于一个职责，就应该考虑类的职责分离。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:3:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"开放-封闭原则(开-闭原则，OCP) 开放-封闭原则，是说软件实体(类、模板、函数等等)应该可以扩展，但是不可修改。即，对于扩展是开放的，对于更改是封闭的。 无论模块是多么\"封闭\"，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须猜测出最有可能发生的变化种类(这种方式不太现实)，然后构造抽象来隔离那些变化。 在我们最初编写代码时，假设变化不发生。当变化发生时，我们就创建抽象来隔离以后发生同类的变化。 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那部分做出抽象，然而，对于应用程序中的每个部分都时刻地进行抽象同样不是一个好主意。拒绝不成熟地抽象和抽象本身一样重要。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:4:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"依赖倒转原则 依赖倒转原则： 高层模块不应该依赖低层模块。两个都应该依赖抽象。 抽象不应该依赖细节。细节应该依赖抽象。 抽象不应该依赖细节，细节应该依赖于抽象。即应针对接口编程，不应该对实现编程。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:5:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"里氏代换原则(LSP) 里氏代换原则:子类型必须能够替换掉它的父类型。即，在软件里面，把父类都替换称它的子类，程序行为没有变化。 只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类基础上增加新的行为。 依赖倒转其实可以说是面向对象设计的标志，用哪些语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象设计，反之那就是过程设计。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:6:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"装饰模式 装饰模式(Decorator): 动态地给一个对象添加额外的职责，就增加功能来说，装饰模式比生成子类更灵活。 装饰模式结构\r装饰模式是利用 SetComponent 来对对象进行包装。 每个装饰对象和如何使用这个对象分离，每个装饰对象只关心自己的功能，不需要关心如何添加到对象链当中。 装饰模式，把每个要装饰到功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需求有选择地、按顺序地使用装饰功能包装对象了。 如果只有一个 ConcreteComponent 类而没有抽象的 Component 类，那么 Decorator 类可以是 ConcreteComponent 的一个子类。同样道理，如果只有一个 ConcreteDecorator 类，那么没必要建立一个单独 Decorator 类，可以把 Decorator 和 ConcreteDecorator 的责任合并为一个类。 装饰模式的优点: 把类中的装饰功能从类中搬移去除，这样可以简化原有的类。 把核心职责和装饰功能分开来，而且可以去除相关类中重复的装饰逻辑。 装饰模式的装饰顺序很重要。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:7:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"代理模式 代理模式(Proxy)，为其他对象提供一种代理以控制对这个对象的访问。 代理模式结构\r代理模式应用 远程代理 为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。如 webservice 虚拟代理 根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。如 HTML 安全代理 用来控制真实对象访问时的权限。 智能指引 当调用真实对象时，代理处理另外一些事。 代理模式就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:8:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"工厂方法模式 简单工厂 VS 工厂方法模式 简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关类，对于客户端来说，去除类与具体产品的依赖。 工厂方法模式: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式结构\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:9:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"原型模式 原型模式(Prototype),用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 c++11新特性，协变返回类型 原型模式结构\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:10:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"模板方法模式 当我们要完成在某一细节层次一致一个过程或一系列步骤，但其个别步骤在更详细的层次上实现可能不同时，我们通常考虑使用模板方法模式处理。 模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法结构即可重新定义该算法到某些特定步骤。 模板方法模式\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:11:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"迪米特法则(LoD) 迪米特法则(LoD): 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类某一个方法的话，可以通过第三者转发这个调用。 在类的结构设计中，每一个类都应当尽量降低成员的访问权限。 迪米特法则的根本思想，是强调类之间的松耦合。 类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的造成波及。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:12:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"外观模式(Facade) 外观模式(Facade): 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式结构\r在设计初期阶段，应该要有意识的将不同的两个层分离，层与层之间建立外观 Facade。 在开发阶段，子系统往往经过不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少它们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，为新系统开发一个外观 Facade 类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与 Facade 对象交互，Facade 与遗留代码交互所有复杂的工作。 外观模式体现了依赖倒置原则和迪米特法则。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:13:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"建造者模式(Builder) 建造者模式(Builder): 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式结构\r建造者模式用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂变化。 建造者模式，使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若要改变一个产品的内部表示，只需要再定义一个建造者即可。 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:14:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"观察者模式(Observer) 观察者模式(Observer) 又叫 发布-订阅(Publish/Subscribe)模式。 观察者模式(Observer)：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象(抽象通知者)在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式结构\r动机： 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要要维护相关对象的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用带来不便。 应用场景： 当一个对象改变需要同时改变其他对象，而它不知道具体有多少对象有待改变，应该使用观察者模式。 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的中使它们各自独立的改变和复用。 观察者模式所做的工作其实就是在解除耦合。让耦合双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 事件委托实现 事件委托产生的动机： 现实中，“抽象通知者\"由于不希望依赖\"抽象观察者”，所以\"增加\"和\"减少\"的方法就没必要了(即抽象观察者已经不存在了)。 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的\"类\"，委托的实例代表一个具体的函数。 一个委托可以搭载多个方法，所有方法被依次唤起。它可以使委托对象所搭载的方法并不需要属于同一个类。 委托对象所搭载的所有方法必须具有相同的原形和形式，也就是具有相同的参数列表和放回值类型。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:15:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"抽象工厂方法(Abstract Factory) 抽象工厂方法(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂方法结构\r抽象工厂的优缺点 优点： 易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实现过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。 缺点： 如果需求来自增加功能，则需要改变的类较多。 简单工厂改进抽象工厂 用反射加抽象工厂 编程方式：依赖注入(Dependency Injection) 反射技术使用格式：Assembly.Load(“程序集名称”).CreateInstance(“命名空间.类型名称”) 所有用简单工厂的地方，都可以考虑用反射技术来去除 switch 或 if，解除分支判断带来的耦合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:16:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"状态模式(State) 状态模式(State)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像似改变了其类。 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 状态模式结构\r状态模式好处： 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。 将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在某个 ConcreteState 中，所以通过定义新的子类可以很容易的增加新的状态和转换。 消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到 State 的子类中,来减少相互间的依赖。 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:17:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"适配器模式(Adapter) 适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 当系统的数据和行为都正确，但接口不符合，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。 适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 适配器模式分为：类适配器模式和对象适配器模式。 类适配器：通过多重继承对一个接口与另一个接口进行匹配。(C#、Java、VB.Net不支持多重继承,即它们要求一个类只有一个父类) 对象适配器结构\r使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不同时，应该考虑用适配器模式。 两个类所做的事情相同或相似，但是具有不同的接口时要使用它。 客户代码可以统一调用同一接口，可以更简单、更直接、更紧凑。 在双方都不太容易修改的时候，再使用适配器模式适配。而不是一有不同就使用它。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:18:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"备忘录模式(Memento) 备忘录模式(Memento)：在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。 备忘录模式结构\rMemento 模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，需要保存的属性只是众多属性中的一小部分时，Originator 可以根据保存的 Memento 信息还原到前一状态。 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以复杂的对象内部信息对其他的对象屏蔽起来。 当角色的状态改变的时候，有可能这个状态无效，这个时候就可以时候暂时保存起来的备忘录将状态复原。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:19:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"组合模式(Composite) 组合模式(Composite)：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式结构\r透明方式与安全方式 透明方式：在 Component 中声明所有用来管理子对象的方法，其中包括 Remove,Add 等。这样实现的 Component 接口的所有子类都具备了 Add 和 Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。缺点，Leaf 类本身不具备 Add 和 Remove 方法的功能，实现它没有意义。 安全方式：在 Component 中不去声明 Remove,Add 方法，那么子类 Leaf 也就不需要去实现它，而是在 Composite 声明所有用来管理子类对象的方法，由于不够透明，所以树叶和树枝类将不具备相同的接口，客户端调用需要做相应的判断，带来不便。 需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式。 组合模式包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象。 用户不需要关心到底是处理一个叶节点还是一个组合组件，也就用不着为定义组合而写一些选择判断语句了。 组合模式让客户可以一致地使用组合结构和单个对象。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:20:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"迭代器模式(Iterator) 迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中每个元素，而又不暴露该对象的内部表示。 当你访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式。 你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。 迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。(c# Java等已经将该模式集成在语言内部了，foreach 算法) 迭代器模式结构\r迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合内部结构，又可让外部代码透明的访问集合内部的数据。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:21:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"单例模式(Singleton) 单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认构造方法就会消失。 通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。 单例模式结构\r单例模式因为 Singleton 封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。 多线程时的单例模式，通常会加进程锁 lock，lock 是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待，直到对象被释放。 静态初始化的方式在自己被加载时就将自己实例化，称之为饿汉式单例类。不存在多线程安全问题。 要在第一次被引用时，才会将自己实例化，称之为懒汉式单例类。存在多线程安全问题。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:22:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"合成/聚合复用原则 对象的继承关系是在编译时就定义好的了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。 合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。 聚合 : 表示一种弱的”拥有“关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分。 合成 : 是一种强的\"拥有\"关系，体现了严格的部分与整体关系，部分和整体的生命周期一样。 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控的庞然大物。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:23:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"桥接模式(Bridge) 桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 抽象与它的实现分离，不是让抽象类与其派生类分离，因为这没有意思。实现指的是抽象类和它的派生类用来实现自己的对象。 桥接模式结构\r实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:24:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"命令模式(Command) 命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式结构\rinvoke:调用 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记录日志 允许接收请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他类，因此增加新的具体命令类很容易 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开 敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要急于去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:25:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"职责链模式(Chain of Responsibility) 职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 职责链模式结构\r职责链的好处 当客户提交一个请求时，请求是沿链传递直至有一个 ConcreteHandler 对象负责处理它。 接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接收者的引用。 随时地增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。 一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:26:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"中介者模式(Mediator) 尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性。 大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。 中介者模式(Mediator)：用一个中介对象来封装一系列的对象交互。中介者使对象不需要显式地相互引用，从而使其耦度松散，而且可以独立地改变它们之间的交互。中介者模式又叫调停者模式。 中介者模式结构\r中介者模式的优缺点 优点 中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了\"多对多\"交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。 Mediator 的出现减少了各个 Colleague 的耦合，使得可以独立地改变和复用各个 Colleague 类和 Mediator，由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。 缺点 由于 ConcreteMediator 控制了集中化，于是就把交互复杂性变为了中介者复杂性，这就使得中介者会变得比任何一个 ConcreteColleague 都复杂。 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:27:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"享元模式(Flyweight) 享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。 享元模式结构\r内部状态和外部状态 内部状态：不会外部环境改变的共享部分 外部状态：随环境改变，不可以共享的状态。可以作为参数传入享元模式，达到内外状态协调。 享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够受大幅度地减少需要实例化类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。 如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:28:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"解释器模式(Interpreter) 解释器模式(Interpreter)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 如果一个特定类型的问题的发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决问题。 解释器模式结构\r当一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。 解释器模式很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易容易实现文法，因为定义抽象语法树各个节点的类的实现大体相似，这些类都易于直接编写。 解释器模式的不足，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。 AST是抽象语法树（Abstract Syntax Tree）的缩写 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:29:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"访问者模式(Visitor) 双分派，意味着得到执行的操作取决于请求的种类和两个接收者的类型。 访问者模式(Visitor)：表示一个作用于某对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式结构\r访问者模式适合数据结构相对稳定的系统。它把数据结构和作用于数据结构的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。 访问者模式的目的是要把处理从数据结构中分离出来。有比较稳定的数据结构，又有易于变化的算法，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。 访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式的缺点其实就是使增加新的数据结构变得困难了。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:30:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"总结 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"创建型模式 抽象工厂模式 建造者模式 工厂方法模式 原型模式 单例模式 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。 原型模式 建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些。 建造者模式 将一个复杂对象的构建与它的表示分离，用同样的构建过程创建不同的产品给客户。 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。 耦合性描述的是一个例程与其他例程之间联系的紧密度。 软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合。 单例模式 对一些类来说，一个实例很重要。 让类自身负责保存它的唯一实例。 这个类可以保证没有其他实例可以被创建，并且还提供了一个访问该实例的方法。 对唯一的实例可以严格地控制客户怎样以及何时访问它。 工厂方法模式 通常设计应该是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。 创建型模式存在的意义： 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统如何使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的\"产品\"对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，即运行时再指定。 从 new 角度讲工厂方法是最好的设计，它把工厂职责都分了类，其他的创建型模式都是它的变体。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:1","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"结构型模式 适配器模式 桥接模式 解耦方式，用聚合代替继承 组合模式 装饰模式 外观模式 享元模式 代理模式 适配器模式 想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复合的类，该类可以与其他不相关的类或不可预见的类协同工作。 让这些接口不同的类通过适配器后，协同工作。 桥接模式 解耦两个或者多个不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改变为了组合关系，从而使这两者可以应对各自独立的变化。 找出变化并封装之。 装饰模式 以动态、透明的方式给单个对象添加职责。 组合模式 客户可以一致地使用组合结构和单个对象。 任何用到基本对象的地方都可以使用组合对象。 外观模式 应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体的办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障。 享元模式 对象使得内存占用过多，而如果都是大量重复的对象，那就是资源的极大浪费。 代理模式 代理和外观的主要区别在于，代理对象代表一个单一的对象而外观对象代表一个子系统，代理的客户对象无法直接访问目标对象，由于代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。 代理一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。 适配器模式 主要为解决两个已有接口之间不匹配的问题，不需要考虑这些接口是怎么实现的，不考虑它们各自可能如何演化。 适配器这种方式不需要对两个独立设计的类中任何一个进行重新设计，就能够使它们协同工作。 外观模式较好。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:2","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"行为型模式 观察者模式 模板方法模式 命令模式 状态模式 职责链模式 解释器模式 中介者模式 访问者模式 策略模式 备忘录模式 迭代器模式 模板方法 代码重复是编程中最常见、最糟糕的\"坏味道\"，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合而为一，程序会变得更好。完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中。 模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法。 命令模式 将调用操作的对象与知道如何实现操作的对象解耦，在不同的时刻指定、排列和执行请求。 支持取消/重做的操作，并可记录整个操作日志，支持事物。 职责链模式 有多个对象可以处理一个请求，哪个对象处理请求事先并不知道，要在运行时刻自动确定，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这个请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 状态模式 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类就可以很容易的增加新的状态和转换。 解释器模式 如果一个特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题。 中介者模式 面向对设计鼓励将行为分布到各个对象中，这种分布肯能会导致对象之间有许多连接。也就是说，有可能一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难。将集体行为封装一个单独的中介者对象可以避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组内的对象不再相互显式引用。这些对象仅知道中介者，从而减少了相互连接的数目。 访问者模式 访问者增加具体的 Element 是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需要增加一个新的访问者即可在一个对象结构上定义一个新的操作。 策略模式 继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类 A 的子类 B、C、D，从而给它们以不同的行为。但这样会将行为硬行编制到父类 A 当中，而将算法的实现与类 A 的实现混合起来，从而使得类 A 难以理解、难以维护、难以扩展，而且还不能动态地改变算法。仔细分析发现，它们之间唯一的差别是它们所使用的算法或行为，将算法封装在独立的策略类中使得你可以独立于其类 A 改变它，使它易于切换、易于理解、易于扩展。 备忘录模式 使用备忘录可以避免暴露一些只应由对象 A 管理却又必须存储在对象 A 之外的信息。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界。 迭代器模式 迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。 只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果遵循开放-封闭原则、依赖倒置原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪个特定的对象。此时就需要\"对象管理者\"工厂来负责此事。 在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。 工厂方法的实现并不能减少工作量，但是它能够在处理新情况时，避免使已经很复杂的代码更加复杂。 面向对象设计模式体现的就是抽象的思想，类是对对象的抽象，抽象类是类的抽象，接口是对行为的抽象。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:3","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Linux"],"content":"Linux命令行与shell脚本编程大全.第3版 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:0:0","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"第一部分 Linux 命令行 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:0","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"linux介绍 Linux可划分为以下四部分： Linux内核 GNU工具 图形化桌面环境 应用软件 内核主要负责以下四种功能： 系统内存管理 软件程序管理 硬件设备管理 文件系统管理 内存管理： 内核可以使用物理内存，也可以创建和管理虚拟内存。 内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间(swap space)。 内存存储单元按组划分成很多块，这些块称作页面(page)。内核将每个内存页面放在物理内存或交换空间。 内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制到交换空间区域(称为换出，swapping out)——即使还有可用内存。 当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面给它让出空间，然后从交换空间换入请求的内存页面。 只要Linux系统在运行，为运行中的程序换出内存页面的过程就不会停歇。 软件管理： Linux操作系统将运行中的程序称为进程。配置防火墙 进程可以在前台运行，将输出显示在屏幕上，也可以在后台运行，隐藏到幕后。内核控制着Linux系统如何管理运行在系统上的所有进程。 内核创建了第一个进程(称为init进程)来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。 管理自启动进程(即启动或停止脚本)的表位于/etc/init.d中。(Ubuntu)。这些脚本通过/etc/rcX.d目录下的入口(entry)启动， 这里的X代表运行级(run level)。 Linux操作系统的init系统采用了运行级。运行级决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定类型的进程。Linux操作系统有5个启动运行级。 运行级为1时，只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。 标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。 另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统，允许用户通过图形化桌面窗口登录系统。 硬件设备管理： 内核的另一职责是管理硬件设备。任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。 在Linux内核中有两种方法用于插入设备驱动代码： 编译进内核的设备驱动代码 可插入内核的设备驱动模块 开发人员提出了内核模块的概念。它允许将驱动代码插入到运行中的内核而无需重新编译内核。同时，当设备不再使用时也可将内核模块从内核中移走。这种方式极大地简化和扩展了硬件设备在Linux上的使用。 Linux系统将硬件设备当成特殊的文件，称为设备文件。 设备文件有3种分类： 字符型设备文件 块设备文件 网络设备文件 字符型设备文件是指处理数据时每次只能处理一个字符的设备。如大多数的调制解调器和终端。 块设备文件是指处理数据时每次能处理大块数据的设备。如硬盘。 网络设备文件是指采用数据包发送和接收数据的设备。，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。 Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。 文件系统管理 Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统(多达20多种)外，Linux还支持从其他操作系统(比如Microsoft Windows)采用的文件系统中读写数据。 Linux服务器所访问的所有硬盘都必须格式化成上述20种文件系统类型中的一种。 Linux内核采用虚拟文件系统(Virtual File System，VFS)作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用时，VFS将信息都缓存在内存中。 GNU 工具 除了由内核控制硬件设备外，操作系统还需要工具来执行一些标准功能，比如控制文件和 程序。 通常将Linux内核和GNU工具的结合体称为Linux。 GNU coreutils软件包由三部分构成： 用以处理文件的工具 用以操作文本的工具 用以管理进程的工具 GNU/Linux shell是一种特殊的交互式工具。 它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。 shell包含了一组内部命令，用这些命令可以完成诸如复制文件、移动文件、重命名文件、显示和终止系统中正运行的程序等操作。shell也允许你在命令行提示符中输入程序的名称，它会将程序名传递给内核以启动它。 你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。 GNOME(the GNU Network Object Model Environment，GNU网络对象模型环境)。 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:1","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"shell介绍 在图形化桌面出现之前，与Unix系统进行交互的唯一方式就是借助由shell所提供的文本命令行界面(command line interface，CLI)。CLI只能接受文本输入，也只能显示出文本和基本的图形输出。 GNOME 終端快捷键： F11 全屏 CTRL+SHIFT+N 启动一个新的shell会话 CTRL+SHIFT+T 在现在的窗口启动一个新的shell会话 CTRL+SHIFT+W 关闭当前的shell会话中的活动标签 CTRL+SHIFT+Q 关闭当前shell会话 CTRL+SHIFT+V 粘贴到shell会话 CTRL+SHIFT+C 复制选择内容到shell会话剪切板 CTRL+SHIFT+F 搜索文本 CTRL+SHIFT+H 从当前位置向前搜索文本 CTRL+SHIFT+G 从当前位置向后搜索文本 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:2","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"基本bash shell命令 本节介绍处理文件和目录相关的命令。 /etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息。 默认bash shell提示符是美元符号($)。 man命令用来访问存储在Linux系统上的手册页面。 要查找与终端相关的命令，可以输入man -k terminal。 除了对节按照惯例进行命名，手册页还有对应的内容区域。每个内容区域都分配了一个数字， 从1开始，一直到9。 区域号 所涵盖的内容 1 可执行程序或shell命令 2 系统调用 3 库调用 4 特殊文件 5 文件格式与约定 6 游戏 7 概述、约定及杂项 8 超级用户和系统管理员命令 9 内核例程 info 命令也可查看命令说明。 -help或--help也可查看命令说明。 常见Linux目录名称： 目录 用途 / 虚拟目录的根目录，通常不会在这里存储文件 /bin 二进制目录，存放许多用户的GNU工具 /boot 启动目录，存放启动文件 /dev 设备目录，Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录，Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户主目录 /sbin 系统二进制目录，存放许多管理员级GNU工具 /run 运行目录，存放系统运行时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用于存放经常变化的文件，比如日志文件 cd destination切换目录命令 cd命令可接受单个参数destination，用以指定想切换到的目录名。如果没有为cd命令指 定目标路径，它将切换到用户主目录。 destination参数可以用两种方式表示：一种是使用绝对文件路径(以\"/“起始的路径)，另一种是使用相对文件 路径。 pwd命令可以显示出shell会话的当前目录，这个目录被称为当前工作目录。 有两个特殊字符可用于相对文件路径中： 单点符(.)，表示当前目录; 双点符(..)，表示当前目录的父目录。 ls命令最基本的形式会显示当前目录下的文件和目录。 ls -F-F参数在目录名后加了正斜线(/)，在可执行文件后加(*)号。 11 ls -R 参数是ls命令可用的另一个参数，叫作递归选项。 ls -r逆序。 创建文件touch filename。 touch filename命令还可用来改变文件的修改时间。这个操作并不需要改变文件的内容。 改变访问时间，可用-a参数。 复制文件 cp source destination 当source和destination参数都是文件名时， cp命令将源文件复制成一个新文件，并且以destination命名。 链接文件 链接是目录中指向文件真实位置的占位符。 在Linux中有两种不同类型的文件链接： 符号链接 硬链接 符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。 创建符号链接命令ln -s soure destination。 硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件要创建硬链接，原始文件也必须事先存在ln source destination。 只能对处于同一存储媒体的文件创建硬链接。要想在不同存储媒体的文件之间创建链接，只能使用符号链接。 重命名文件 mv oldname newname修改文件名称。 mv source destination也可以使用mv来移动文件的位置。 mv source/oldfilename destination/newfilename也可以使用mv命令移动文件位置并修改文件名称。 删除文件 rm -f 强制删除文件。 rm -rf可用来强制删除目录。 创建目录 mkdir创建目录。 同时创建多个目录和子目录，需要加入-p参数mkidr -p d1/d2/d3。 删除目录的基本命令是rmdir。默认情况下，只删除空目录。 查看文件类型 flie filename查看文件属性。 查看整个文件 cat filename查看文件内容。 cat -n 给所有行加入行号。 cat -b 只给有文本的行加上行号，空白行不加行号。 cat -T 制表位显示为^T。 more命令 more命令会显示文本文件的内容，但会在显示每页数据之后停下来。more命令是分页工具。 less命令 less filename。less命令为more命令的升级版。 查看部分文件 tail命令会显示文件最后几行的内容(文件的“尾部”)。 tail filename默认显示文件尾部10行内容。 tail -n 2 filename或者tail -2 filename指定显示末尾2行内容。 tail -f 允许在其他进程使用该文件时查看文件的内容。 tail 命令会保持活动状态，并不断显示添加到文件中的内容。 head命令 类似tail用法。不支持-f参数，因为通常文件开头不会改变。 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:3","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"更多bash shell命令 本章介绍系统管理命令。 监测进程(某个特定时间点) 查看进程命令ps。 默认情况下， ps命令只会显示运行在当前控制台下的属于当前用户的进程。 Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数： Unix风格的参数，前面加单破折线; BSD风格的参数，前面不加破折线; GNU风格的长参数，前面加双破折线。 Unix风格参数： ps -aux/aux查看所有进程。 ps -ef以完整格式(-f)显示所有(-e)运行的进程 名称 描述 UID 启动这些进程的用户 PID 进程的进程ID PPID 父进程的进程号(如果该进程是由另一个进程启动的) C 进程生命周期中的CPU利用率 STIME 进程启动时的系统时间 TTY 进程启动时的终端设备 TIME 运行进程需要的累计CPU时间 CMD 启动的程序名称 ps -l后面会增加如下几项： 名称 描述 F 内核分配给进程的系统标记 S 进程的状态(O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止) PRI 进程的优先级(越大的数字代表越低的优先级) NI 谦让度值用来参与决定优先级 ADDR 进程的内存地址 SZ 假如进程被换出，所需交换空间的大致大小 WCHAN 进程休眠的内核函数的地址 BSD风格参数： ps l命令大部分输出与Unix风格类似。不同部分如下： 名称 解释 VSZ 进程在内存中的大小，以千字节(KB)为单位 RSS 进程在未换出时占用的物理内存 STAT 代表当前进程状态的双字符状态码 第一个字符采用了和Unix风格S列相同的值，表明进程是在休眠、运行还是等待。第二个参数进一步说明进程的状态，如Ssl+ \u003c：该进程运行在高优先级上。 N：该进程运行在低优先级上。 L：该进程有页面锁定在内存中。 s：该进程是控制进程。 l：该进程是多线程的。 +：该进程运行在前台。 GNU长参数： 如--help。 ps --forest会显示进程的层级信息，并以ASCLL字符绘画成可爱的图表。 这种格式让跟踪子进程和父进程变得十分容易。 实时监测进程 top命令。 top -u username监测特定用户进程。 top -p 11345监测特定进程号进程。 top命令输出，第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。 top命令的输出中将进程叫作任务(task)：有多少进程处在 运行(running)、休眠(sleeping)、停止(stopped)或是僵化状态(zombie，僵化状态是指进程完成了，但父进程没有响应) 。 最后显示运行进程列表参数解释如下： 名称 描述 PID 进程的ID USER 进程属主名字 PR 进程的优先级 NI 进程的谦让度值 VIRT 进程占用的虚拟内存总量 RES 进程占用的物理内存总量 SHR 进程和其他进程共享的内存总量 S 进程状态(D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态) %CPU 进程使用的CPU时间比例 %MEM 进程使用的内存占可用内存的比例 TME+ 自进程启动到目前为止的CPU时间总量 COMMAND 进程所对应的命令行名称，也就是启动的程序名 结束进程 在Linux中，进程之间通过信号来通信。 进程如何处理信号是由开发人员通过编程来决定的。 kill命令 kill命令可通过进程ID(PID)给进程发信号。默认情况下， kill命令会向命令行中列出的全部PID发送一个TERM信号。kill命令只能用进程的PID而不能用命令名。 linux进程信号： 信号 名称 描述 1 HUP 挂起 2 INT 中断 3 QUIT 结束运行 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行，但不终止 18 TSTP 停止或暂停，但继续在后台运行 19 CONT 在STOP和TSTP之后恢复执行 如果要强制终止，-s参数支持指定其他信号(用信号名或信号值)，如： kill -s HUP 3490 killall命令 killall命令非常强大，它支持通过进程名而不是PID来结束进程。killall命令也支持通配符，这在系统因负载过大而变得很慢时很有用。 监测磁盘空间 mount命令。 mount命令提供如下四部分信息： 媒体的设备文件名 媒体挂载到虚拟目录的挂载点 文件系统类型 已挂载媒体的访问状态 要手动在虚拟目录中挂载设备，需要以root用户身份登录，或是以root用户身份运行sudo命令。下面是手动挂载媒体设备的基本命令： mount -t type device directory type参数指定了磁盘被格式化的文件系统类型。和Windows PC共用这些存储设备。 通常得使用下列文件系统类型： vfat：Windows长文件系统。 ntfs：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。 iso9660：标准CD-ROM文件系统。 -o参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。 以下为常用的选项： ro：以只读形式挂载。 rw：以读写形式挂载。 user：允许普通用户挂载文件系统。 check=none：挂载文件系统时不进行完整性校验。 loop：挂载一个文件。 umount命令，卸载。 umount [directory | device ] df命令，查看挂载磁盘使用情况。 df -h用户易读形式显示。 df命令输出显示的时Linux系统认为的当前值。有可能系统上有运行的进程已经创建或删除了某个文件，但尚未释放文件。 这个值是不会算进闲置空间的。 du命令 du命令可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况(查看内容包含所有文件及子目录)。主要用来查看该目录下是否有超大文件。 常用可选参数： -c:显示所有已列出文件总的大小。 -h:按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。 -\u003e -s:显示每个输出参数的总计。 处理大数据文件命令 排序数据 sort命令会按照默认语言的排序规则对文本文件数据进行排序。 默认情况下，sort命令会把数字当作字符来执行标准的字符排序。解决该问题，则需执行sort -n filename，按值排序。 sort -M用三字符月份名按月份排序。 sort -r逆序。 单破折号 双破折号 描述 -b –ignore-leading-blanks 排序时忽略起始的空白 -C –check=quiet 不排序，如果数据无序也不要报告 -c –check 不排序，但检查输入数据是不是已排序;未排序的话，报告 -d –dictionary-order 仅考虑空白和字母，不考虑特殊字符 -f –ignore-case 默认情况下，会将大写字母排在前面;这个参数会忽略大小写 -g –general-number-sort 按通用数值来排序(跟-n不同，把值当浮点数来排序，支持科学计数法表示的值) -i –ignore-nonprinting 在排序时忽略不可打印字符 -k –key=POS1[，POS2] 排序从POS1位置开始;如果指定了POS2的话，到POS2位置结束 -M –month-sort 用三字符月份名按月份排序 -m –merge 将两个已排序数据文件合并 -n –numeric-sort 按字符串数值来排序(并不转换为浮点数) -o –output=file 将排序结果写出到指定的文件中 -R –random-sort 按随机生成的散列表的键值排序 –random-source=FILE 指定-R 参数用到的随机字节的源文件 -r –reverse 反序排序(升序变成降序) -S –buffer-size=SIZE 指定使用的内存大小 -s –stable 禁用最后重排序比较 -T –temporary-directory=DIR 指定一个位置来存储临时工作文件 -t –field-separator=SEP 指定一个用来区分键位置的字符 -u –unique 和-c 参数一起使用时，检查严格排序;不和-c参数一起用时，仅输出第一例相似的两行 -z –zero-terminated 用NULL字符作为行尾，而不是用换行符 -k和-t参数在对按字段分隔的数据进行排序时非常有用，例如/etc/passwd文件。可以用-t参数来指定字段分隔符，然后用-k参数来指定排序的字段。 $ sort -t ':' -k 3 -n /etc/passwd $ du -sh * | sort -nr 搜索数据 grep命令 命令格式grep [options] pattern [file] grep -v t file1反向搜索包含 t 字符的文本。 grep -n 显示所在行行号。 grep -c只显示统计出现的总行数。 grep -e t -e f file1指定多个匹配模式。 精确搜索则匹配模式使用正则表达式。 fgrep则是另外一个版本，支持将匹配模式指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后在fgrep命令中用其在一个大型文件中搜索字符串了。 压缩数据 工具 文件扩展名 描述 bzip2 .bz2 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 compress .Z 最初的Unix文件压缩工具,已经快没人用了 gzip .gz","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:4","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"理解shell CLI，Command-line interface，命令行界面 ps --forest查看shell进程层级关系 exit退出子shell，在父shell中还可以登出当前的虚拟控制台终端或终端仿真器软件。 运行shell脚本也能够创建出子shell。 进程列表 $ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)”()“和命令构成一个进程列表，生成了一个子shell来执行对应的命令。 进程列表是一种命令分组(command grouping)。另一种命令分组是将命令放入花括号中,并在命令列表尾部加上分号”;\"。语法为{ command; }。使用花括号进行命令分组并不会像进程列表那样创建出子shell。 echo $BASH_SUBSHELL返回0则表示无子shell，返回1或者更大的数则表明存在子shell。 子shell并非真正的多进程处理，因为终端控制着子shell的I/O。 子shell用法 后台模式 要想将命令置入后台模式，可以在命令末尾加上字符 \u0026 。 jobs命令可以显示出当前运行在后台模式中的所有用户的进程(作业) 。 jobs -l查看后台进程，能显示命令PID。 协程 协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。 coproc sleep 2 ##命令输入 coproc COPROC sleep 2\u0026 ##结果显示 COPROC是coproc命令给进程起的名字。你可以使用命令的扩展语法自己设置这个名字。 corproc my_jobs { sleep 2; } ##命令输入 coproc My_Job { sleep 10; }\u0026 ##结果显示 只有在拥有多个协程的时候才需要对协程进行命名，因为你得和它们进行通信。 将协程与进程列表结合起来产生嵌套的子shell。只需要输入进程列表,然后把命令coproc放在前面就行了。 coproc ( sleep 2; sleep 10; ) 生成子shell的成本不低，而且速度还慢。创建嵌套子shell更是火上浇油! 内建命令 外部命令 外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。 外部命令程序通常位于 /bin、/usr/bin、/sbin或/usr/sbin中。 which ps /bin/ps type -a ps ps is /bin/ps #每次执行ps都会生成一个新的子进程查看当前系统进程，然后自动退出。 ls -l /bin/ps -rwxr-xr-x 1 root root 137688 10月 31 2023 /bin/ps 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生(forking)。 内建命令 内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。 cd和exit命令都内建于bash shell。可以利用type命令来了解某个命令是否是内建的。 $ type cd cd is a shell builtin $ type ps ps is hashed (/bin/ps) 有些命令有多种实现。例如echo和pwd既有内建命令也有外部命令。 $ type echo #仅显示内建命令 echo is a shell builtin $ type -a echo #显示内建命令和外部命令 echo is a shell builtin echo is /bin/echo $ which echo #仅显示外部命令 /bin/echo history查看历史记录也是shell内建命令。 不带选项的history通常会显示最近的1000命令。通过修改环境变量HESTSIZE的值来修改保存的历史命令数量。 !!唤出刚刚使用的命令。 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。 history -a可将历史命令强制写入.bash_history文件中而不需等到退出shell。 !20可将历史记录编号为20的命令取出。 alias命名别名也是shell内建命令。 命令别名允许你为常用的命令(及其参数)创建另一个名称，从而将输入量减少到最低。 alias -p要查看当前可用的别名。 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:5","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"使用linux环境变量 环境变量 bash shell用一个叫作环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息(这也是它们被称作环境变量的原因)。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。 环境变量分类： 全局变量 局部变量 全局环境变量 全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。 系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。 env/printenv查看全局变量命令。 printenv HOME显示个别环境变量的值。也可以echo $HOME。 局部环境变量 局部环境变量只能在定义它们的进程中可见。 Linux系统也默认定义了标准的局部环境变量。 在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量。 set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。 env和 printenv命令则不会排序，也不会输出局部变量和用户定义变量。 设置用户定义变量 $ echo $myself #创建用户变量 $ myself=hello #给变量赋值，所赋值含空格等特殊符号意义符号时需用引号。 $ echo $myself #显示变量值 hello 变量名、等号和值之间没有空格。 在子shell中无法使用用户定义变量。退出子进程后用户变量仍存在。 设置全局变量 创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。 my_value=\"hello world\" export my_value 子shell甚至无法使用export命令改变父shell中全局环境变量的值。 删除环境变量 echo $my_value #创建变量 unset my_value #删除变量，不加$ 和修改变量一样，在子shell中删除全局变量后，你无法将效果反映到父shell中。 所以要删除变量，应该在创建变量的shell进程中执行。 默认的shell环境变量 bash shell支持的Bourne变量。 变量 描述 CDPATH 冒号分隔的目录列表,作为cd 命令的搜索路径 HOME 当前用户的主目录 IFS shell用来将文本字符串分割成字段的一系列字符 MAIL 当前用户收件箱的文件名(bash shell会检查这个文件,看看有没有新邮件) MAILPATH 冒号分隔的当前用户收件箱的文件名列表(bash shell会检查列表中的每个文件,看看有没有新邮件) OPTARG getopts命令处理的最后一个选项参数值 OPTIND getopts命令处理的最后一个选项参数的索引号 PATH shell查找命令的目录列表,由冒号分隔 PS1 shell命令行界面的主提示符 PS2 shell命令行界面的次提示符 除了默认的Bourne的环境变量,bash shell还提供一些自有的变量。 变量 描述 BASH 当前shell实例的全路径名 BASH_ALIASES 含有当前已设置别名的关联数组 BASH_ARGC 含有传入子函数或shell脚本的参数总数的数组变量 BASH_ARCV 含有传入子函数或shell脚本的参数的数组变量 BASH_CMDS 关联数组,包含shell执行过的命令的所在位置 BASH_COMMAND shell正在执行的命令或马上就执行的命令 BASH_ENV 设置了的话,每个bash脚本会在运行前先尝试运行该变量定义的启动文件 BASH_EXECUTION_STRING 使用bash -c 选项传递过来的命令 BASH_LINENO 含有当前执行的shell函数的源代码行号的数组变量 BASH_REMATCH 只读数组,在使用正则表达式的比较运算符=~进行肯定匹配(positive match)时,包含了匹配到的模式和子模式 BASH_SOURCE 含有当前正在执行的shell函数所在源文件名的数组变量 BASH_SUBSHELL 当前子shell环境的嵌套级别(初始值是0) BASH_VERSINFO 含有当前运行的bash shell的主版本号和次版本号的数组变量 BASH_VERSION 当前运行的bash shell的版本号 BASH_XTRACEFD 若设置成了有效的文件描述符(0、 1、2),则 ‘set -x’调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 BASHOPTS 当前启用的bash shell选项的列表 BASHPID 当前bash进程的PID COLUMNS 当前bash shell实例所用终端的宽度 COMP_CWORD COMP_WORDS 变量的索引值,后者含有当前光标的位置 COMP_LINE 当前命令行 COMP_POINT 当前光标位置相对于当前命令起始的索引 COMP_KEY 用来调用shell函数补全功能的最后一个键 COMP_TYPE 一个整数值,表示所尝试的补全类型,用以完成shell函数补全 COMP_WORDBREAKS Readline库中用于单词补全的词分隔字符 COMP_WORDS 含有当前命令行所有单词的数组变量 COMPREPLY 含有由shell函数生成的可能填充代码的数组变量 COPROC 占用未命名的协进程的I/O文件描述符的数组变量 DIRSTACK 含有目录栈当前内容的数组变量 EMACS 设置为’t’ 时,表明emacs shell缓冲区正在工作,而行编辑功能被禁止 ENV 如果设置了该环境变量,在bash shell脚本运行之前会先执行已定义的启动文件(仅用于当bash shell以POSIX模式被调用时) EUID 当前用户的有效用户ID(数字形式) FCEDIT 供fc命令使用的默认编辑器 FIGNORE 在进行文件名补全时可以忽略后缀名列表,由冒号分隔 FUNCNAME 当前执行的shell函数的名称 FUNCNEST 当设置成非零值时,表示所允许的最大函数嵌套级数(一旦超出,当前命令即被终止) GLOBIGNORE 冒号分隔的模式列表,定义了在进行文件名扩展时可以忽略的一组文件名 GROUPS 含有当前用户属组列表的数组变量 histchars 控制历史记录扩展,最多可有3个字符 HISTCMD 当前命令在历史记录中的编号 HISTCONTROL 控制哪些命令留在历史记录列表中 HISTFILE 保存shell历史记录列表的文件名(默认是.bash_history) HISTFILESIZE 最多在历史文件中存多少行 HISTTIMEFORMAT 如果设置了且非空,就用作格式化字符串,以显示bash历史中每条命令的时间戳 HISTIGNORE 由冒号分隔的模式列表,用来决定历史文件中哪些命令会被忽略 HISTSIZE 最多在历史文件中存多少条命令 HOSTFILE shell在补全主机名时读取的文件名称 HOSTNAME 当前主机的名称 HOSTTYPE 当前运行bash shell的机器 IGNOREEOF shell在退出前必须收到连续的 EOF 字符的数量(如果这个值不存在,默认是1) INPUTRC Readline初始化文件名(默认是.inputrc) LANG shell的语言环境类别 LC_ALL 定义了一个语言环境类别,能够覆盖LANG变量 LC_COLLATE 设置对字符串排序时用的排序规则 LC_CTYPE 决定如何解释出现在文件名扩展和模式匹配中的字符 LC_MESSAGES 在解释前面带有$的双引号字符串时,该环境变量决定了所采用的语言环境设置 LC_NUMERIC 决定着格式化数字时采用的语言环境设置 LINENO 当前执行的脚本的行号 LINES 定义了终端上可见的行数 MACHTYPE 用“CPU-公司-系统”(CPU-company-system)格式定义的系统类型 MAPFILE 一个数组变量,当mapfile命令未指定数组变量作为参数时,它存储了mapfile所读入的文本 MAILCHECK shell查看新邮件的频率(以秒为单位,默认值是60) OLDPWD shell之前的工作目录 OPTERR 设置为1时,bash shell会显示getopts命令产生的错误 OSTYPE 定义了shell所在的操作系统 PIPESTATUS 含有前台进程的退出状态列表的数组变量 POSIXLY_CORRECT 设置了的话,bash会以POSIX模式启动 PPID bash shell父进程的PID PROMPT_COMMAND 设置了的话,在命令行主提示符显示之前会执行这条命令 PROMPT_DIRTRIM 用来定义当启用了 \\w或\\W提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换 PS3 select命令的提示符 PS4 如果使用了bash的-x 选项,在命令行之前显示的提示信息 PWD 当前工作目录 RANDOM 返回一个0~32767的随机数(对其的赋值可作为随机数生成器的种子) READLINE_LINE 当使用bind -x 命令时,存储Readline缓冲区的内容 READLINE_POINT 当使用bind -x 命令时,表示Readline缓冲区内容插入点的当前位置 REPLY read命令的默认变量 SECONDS 自从shell启动到现在的秒数(对其赋值将会重置计数器) SH","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:6","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"理解Linux文件权限 Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。 用户权限是通过创建用户时分配的用户ID(User ID，通常缩写为UID)来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。 登录名是用户用来登录系统的最长八字符的字符串(字符可以是数字或字母)，同时会关联一个对应的密码。 /etc/passwd 文件 Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。这个文件就是/etc/passwd文件，它包含了一些与用户有关的信息。 root用户账户是Linux系统的管理员，固定分配给它的UID是0。 Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。 Linux为系统账户预留了500以下的UID值。 /etc/passwd文件中还有很多用户登录名和UID之外的信息。 /etc/passwd文件的字段包含了如下信息: 登录用户名 用户密码 (用x表示) 用户账户的UID(数字形式) 用户账户的组ID(GID)(数字形式) 用户账户的文本描述(称为备注字段) 用户HOME目录的位置 用户的默认shell 绝大多数Linux系统都将用户密码保存在另一个单独的文件中(叫作shadow文件，位置在/etc/shadow)。只有特定的程序(比如登录程序)才能访问这个文件。 /etc/passwd是一个标准的文本文件。你可以用任何文本编辑器在/etc/password文件里直接手动进行用户管理(比如添加、修改或删除用户账户)。 /etc/shadow文件 /etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。 rich:$1$.FfcK0ns$f1UgiyHQ25wrB/hykCn020:11627:0:99999:7::: 在/etc/shadow文件的每条记录中都有9个字段: 与/etc/passwd文件中的登录名字段对应的登录名 加密后的密码 自上次修改密码后过去的天数密码(自1970年1月1日开始计算) 多少天后才能更改密码 多少天后必须更改密码 密码过期前提前多少天提醒用户更改密码 密码过期后多少天禁用用户账户 用户账户被禁用的日期(用自1970年1月1日到当天的天数表示) 预留字段给将来使用 添加新用户 用来向Linux系统添加新用户的主要工具是useradd。 可以使用加入了 -D选项的useradd命令查看所用Linux系统中的这些默认值。 useradd -D GROUP=100 HOME=/home INACTIVE=-1 EXPIRE= SHELL=/bin/sh SKEL=/etc/skel CREATE_MAIL_SPOOL=no 列出的默认值如下: 新用户会被添加到GID为 100的公共组 新用户的HOME目录将会位于/home/loginname 新用户账户密码在过期后不会被禁用 新用户账户未被设置过期日期 新用户账户将bash shell作为默认shell 系统会将/etc/skel目录下的内容复制到用户的HOME目录下 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。 useradd命令不会创建HOME目录，但是-m命令行选项会使其创建HOME目录。 useradd命令行参数，参考useradd --help查看。 删除用户 userdel username系统中删除用户，默认情况下，userdel命令会只删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。 果加上-r参数，userdel会删除用户的HOME目录以及邮件目录。 然而，系统上仍可能存有已删除用户的其他文件。这在有些环境中会造成问题。 修改用户 用户账户修改工具: 命令 描述 usermod 修改用户账户的字段,还可以指定主要组以及附加组的所属关系 passwd 修改已有用户的密码 chpasswd 从文件中读取登录名密码对,并更新密码 chage 修改密码的过期日期 chfn 修改用户账户的备注信息 chsh 修改用户账户的默认登录shell usermod命令 usermod -l #修改用户账户的登录名 usermod -L #锁定账户，是用户无法登录 usermod -p #修改账户的密码 usermod -U #解除锁定,使用户能够登录 #....,其他详见--help passwd和chpasswd命令 passwd username #只能修改自己 passwd -e username #强制用户下次登录时修改密码 sudo passwd username #可修改其他用户密码 chpasswd命令能从标准输入自动读取登录名和密码对(由冒号分割)列表，给密码加密，然后为用户账户设置。 也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。 $ chpasswd \u003c user.txt chsh、chfn和chage命令 chsh、chfn和chage工具专门用来修改特定的账户信息。chsh命令用来快速修改默认的用户登录shell。使用时必须用shell的全路径名作为参数，不能只用shell名。 $ chsh -s /bin/csh test chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。 chage命令用来帮助管理用户账户的有效期。 参数 描述 -d 设置上次修改密码到现在的天数 -E 设置密码过期的日期 -I 设置密码过期到锁定账户的天数 -m 设置修改密码之间最少要多少天 -W 设置密码过期前多久开始出现提醒信息 使用 Linux 组 /etc/group 文件 $cat /etc/group #查看组 root:x:0:root #... /etc/group文件有4个字段: 组名 组密码 GID 属于该组的用户列表 创建新组 $ groupadd groupname 在创建新组时，默认没有用户被分配到该组。groupadd命令没有提供将用户添加到组中的选项，但可以用usermod命令来弥补这一点。 $ usermod -G groupname username 修改组 groupmod命令可以修改已有组的GID(加-g选项)或组名(加-n选项)。 $ groupmod -n newgroupname oldgroupname 理解文件权限 使用文件权限符 -rw-rw-r-- 1 rich rich 50 2010-09-13 07:49 file1.gz 这个字段的第一个字符代表了对象的类型: -代表文件 d代表目录 l代表链接 c代表字符型设备 b代表块设备 n代表网络设备 之后有3组三字符的编码。每一组定义了3种访问权限: r代表对象是可读的 w代表对象是可写的 x代表对象是可执行的 若没有某种权限,在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别: 对象的属主 对象的属组 系统其他用户 默认文件权限 命令umask可以查看和设置默认文件属性 $ umask #显示默认权限 0002 $ umask 0001 #设置默认权限 第一位代表了一项特别的安全特性，叫作粘着位(sticky bit)。 后面的3位表示文件或目录对应的umask八进制值。 八进制模式的安全性设置先获取这3个rwx权限的值，然后将其转换成3位二进制值，用一个八进制值来表示。 Linux文件权限码: 权限 二进制值 八进制值 描述 — 000 0 没有任何权限 –x 001 1 只有执行权限 -w- 010 2 只有写入权限 -wx 011 3 只有写入和执行权限 r– 100 4 只有读取权限 r-x 101 5 只有读取和执行权限 rw- 110 6 只有读取和写入权限 rwx 111 7 有全部权限 umask值只是个掩码。它会屏蔽掉不想授予该安全级别的权限。 要把umask值从对象的全权限值中减掉。对文件来说，全权限的值是666(所有用户都有读和写的权限);而对目录来说，则是777(所有用户都有读、写、执行权限)。 对于文件，对应的umask值为(666-文件权限对应的3位8进制值)，对于目录，对应的umask值为(777-目录对应的3位8进制值)。 改变安全性设置 改变权限 chmod命令用来改变文件和目录的安全性设置，该命令的格式如下: chmod options mode file 与通常用到的3组三字符权限字符不同，chmod命令采用了另一种方法。下面是在符号模式下指定权限的格式。 [ugoa...][[+-=][rwxXstugo...] 第一组字符定义了权限作用的对象: u代表用户 g代表组 o代表其他 a代表上述所有 后面跟着的符号表示你是想在现有权限基础上增加权限(+)，还是在现有权限基础上移除权限(-)，或是将权限设置成后面的值(=)。 第三个符号代表作用到设置上的权限: x:如果对象是目录或者它已有执行权限,赋予执行权限。 s:运行时重新设置UID或GID。 t:保留文件或目录。 u:将权限设置为跟属主一样。 g:将权限设置为跟属组一样。 o:将权限设置为跟其他用户一样。 chmod o+r","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:7","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"管理文件系统 创建分区 fdisk /dev/sdb #进入分区磁盘，交互提示分区设置 fdisk命令提示符下的可用命令: 命令 描述 a 设置活动分区标志 b 编辑BSD Unix系统用的磁盘标签 c 设置DOS兼容标志 d 删除分区 l 显示可用的分区类型 m 显示命令选项 n 添加一个新分区 o 创建DOS分区表 p 显示当前分区表 q 退出,不保存更改 s 为Sun Unix系统创建一个新磁盘标签 t 修改分区的系统ID u 改变使用的存储单位 v 验证分区表 w 将分区表写入磁盘 x 高级功能 常用命令： #用p命令将一个存储设备的详细信息显示出来 Command (m for help): p #以使用n命令在该存储设备上创建新的分区 Command (m for help): n Command action e extended #扩展分区 p primary partition (1-4) #主分区 p Partition number (1-4): 1 First cylinder (1-652, default 1): 1 Last cylinder, +cylinders or +size{K,M,G} (1-652, default 652): +2G #分配大小 #用w命令将更改保存到存储设备上 Command (m for help): w 主分区可以被文件系统直接格式化，而扩展分区则只能容纳其他逻辑分区。 扩展分区出现的原因是每个存储设备上只能有4个分区。可以通过创建多个扩展分区,然后在扩展分区内创建逻辑分区进行扩展。 创建文件系统 创建文件系统的命令行程序列表如下: 工具 用途 mkefs 创建一个ext文件系统 mke2fs 创建一个ext2文件系统 mkfs.ext3 创建一个ext3文件系统 mkfs.ext4 创建一个ext4文件系统 mkreiserfs 创建一个ReiserFS文件系统 jfs_mkfs 创建一个JFS文件系统 mkfs.xfs 创建一个XFS文件系统 mkfs.zfs 创建一个ZFS文件系统 mkfs.btrfs 创建一个Btrfs文件系统 type mkefs #查看工具是否可用 所有的文件系统命令都允许通过不带选项的简单命令来创建一个默认的文件系统。 sudo mkfs.ext4 /dev/sdb1 创建过程中有一步是创建新的日志。 将创建好的文件系统挂载到虚拟目录下的某个挂载点，这样就可以将数据存储在新文件系统中了。 $ ls /mnt $ sudo mkdir /mnt/my_partition $ ls -al /mnt/my_partition/ $ ls -dF /mnt/my_partition /mnt/my_partition/ $ sudo mount -t ext4 /dev/sdb1 #将文件系统挂载 /mnt/my_partition $ ls -al /mnt/my_partition/ 文件系统的检查与修复 fsck命令能够检查和修复大部分类型的Linux文件系统。 #用法格式： fsck options filesystem fsck的命令行选项 选项 描述 -a 如果检测到错误,自动修复文件系统 -A 检查/etc/fstab文件中列出的所有文件系统 -C 给支持进度条功能的文件系统显示一个进度条(只有ext2和ext3) -N 不进行检查,只显示哪些检查会执行 -r 出现错误时提示 -R 使用-A选项时跳过根文件系统 -s 检查多个文件系统时,依次进行检查 -t 指定要检查的文件系统类型 -T 启动时不显示头部信息 -V 在检查时产生详细输出 -y 检测到错误时自动修复文件系统 *只能在未挂载的文件系统上运行fsck命令 以上讲的是关于物理存储设备中的文件系统。 逻辑卷管理 Linux逻辑卷管理器(logical volume manager,LVM)软件包。 逻辑卷管理的核心在于如何处理安装在系统上的硬盘分区。在逻辑卷管理的世界里，硬盘称作物理卷(physical volume,PV)。每个物理卷都会映射到硬盘上特定的物理分区。 多个物理卷集中在一起可以形成一个卷组(volume group,VG)。 使用 Linux LVM 定义物理卷 [...] #。在创建了基本的Linux分区之后,你需要通过t命令改变分区类型。 Command (m for help): t Selected partition 1 #分区类型8e表示这个分区将会被用作Linux LVM系统的一部分 Hex code (type L to list codes): 8e Changed system type of partition 1 to 8e (Linux LVM) Command (m for help): p [...] Command (m for help): w 用分区来创建实际的物理卷，通过pvcreate命令定义用于物理卷的物理分区。它只是简单地将分区标记成Linux LVM系统中的分区而已。 sudo prcreate /dev/sdb1 想查看创建进度，用pvdisplay命令来显示已创建的物理卷列表。 sudo pvdisplay /dev/sdb1 创建卷组 从物理卷中创建一个或多个卷组。 使用vgcreate命令来创建卷组。vgcreate命令需要一些命令行参数来定义卷组名以及你用来创建卷组的物理卷名。 sudo vgcreate Vol1 /dev/sdb1 用vgdisplay命令新创建的卷组的细节。 sudo vgdisplay Vol1 创建逻辑卷 Linux系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。Linux系统会像处理物理分区一样处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上。 要创建逻辑卷,使用lvcreate命令。 lvcreate的选项 选项 长选项名 描述 -c –chunksize 指定快照逻辑卷的单位大小 -C –contiguous 设置或重置连续分配策略 -i –stripes 指定条带数 -I –stripesize 指定每个条带的大小 -l –extents 指定分配给新逻辑卷的逻辑区段数,或者要用的逻辑区段的百分比 -L –size 指定分配给新逻辑卷的硬盘大小 –minor 指定设备的次设备号 -m –mirrors 创建逻辑卷镜像 -M –persistent 让次设备号一直有效 -n –name 指定新逻辑卷的名称 -p –permission 为逻辑卷设置读/写权限 -r –readahead 设置预读扇区数 -R –regionsize 指定将镜像分成多大的区 -s snapshot 创建快照逻辑卷 -Z –zero 将新逻辑卷的前1 KB数据设置为零 常用选项: sudo lvcreate -l 100%FREE -n lvtest Vol1 Logical volume \"lvtest\" created 用lvdisplay命令查看创建的逻辑卷的详细情况。 sudo lvdisplay Vol1 创建文件系统 sudo mkfs.ext4 /dev/Vol1/lvtest 在创建了新的文件系统之后,可以用标准Linux mount命令将这个卷挂载到虚拟目录中，就跟它是物理分区一样。唯一的不同是你需要用特殊的路径来标识逻辑卷。 sudo mount /dev/Vol1/lvtest /mnt/my_partition mount cd /mnt/my_partition ls -al mkfs.ext4和mount命令中用到的路径都有点奇怪。路径中使用了卷组名和逻辑卷名，而不是物理分区路径。 5. 修改LVM Linux LVM的好处在于能够动态修改文件系统。 Linux LVM包中的常见命令: 命令 功能 vgchange 激活和禁用卷组 vgremove 删除卷组 vgextend 将物理卷加到卷组中 vgreduce 从卷组中删除物理卷 lvextend 增加逻辑卷的大小 lvreduce 减小逻辑卷的大小 运行lsblk命令，查看磁盘的分区。 lsblk 用于查看磁盘和分区结构，df 用于查看文件系统的空间使用情。 逻辑卷中的文件系统需要手动修整来处理大小上的改变。大多数文件系统都包含了能够重新格式化文件系统的命令行程序，比如用于ext2、ext3和ext4文件系统的resize2fs程序。 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:8","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"安装软件程序 Linux中广泛使用的两种主要的PMS基础工具是dpkg和rpm。 基于Debian的发行版(如Ubuntu和Linux Mint)使用的是dpkg命令。 基于Red Hat的发行版(如Fedora、 openSUSE及Mandriva)使用的是rpm命令。 基于 Debian 的系统 dpkg工具常用选项: 列出特定软件包所安装的全部文件 dpkg -L package_name dpkg -L vim-common 查找某个特定文件属于哪个软件包 dpkg --search absolute_file_name #在使用的时候必须用绝对文件路径 dpkg --search /usr/bin/xxd #使用下面的结构来指定仓库源。 deb (or deb-src) address distribution_name package_type_list cat /etc/apt/sources.list #查看软件源 deb http://mirrors.aliyun.com/ubuntu/ focal multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse #Added by software-properties deb或deb-src的值表明了软件包的类型。 deb值说明这是一个已编译程序源，而deb-src值则说明这是一个源代码的源。 distribution_name条目是这个特定软件仓库的发行版版本的名称。 package_type_list条目可能并不止一个词，它还表明仓库里面有什么类型的包。你可以看到诸如main、restricted、universe和partner这样的值。 基于 Red Hat 的系统 yum:在Red Hat和Fedora中使用。 urpm:在Mandriva中使用。 zypper:在openSUSE中使用。 列出系统上已安装的包 yum list installed #通常会一闪而过，查看所有已安装的包 yum list installed \u003e installed_software #将这个记录重定向至文件方便查看 yum list xterm #查看特定应用包是否安装 yum provides file_name #找出系统上的某个特定文件属于哪个软件包 用yum安装软件 yum install package_name 手动下载rpm安装文件并用yum安装,这叫作本地安装。基本的命令是: yum localinstall package_name.rpm 用yum更新软件 yum list updates #列出所有可用更新 yum update package_name #更新特定安装包 yum update #更新所有安装包 用 yum 卸载软件 yum remove package_name #只删除软件包而保留配置文件和数据文件 yum erase package_name #删除软件和它所有的文件 处理损坏的包依赖关系 有时在安装多个软件包时，某个包的软件依赖关系可能会被另一个包的安装覆盖掉。这叫作损坏的包依赖关系(broken dependency) 。 yum clean all yum updates 显示所有包的库依赖关系以及什么软件可以提供这些库依赖关系。 yum deplist package_name 如果这样仍未解决问题，还有最后一招: yum update --skip-broken #--skip-broken选项允许你忽略依赖关系损坏的那个包,继续去更新其他软件包 yum 软件仓库 要想知道你现在正从哪些仓库中获取软件，输入如下命令: yum repolist 如果仓库中没有需要的软件，你可以编辑一下配置文件。yum的仓库定义文件位于/etc/yum.repos.d。你需要添加正确的URL，并获得必要的加密密钥。 从源码安装 tar -zxvf sysstat-11.1.1.tar.gz #解压文件放入sysstat-11.1.1的目录中 cd sysstat ./configure #检查你的Linux系统,确保它拥有合适的编译器能够编译源代码,另外还要具备正确的库依赖关系 make #make命令会编译源码,然后链接器会为这个包创建最终的可执行文件 sudo make install #想将它安装到Linux系统中常用的位置上 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:1:9","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"shell 脚本编程基础 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:2:0","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"构建基本脚本 创建 shell 脚本文件 在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为: #!/bin/bash shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外，# 后面的惊叹号会告诉shell用哪个shell来运行脚本(是的，你可以使用bash shell，同时还可以使用另一个shell来运行你的脚本)。 显示消息 echo string echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。 echo \"it's hello wrold\" 把文本字符串和命令输出显示在同一行中，在字符串的两侧使用引号，保证要显示的字符串尾部有一个空格。 echo -n \"hello world: \" #后引号前有一个空格 使用变量 环境变量 echo $HOME echo \"The cost of the item is \\$15\" #加斜杠转义为符号而不是变量 用户变量 用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。 用户变量区分大小写。 使用等号将值赋给用户变量。在变量、等号和值之间*不能出现空格。 #!/bin/bash date=10 guest=\"Peter\" echo \"$guest checked in $day days ago\" 命令替换 有两种方法可以将命令输出赋给变量: 反引号字符( ` ) $( )格式 test=`date` test1=$(date) #一段常见用法,在脚本中通过命令替换获得当前日期并用它来生成唯一文件名 today=$(date +%y%m%d) #%y年份后两位 ls /usr/bin -al \u003e log.$today 命令替换会创建一个子shell来运行对应的命令。子shell (subshell)是由运行该脚本的shell所创建出来的一个独立的子shell(child shell)。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的。 在命令行提示符下使用路径 ./ 运行命令的话，也会创建出子shell;要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心! 重定向输入和输出 输出重定向 最基本的重定向将命令\u003e的输出发送到一个文件中，如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。 command \u003e outputfile date \u003e test 追加数据\u003e\u003e date \u003e\u003e test 输入重定向 输入重定向符号是小于号(\u003c)。 wc命令可以对对数据中的文本进行计数: -l(–lines)文本的行数 -w(–words)文本的词数 -c(–bytes)文本的字节数 -m(–chars)字符统计 将文本文件重定向到wc命令: wc \u003c test #默认输出3个值，行数，词数，字节数 另外一种输入重定向的方法，称为内联输入重定向(inline input redirection)。 内联输入重定向符号是远小于号(«)，你必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。 command \u003c\u003c marker date marker wc \u003c\u003c EOF \u003estring 1 \u003estring 2 \u003estring 3 \u003eEOF #次提示符(\u003e) 管道 管道符号|。 command | command Linux系统实际上会同时运行由管道(|)连接的命令，在系统内部将它们连接起来。数据传输不会用到任何中间文件或缓冲区。 cat /etc/passwd | grep \"n\" | sort | more cat /etc/passwd | grep \"n\" | sort \u003e sorted_file 执行数学运算 expr 命令 $ expr 1 + 5 #+和数字之间有空格 6 许多expr命令操作符在shell中另有含义(比如星号)，在它们传入expr命令之前,需要使用shell的转义字符(反斜线)将其标出来。 $ expr 5 \\* 2 10 expr缺点较多，shell编程时不推荐使用。 使用方括号[ ] var1=$[ 1 + 2 ] var2=$[ $var1 * 5 ] bash shell数学运算符[ ]只支持整数运算。 z shell(zsh)提供了完整的浮点数算术操作。 浮点解决方案 最常见的方案是用内建的bash计算器，叫作bc。 bc的基本用法 bash计算器能够识别: 数字(整数和浮点数) 变量(简单变量和数组) 注释(以#或C语言中的/* */开始的行) 表达式 编程语句(例如if-then语句) 函数 浮点运算是由内建变量scale控制的，必须将这个值设置为你希望在计算结果中保留的小数位数，否则无法得到期望的结果。 scale变量的默认值是0。-q命令行选项可以不显示bash计算器冗长的欢迎信息。 bc -q #进入bash计算器 var1=10 var1*3 var2=var1/5 scale-4 #保留4位小数 print var2 quit #退出bc计算器 变量一旦被定义，你就可以在整个bash计算器会话中使用该变量了。print语句允许你打印变量和数字。 2. 在脚本中使用bc 基本格式如下: variable=$(echo \"options; expression\" | bc) #! /bin/bash var1=$(echo \"scale=4; 3.44 / 5\" | bc) echo The answer is $var1 如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。 bc命令能识别输入重定向，允许你将一个文件重定向到bc命令来处理。 最好的办法是使用内联输入重定向，它允许你直接在命令行中重定向数据。 variable=$(bc \u003c\u003c EOF \u003eoptions \u003estatements \u003eexpressions \u003eEOF ) 在bash计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用。 退出脚本 shell中运行的每个命令都使用退出状态码(exit status)告诉shell它已经运行完毕。退出状态码是一个0~255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。 查看退出状态码 Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。 date echo $? Linux退出状态码 状态码 描述 0 命令成功结束 1 一般性未知错误 2 不适合的shell命令 126 命令不可执行 127 没找到命令 128 无效的退出参数 128+x 与Linux信号x相关的严重错误 130 通过Ctrl+C终止的命令 255 正常范围之外的退出状态码 exit 命令 exit命令允许你在脚本结束时指定一个退出状态码。 #!/bin/bash # testing the exit status var1=10 var2=30 var3=$[$var1 + $var2] echo The answer is $var3 exit 5 #也可以在exit命令的参数中使用变量。 exit $var1 退出状态码最大只能是255。 ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:2:1","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["Linux"],"content":"使用结构化命令 使用 if-then 语句 if-then语句格式: if command then commands fi ","date":"2024-05-07","objectID":"/zh-cn/linux-command-line-and-shell-script-programming/:2:2","tags":["shell"],"title":"Linux Command Line And Shell Script Programming","uri":"/zh-cn/linux-command-line-and-shell-script-programming/"},{"categories":["documentation"],"content":" latex公式大全 读研写作latex公式相关 程序员数学 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:0:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"逻辑 逻辑 表示法 逻辑与 $A\\wedge B$ 逻辑或 $A\\vee B$ 逻辑非 $A\\neg B$ 逻辑相等 $A= B$ 逻辑异或 $A\\oplus B$ 逻辑蕴含 $A\\rightarrow B$ 逻辑蕴含 命题:若 $A$ 则 $B$ 逻辑表达式: $A\\rightarrow B$ 真值表: $A$ $B$ $A\\rightarrow B$ 0 1 1 1 0 0 0 1 1 1 1 1 逆否命题: ($\\neg B$)$\\rightarrow$($\\neg A$) ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:1:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"余数—一种问题的划分思想 奇偶校验的关键是找到合适的分类方法(完备性和排他性) 哥斯堡七桥问题 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:2:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"数学归纳法 将复杂问题简化 数学归纳法是由简单到复杂推理 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:3:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"置换、排列、组合 置换: $$P_n^n=n!$$ 排列: $$\\mathrm{P}_n^k=\\frac{n!}{(n-k)!}$$ 组合: $$\\mathrm{C}_n^k=\\frac{\\mathrm{P}_n^k}{\\mathrm{P}_k^k}=\\frac{n!}{(n-k)!(k)!}$$ 三者关系: $$\\mathrm{P}_n^k=\\mathrm{C}_n^k\\times \\mathrm{P}_k^k$$ ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:4:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"递归 将复杂问题简化 递归是将一般性前提推出个别性结论 递归思维方式：将复杂问题转为简单问题。核心是在问题中找出递归结构，建立递推公式。 斐波那契数列: $$0,1,1,2,3,5,8,13,21,34,55,89,…$$ 公式形式: $$S_n=S_{n-1}+S_{n-2}$$ 递归定义组合数: $$ \\mathrm{C_{n}^{k}}= \\begin{cases} 0,\u0026 (n=0 \\text{ 或 }k=0)\\\\ \\mathrm{C_{n-1}^{k-1}}+\\mathrm{C_{n-1}^{k}} \u0026 (0\u003ck\u003cn) \\end{cases} $$ 递归组合定义的数学理解: 从 n 个数中选 k 个包含特定数的组合等于包含特定数的组合($C_{n-1}^{k-1}$)加上不包含特定数的组合($C_{n-1}^{k}$) 找出复杂问题中隐含的递归结构步骤： 从 n 层的整体问题中隐去部分问题。 判断剩余问题是否是 n-1 层的问题。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:5:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"指数爆炸 数字急剧增长的情况称之为\"指数爆炸\"。 要一个不漏地测试设定选项的所有可能性是不现实的。 如果问题中包含指数爆炸，就不能简单的采用\"一个不漏\"的方法解决。 二分查找是利用指数爆炸的特性，每判断一次就能筛选出一半的\"有序\"查找对象。 处理庞大数字的工具–对数 利用指数爆炸加密 现在使用的密码，是用俗标\"密钥\"的随机字节流来加密的。 密码技术相关 四种处理指数爆炸问题的方法 极力求解:知道方法后极力求解。受限于计算机性能。 变相求解:转换成简单问题求解。不容易找到替换的方法。 近似求解:不求完全解答，而是找出近似解。数学层面虽不够严谨，但有利于实际应用。 概率求解:求解时使用随机数的方法。听起来虽不靠谱，不过在实际应用中却非常重要。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:6:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"不可解问题 不可解的数和无法编写的程序 反正法也称作归谬法 可数：集合的元素是有限的，或者集合中的所有元素都与正整数意义对应时，这个集合就被定义为可数。 可数集合: 有限集合 0以上所有偶数或奇数的集合 所有整数的集合 所有有理数的集合 程序的集合 不可数集合: 所有整数数列的集合，无穷个整数的排列成为整数数列。 所有实数的集合 所有函数的集合 对角论证法：为找出不包含在表中的数而选出表中对角线所有的数字。 不可解问题：原则上不能用程序解决的问题。 停机问题(Halting Problem)：判断\"某程序在给定数据下，是否会在有限时间内结束运行\"的问题。 许多判断程序运行的问题都是不可解问题。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:7:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"linux shell脚本攻略 不能出现在文件名中的字符只有斜线(/)和空操作符(null)两个。 斜线用来分割构成路径名的各个文件 空操作符则用来终止一个路径名 /表示根目录，以/开头的路径为绝对路径，否则为相对路径。相对路径从工作目录开始解释 linux+shell脚本攻略 参考源码 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:0:0","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"预备知识 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:0","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"显示输出 username@hostname$或root@hostname #:$ 表示普通用户， # 表示管理员用户root。 shell 脚本通常以 shebang(也作 hashbang) 起始:#!/bin/bash shebang 是一个文本行，其中 #! 位于解释器路径之前。 /bin/bash是Bash的解释器命令路径。 bash 将以 # 符号开头的行视为注释。脚本中只有第一行可以使用shebang来定义解释该脚本所使用的解 释器。 脚本的执行方式有两种 (1) 将脚本名作为命令行参数： bash myScript.sh (2) 授予脚本执行权限，将其变为可执行文件: chmod 755 myScript.sh #chmod a+x myScript.sh #所有用户获得执行权限 ./myScript.sh $ ./sample.sh #./表示当前目录 $ /home/path/sample.sh #使用脚本的完整路径 ~ 表示主目录，它通常是 /home/user ，其中 user 是用户名，如果是root用户，则为 /root 。 shell 使用分号或换行符来分隔单个命令或命令序列。 $ cmd1;cmd2 等同于 $ cmd1 $ cmd2 echo 是用于终端打印的最基本命令。 默认情况下， echo 在每次调用后会添加一个换行符。 $ echo \"Welcome to Bash\" #$ echo Welcome to Bash 同样可以输出 Welcome to Bash $ echo 'text in quotes'#单引号也可以实现同样的效果 #双引号允许shell解释字符串中出现的特殊字符。单引号不会对其做任何解释。 如果需要打印像!这样的特殊字符，那就不要将其放入双引号中，而是使用单引号，或是在特殊字符之前加上一个反斜线（\\）： $ echo Hello world ! $ echo 'Hello world !' $ echo \"Hello world \\!\" #将转义字符放在前面 #输出结果 Hello world ! 另一个可用于终端打印的命令是 printf 。该命令使用的参数和C语言中的 printf 函数一样。 $ printf \"Hello world\" #输出结果 Hello world $ 使用 echo 和 printf 的命令选项时，要确保选项出现在命令中的所有字符串之前，否则 Bash 会将其视为另外一个字符串。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:1","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"使用变量与环境变量 变量名由一系列字母、数字和下划线组成，其中不包含空白字符。常用的惯例是在脚本中使用大写字母命名环境变量，使用驼峰命名法或小写字母命名其他变量。 所有的应用程序和脚本都可以访问环境变量。可以使用 env 或 printenv 命令查看当前shell 中所定义的全部环境变量。 $ env #要查看其他进程的环境变量，可以使用如下命令 $ cat /proc/$PID/environ #PID 是相关进程的进程ID（ PID 是一个整数） 我们可以使用 pgrep 命令获得gedit的进程ID: #查看运行程序gedit的ID数值 $ pgrep gedit 12501 特殊文件/proc/PID/environ是一个包含环境变量以及对应变量值的列表。每一个变量以 name=value 的形式来描述，彼此之间由null字符（ \\0 ）分隔。 生成一份易读的报表，可以将 cat 命令的输出通过管道传给 tr ，将其中的 \\0 替换成 \\n： $ cat /proc/12501/environ | tr '\\0' '\\n' varName 是变量名， value 是赋给变量的值。如果 value 不包含任何空白字符（例如空格），那么就不需要将其放入引号中，则必须使用单引号或双引号。 varName=value 注意：var = value 不同于 var=value 。把 var=value 写成 var = value是一个常见的错误。两边没有空格的等号是赋值操作符，加上空格的等号表示的是等量关系测试。 在变量名之前加上美元符号（$）就可以访问变量的内容。 var=\"value\" #将\"value\"赋给变量var echo $var #显示var中的值 #也可以 echo ${var} 可以在 printf 、 echo 或其他命令的双引号中引用变量值 #!/bin/bash #文件名:variables.sh fruit=apple count=5 echo \"We have $count ${fruit}(s)\" We have 5 apple(s) #输出结果 shell使用空白字符来分隔单词，所以我们需要加上一对花括号来告诉shell这里的变量名是 fruit ，而不是 fruit(s)。 在 PATH 中添加一条新路径，可以使用如下命令: #将/home/user/bin添加到了 PATH 中 export PATH=\"$PATH:/home/user/bin\" #或者 PATH=\"$PATH:/home/user/bin\" export PATH export 命令声明了将由子进程所继承的一个或多个变量。可以将一个变量设置为环境变量，使得该变量在当前 Shell 进程中可被其他子进程访问到。 注意：使用单引号时，变量不会被扩展（expand），仍依照原样显示。这意味着 $ echo '$var' 会显示 $var 。 获得字符串的长度： var=123456789 length=${#var} 识别当前所使用的shell： echo $SHELL #或者 echo $0 检查是否为超级用户： #!/bin/bash #环境变量 UID 中保存的是用户ID #它可以用于检查当前脚本是以root用户还是以普通用户的身份运行的 #root用户的 UID 是 0 # [ 实际上是一个命令，必须将其与剩余的字符串用空格隔开 If [ $UID -ne 0 ]; then echo Non root user. Please run as root. else echo Root user fi 等价于 If test $UID -ne 0:1 then echo Non root user. Please run as root. else echo Root user fi 修改Bash的提示字符串（ username@hostname:~$ ） #利用 PS1 环境变量来定义主提示字符串 #默认的提示字符串是在文件 ~/.bashrc 中的某一行设置的 #查看设置变量 PS1 的那一行 $ cat ~/.bashrc | grep PS1 PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' #修改提示字符串，可以输入 $ PS1=\"PROMPT\u003e\" #提示字符串已经改变 PROMPT\u003e Type commands here. 还有一些特殊的字符可以扩展成系统参数。例如： \\u 可以扩展为用户名， \\h 可以扩展为主机名，而 \\w 可以扩展为当前工作目录。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:2","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"使用函数添加环境变量 环境变量通常保存了可用于搜索可执行文件、库文件等的路径列表。 export PATH=/opt/myapp/bin:$PATH export LD_LIBRARY_PATH=/opt/myapp/lib; $LD_LIBRARY_PATH #结果 PATH=/opt/myapp/bin:/usr/bin:/bin # : 路径分隔符 LD_LIBRARY_PATH=/opt/myapp/lib:/usr/lib; /lib 我们可以在.bashrc文件中定义如下函数，简化路径添加操作： #定义函数 prepend() { [ -d \"$2\" ] \u0026\u0026 eval $1=\\\"$2':'\\$$1\\\" \u0026\u0026 export $1; } #用法 prepend PATH /opt/myapp/bin prepend LD_LIBRARY_PATH /opt/myapp/lib 函数 prepend() 首先确认该函数第二个参数所指定的目录是否存在。如果存在， eval 表达式将第一个参数所指定的变量值设置成第二个参数的值加上 : （路径分隔符），随后再跟上第一个参数的原始值。 在进行添加时，如果变量为空，则会在末尾留下一个 : 。要解决这个问题，可以对该函数再做一些修改： prepend() { [ -d \"$2\" ] \u0026\u0026 eval $1=\\\"$2\"\\$\\$$1\\\" \u0026\u0026 export $1; } 在这个函数中，我们引入了一种shell参数扩展的形式： ${parameter:+expression} 如果 parameter 有值且不为空，则使用 expression 的值。 通过这次修改，在向环境变量中添加新路径时，当且仅当旧值存在，才会增加 : 。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:3","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"使用 shell 进行数学运算 Bash shell使用 let 、 (( )) 和 [ ] 执行基本的算术操作。工具 expr 和 bc 可以用来执行高级操作。 let命令可以直接执行基本的算术操作。当使用 let 时，变量名之前不需要再添加 $ 。 no1=4; no2=5; let result=no1+no2; echo $result let 命令的其他用法如下： 自加操作 $ let no1++ 自减操作 $ let no1-- 简写形式 let no+=6 let no-=6 #它们分别等同于 let no=no+6 和 let no=no-6 操作符 [ ] 的使用方法和 let 命令一样： result=$[ no1 + no2 ] #注意空格[]前后位置都要有空格 result=$[ $no1 + 5 ] 也可以使用操作符 (()) 。出现在 (()) 中的变量名之前需要加上 $ ： result=$(( no1 + 50 )) expr 同样可以用于基本算术操作： result=`expr 3 + 4` result=$(expr $no1 + 5) 注意：以上这些方法不支持浮点数，只能用于整数运算。 bc 是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数： echo \"4 * 0.56\" | bc 2.24 no=54; #result=`echo \"$no * 1.5\" | bc` #反引号旧语法，推荐使用下面的$() result=$(echo \"$no * 1.5\" | bc) echo $result 81.0 bc 可以接受操作控制前缀。这些前缀之间使用分号分隔。 设定小数精度： #参数 scale=2 将小数位个数设置为 2 echo \"scale=2;22/7\" | bc 3.14 进制转换： #!/bin/bash #数字转换 no=100 echo \"obase=2;$no\" | bc #二进制,默认ibase为十进制 1100100 no=1100100 echo \"obase=10;ibase=2;$no\" | bc #obase：输出进制，ibase:输入进制 100 计算平方以及平方根： echo \"sqrt(100)\" | bc #平方根 echo \"10^10\" | bc #平方 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:4","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"文件描述符与重定向 文件描述符是与输入和输出流相关联的整数。常见的文件描述符有stdin(标准输入)、stdout(标准输出)和stderr(标准错误)。我们可以将某个文件描述符的内容重定向到另一个文件描述符中。 脚本可以使用大于号(\u003e)将输出重定向到文件中,命令产生的文本可能是正常输出，也可能是错误信息。默认情况下，正常输出（ stdout ）和错误信息（ stderr ）都会显示在屏幕上。 文件描述符是与某个打开的文件或数据流相关联的整数。文件描述符 0 、 1 以及 2 是系统预留的: 0 —— stdin （标准输入） 1 —— stdout （标准输出） 2 —— stderr （标准错误） 使用大于号(\u003e)将文本保存到文件中(若文件存在，则先清空文件内的文本，再写入文本)： $ echo \"This is a sample text 1\" \u003e temp.txt #该命令会将输出的文本保存在temp.txt中。 #如果temp.txt已经存在，大于号会清空该文件中 先前的内容。 使用双大于号(»)将文本追加到文件中(不会清空文件中的内容)： echo \"This is sample text 2\" \u003e\u003e temp.txt 使用 cat 查看文件内容： $ cat temp.txt This is sample text 1 This is sample text 2 重定向 stderr: $ ls + ls: cannot access +: No such file or directory #这里， + 是一个非法参数，因此会返回错误信息。 $ ls + \u003e out.txt #因为 stdout 并没有输出，所以out.txt的内容为空 $ ls + 2\u003e out.txt #重定向到out.txt 将 stderr 和 stdout 分别重定向到不同的文件中： $ cmd 2\u003estderr.txt 1\u003estdout.txt 将stderr 和 stdout 都重定向到同一个文件中： $ cmd 2\u003e\u00261 alloutput.txt #或者这样 $ cmd \u0026\u003e output.txt 如果你不想看到或保存错误信息，那么可以将 stderr 的输出重定向到/dev/null(一个特殊的设备文件，它会丢弃接收到的任何数据)。 我们在处理一些命令输出的同时还想将其保存下来，以备后用。 stdout 作为单数据流（single stream），可以被重定向到文件或是通过管道传入其他程序，但是无法两者兼得。 有一种方法既可以将数据重定向到文件，还可以提供一份重定向数据的副本作为管道中后续命令的 stdin 。 tee 命令从 stdin 中读取，然后将输入数据重定向到 stdout 以及一个或多个文件中。 command | tee FILE1 FILE2 | otherCommand 命令 cat -n 为从 stdin 中接收到的每一行数据前加上行号并将其写入 stdout ： $ cat a* | tee out.txt | cat -n cat: a1: Permission denied 1 A2 2 A3 使用 cat 查看out.txt的内容： $ cat out.txt A2 A3 注意：cat: a1: Permission denied 并没有在文件内容中出现，因为这些信息被发送到了 stderr ，而 tee 只能从 stdin 中读取。 默认情况下， tee 命令会将文件覆盖，但它提供了一个 -a 选项，可用于追加内容。 $ cat a* | tee -a out.txt | cat -n 带有参数的命令可以写成： command FILE1 FILE2 ... ，或者就简单地使用 command FILE 。 要发送输入内容的两份副本给 stdout ，使用 - 作为命令的文件名参数即可： #$ cmd1 | cmd2 | cmd - $ echo who is this | tee - who is this who is this 默认情况下，重定向操作针对的是标准输出。 从 stdin 读取输入的命令能以多种方式接收数据。可以用 cat 和管道来指定我们自己的文件描述符。 将文件重定向到命令： #借助小于号（ \u003c ），我们可以像使用 stdin 那样从文件中读取数据 $ cmd \u003c file 重定向脚本内部的文本块 #!/bin/bash #可以将脚本中的文本重定向到文件。 #要想将一条警告信息添加到自动生成的文件顶部，可以使用下面的代码: cat\u003c\u003cEOF\u003elog.txt #重定义文件结束符 EOF This is a generated file. Do not edit. Changes will be overwritten. EOF #出现在 cat \u003c\u003cEOF\u003elog.txt 与下一个 EOF 行之间的所有文本行都会被当作 stdin 数据。log.txt文件的内容显示如下: $ cat log.txt This is a generated file. Do not edit. Changes will be overwritten. 自定义文件描述符 文件描述符是一种用于访问文件的抽象指示器存取文件离不开被称为\"文件描述符\"的特殊数字。 0 、 1 和 2 分别是stdin 、 stdout 和 stderr 预留的描述符编号。 exec 命令创建全新的文件描述符。常用的打开模式有3种： (1)只读模式。\u003c (2)追加写入模式。» (3)截断写入模式。\u003e 创建一个用于读取文件的文件描述符： $ # exec 3\u003cinput.txt #使用文件描述符3打开并读取文件 $ echo this is a test line \u003e input.txt $ exec 3\u003cinput. \u003c\u0026：将输入重定向到指定的文件描述符。 在命令中使用文件描述符 3： $ cat\u003c\u00263 this is a test line 如果要再次读取，我们就不能继续使用文件描述符 3 了，而是需要用 exec 重新创建一个新的文件描述符（可以是 4 ）来从另一个文件中读取或是重新读取上一个文件。 创建一个用于写入（截断模式）的文件描述符： $ #exec 4\u003eoutput.txt #打开文件进行写入 $ exec 4\u003eoutput.txt $ echo newline \u003e\u00264 $ cat output.txt newline 创建一个用于写入（追加模式）的文件描述符： #$ exec 5\u003e\u003einput.txt $ exec 5\u003e\u003einput.txt $ echo appended line \u003e\u00265 $ cat input.txt newline appended line ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:5","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"数组与关联数组 Bash从4.0版本才开始支持关联数组 数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。当数据以数字顺序组织的时候，应该使用普通数组，例如一组连续的迭代。当数据以字符串组织的时候，关联数组就派上用场了，例如主机名称。 定义数组的方法 #这些值将会存储在以0为起始索引的连续位置上 array_var=(test1 test2 test3 test4) #将数组定义成一组“索引-值” array_var[0]=\"test1\" array_var[1]=\"test2\" array_var[2]=\"test3\" array_var[3]=\"test4\" 打印出特定索引的数组元素内容 echo ${array_var[0]} test1 index=3 echo ${array_var[$index]} test4 以列表形式打印出数组中的所有值 $ echo ${array_var[*]} test1 test2 test3 test4 #或者 $ echo ${array_var[@]} test1 test2 test3 test4 打印数组长度（即数组中元素的个数） $ echo ${#array_var[*]} 4 定义关联数组 #使用声明语句将一个变量定义为关联数组 $ declare -A ass_array 可以用下列两种方法将元素添加到关联数组中 使用行内\"索引 - 值\"列表 $ ass_array=([index1]=val1 [index2]=val2) 使用独立的\"索引 - 值\"进行赋值： $ ass_array[index1]=val1 $ ass_array[index2]=val2 列出数组索引(普通数组和关联数组均可使用) $ echo ${!array_var[*]} #或者 $ echo ${!array_var[@]} ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:6","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"别名 使用 alias 命令创建别名。 创建别名 #为 apt-get install 创建了一个别名 $ alias install='sudo apt-get install' alias 命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名在所有的shell中都可用，可以将其定义放入~/.bashrc文件中。每当一个新的交互式shell进程生成时，都会执行 ~/.bashrc中的命令。 #添加别名 $ echo 'alias cmd=\"command seq\"' \u003e\u003e ~/.bashrc 删除别名 只需将其对应的定义（如果有的话）从~/.bashrc中删除，或者使用unalias 命令。也可以使用 alias example= ，这会取消别名 example。 注意：创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的设置取代。 创建别名并为原文件保留一个副本 #创建一个别名 rm ，它能够删除原始文件，同时在backup目录中保留副本 alias rm='cp $@ ~/backup \u0026\u0026 rm $@' $@ 的含义：$@ 表示所有的位置参数，每个参数都是一个独立的字符串。 在使用 $@ 时，最好将其放在双引号中以避免参数的空格和特殊字符被解释为多个参数。这样可以确保每个参数都作为独立的字符串进行处理。 $@ 和 $* 的区别：$@和 $* 都表示所有的位置参数，但在引用时有所不同。$@ 会将每个参数作为独立的引用，并保留参数中的空白和特殊字符；而 $* 会将所有参数作为单个字符串引用，并在参数之间插入第一个字符处定义的特殊字符（通常是空格）。 对别名进行转义 创建一个和原生命令同名的别名很容易，你不应该以特权用户的身份运行别名化的命令。我们可以转义要使用的命令，忽略当前定义的别名。 $ \\command 字符 \\ 可以转义命令，从而执行原本的命令。在不可信环境下执行特权命令时，在命令前加上 \\ 来忽略可能存在的别名总是一种良好的安全实践。这是因为攻击者可能已经将一些别有用心的命令利用别名伪装成了特权命令，借此来盗取用户输入的重要信息。 列举别名 alias alias ll='ls -l' alias lt='ls -t' alias la='ls -a' ... ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:7","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"采集终端信息 tput 和 stty 是两款终端处理工具。 获取终端的行数和列数： tput cols tput lines 打印出当前的终端名： tput longname 将光标移动到坐标(100,100)处： tput cup 100 100 设置终端背景色： tput setb n #n 可以在0到7之间取值 设置终端前景色： tput setf n #n 可以在0到7之间取值 注意：包括常用的 color ls 在内的一些命令可能会重置前景色和背景色。 设置文本样式为粗体： tput bold 设置下划线的起止： tput smul tput rmul 删除从当前光标位置到行尾的所有内容： tput ed 输入密码时，脚本不应该显示输入内容。在下面的例子中，我们将看到如何使用 stty 来实现这一需求： #!/bin/sh #Filename: password.sh echo -e \"Enter password: \" # 在读取密码前禁止回显 stty -echo read password # 重新允许回显 stty echo echo $password #显示输入的密码 stty 命令的选项 -echo 禁止将输出发送到终端，而选项 echo 则允许发送输出。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:8","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"获取并设置日期及延时 在系统内部，日期被存储成一个整数，其取值为自1970年1月1日0时0分0秒 起所流逝的秒数。这种计时方式称为纪元时或Unix时间。 读取日期： $ date Thu May 20 23:09:04 IST 2010 2024年 03月 21日 星期四 22:52:24 CST 打印纪元时： $ date +%s 1711032681 将日期转换成纪元时： $ date --date \"Wed mar 15 08:09:16 EDT 2017\" +%s $ date -d \"Wed mar 15 08:09:16 EDT 2017\" +%s #这条命令无法转带中文格式日期 1489579718 用带有前缀 + 的格式化字符串作为 date 命令的参数，可以按照你的选择打印出相应格式的日期： $ date \"+%d %B %Y\" 20 May 2010 设置日期和时间： ## date -s \"格式化的日期字符串\" date -s \"21 June 2009 11:01:22\" #如果系统已经联网，可以使用 ntpdate 来设置日期和时间： /usr/sbin/ntpdate -s time-b.nist.gov date 命令可以用于计算一组命令所花费的执行时间: #!/bin/bash #文件名: time_take.sh start=$(date +%s) #date 命令的最小精度是秒,对命令计时的另一种更好的方式是使用 time 命令 commands; statements; end=$(date +%s) difference=$(( end - start)) echo Time taken to execute commands is $difference seconds. 在脚本中生成延时： #!/bin/bash #文件名: sleep.sh echo Count: tput sc # 循环40秒 for count in `seq 0 40` do tput rc tput ed echo -n $count #-n,不输出尾部换行符 sleep 1 done 在上面的例子中，变量依次使用了由 seq 命令生成的一系列数字。我们用 tput sc 存储光标位置。在每次循环中，通过 tput rc 恢复之前存储的光标位置，在终端中打印出新的 count 值，然后使用 tputs ed 清除从当前光标位置到行尾之间的所有内容。行被清空之后，脚本就可以显示出新的值。 sleep 可以使脚本在每次循环迭代之间延迟1秒钟。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:9","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"调试脚本 可以利用Bash内建的调试工具或者按照易于调试的方式编写脚本。 使用选项 -x，启用shell脚本的跟踪调试功能： $ bash -x script.sh #或 sh -x script 运行带有 -x 选项的脚本可以打印出所执行的每一行命令以及当前状态。 使用 set -x 和 set +x 对脚本进行部分调试。 #!/bin/bash #文件名: debug.sh for i in {1..6}; do set -x #-x与+x包裹部分是被限制的调试区域 echo $i set +x done echo \"Script executed\" 该脚本并没有使用上例中的 seq 命令，而是用 {start..end} 来迭代从 start 到 end 之间的值。这个语言构件（construct）在执行速度上要比 seq 命令略快。 定义 _DEBUG 环境变量来启用或禁止调试及生成特定形式的信息。 #!/bin/bash #名字: debug.sh function DEBUG() { [ \"$_DEBUG\" == \"on\" ] \u0026\u0026 $@ || : #[]为真执行$@(位置参数)，[]为假执行 ||后面的:,shell空命令(这里当作占位符) } for i in {1..10} do DEBUG echo \"I is $i\" done 将调试功能设置为 on 来运行上面的脚本： _DEBUG=on ./debug.sh #需有x权限 我们在每一条需要打印调试信息的语句前加上 DEBUG 。如果没有把 _DEBUG=on 传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 : 告诉shell不要进行任何操作。 set -x ：在执行时显示参数和命令。 set +x ：禁止调试。 set -v ：当命令进行读取时显示输入。 set +v ：禁止打印输入。 shebang的妙用 把shebang从 #!/bin/bash 改成 #!/bin/bash -xv ，这样一来，不用任何其他选项就可以启用调试功能了。 以将环境变量PS4设置为 '$LINENO: ' ，显示出每行的行号： PS4='$LINENO: ' ``（反引号）用于执行命令替换，将命令的输出结果作为替换结果。 ‘’（单引号）用于创建字符串字面值，保持所有字符的原样性，不进行变量替换或命令执行。 使用了 -x或 set -x ，调试输出会被发送到 stderr，可以使用下面的命令将其重定向到文件中： sh -x testScript.sh 2\u003e debugout.txt Bash 4.0以及后续版本支持对调试输出使用自定义文件描述符： exec 6\u003e /tmp/debugout.txt BASH_XTRACEFD=6 BASH_XTRACEFD=6 是一个环境变量设置，它指示Bash Shell将跟踪（trace）输出重定向到文件描述符6。通常，Bash Shell使用文件描述符2（标准错误）来输出跟踪信息，但通过将BASH_XTRACEFD设置为6，你可以将跟踪输出重定向到文件描述符6，从而将跟踪信息写入/tmp/debugout.txt 文件。 函数和参数 函数和别名乍一看很相似，不过两者在行为上还是略有不同。最大的差异在于函数参数可以在函数体中任意位置上使用，而别名只能将参数放在命令尾部。 函数的定义包括function命令、函数名、开/闭括号以及包含在一对花括号中的函数体。 函数可以这样定义： function fname() { statements; } #或者 fname() { statements; } #或者 fname() { statement; } 只需使用函数名就可以调用函数 $ fname ; #执行函数 函数参数可以按位置访问， $1 是第一个参数， $2 是第二个参数，以此类推： fname arg1 arg2 ; #传递参数 以下是函数 fname 的定义。在函数 fname 中，包含了各种访问函数参数的方法。 fname() { echo $1, $2; #访问参数1和参数2 echo \"$@\"; #以列表的方式一次性打印所有参数 echo \"$*\"; #类似于$@，但是所有参数被视为单个实体 return 0; #返回值 } 传入脚本的参数可以通过下列形式访问。 $0 是脚本名称。 $1 是第一个参数。 $2 是第二个参数。 $n 是第n个参数。 \"$@\" 被扩展成 \"$1\" \"$2\" \"$3\" 等。 \"$*\" 被扩展成 \"$1c$2c$3\" ，其中 c 是IFS的第一个字符。 $@要比$*用得多。由于$*将所有的参数当作单个字符串,因此它很少被使用。 grep命令找到的是字符串eth0,而不是IP地址。如果我们使用函数来实现的话,可以将设备名作为参数传入ifconfig,不再交给 grep : $\u003e function getIP() { /sbin/ifconfig $1 | grep 'inet '; } $\u003e getIP eth0 inet addr:192.168.1.2 Bcast:192.168.255.255 Mask:255.255.0.0 #直接方式也可以获得 $\u003e ifconfig eth0 | grep \"inet\" inet addr:192.168.1.2 Bcast:192.168.255.255 Mask:255.255.0.0 Bash函数的技巧 在Bash中,函数同样支持递归调用(可以调用自身的函数),如F() { echo $1; F hello;sleep 1; } 递归函数 Fork炸弹 :(){ :|:\u0026 };: #这个函数会一直地生成新的进程,最终形成拒绝服务攻击。 #函数调用前的 \u0026将子进程放入后台。 #这段危险的代码能够不停地衍生出进程,因而被称为Fork炸弹。 可以通过修改配置文件/etc/security/limits.conf中的 nproc 来限制可生成的最大进程数,进而阻止这种攻击。 #将所有用户可生成的进程数限制为100 hard nproc 100 导出函数 函数也能像环境变量一样用export导出,如此一来,函数的作用域就可以扩展到子进程中: export -f fname $\u003e function getIP() { /sbin/ifconfig $1 | grep 'inet '; } $\u003e echo \"getIP eth0\" \u003etest.sh $\u003e sh test.sh #sh 无法使用函数 sh: getIP: No such file or directory $\u003e export -f getIP $\u003e sh test.sh test.sh: 2: getip: not found $\u003e bash test.sh #sh 不支持export命令 inet addr: 192.168.1.2 Bcast: 192.168.255.255 Mask:255.255.0.0 读取命令返回值(状态) cmd echo $? #返回值被称为退出状态。它可用于确定命令执行成功与否。 #如果命令成功退出,那么退出状态为0,否则为非0。 下面的脚本可以报告命令是否成功结束: #!/bin/bash #文件名: success_test.sh #对命令行参数求值,比如success_test.sh ‘ls | grep txt’ eval $@ #eval $@ 是一个在Shell脚本中常见的用法，它用于执行传递给脚本的命令行参数。当使用 eval $@ 时，eval 命令会对 $@ 中的参数进行解析和执行。 if [ $? -eq 0 ]; then echo \"$CMD executed successfully\" else echo \"$CMD terminated unsuccessfully\" fi 向命令传递参数 $# 是一个特殊变量，用于获取传递给脚本的命令行参数的数量。 shift命令可以将参数依次向左移动一个位置,让脚本能够使用$1 来访问到每一个参数。下面的代码显示出了所有的命令行参数: $ cat showArgs.sh for i in `seq 1 $#` do echo $i is $1 shift done $ sh showArgs.sh a b c 1 is a 2 is b 3 is c ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:10","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"将一个命令的输出发送给另一个命令 使用管道 | 来连接多条命令 $ cmd1 | cmd2 | cmd3 组合两个命令： $ ls | cat -n \u003e out.txt # -n，加上行号 将命令序列的输出赋给变量: #这种方法叫作子shell法 cmd_output=$(ls | cat -n) echo $cmd_output #或者，反引号 cmd_output=`COMMANDS` 利用子shell生成一个独立的进程 子shell本身就是独立的进程。可以使用()操作符来定义一个子shell。 $\u003e pwd / $\u003e (cd /bin; ls) awk bash cat... $\u003e pwd / 当命令在子shell中执行时,不会对当前shell造成任何影响;所有的改变仅限于该子shell内。例如,当用cd命令改变子shell的当前目录时,这种变化不会反映到主shell环境中。 通过引用子shell的方式保留空格和换行符 $ cat text.txt 1 2 3 $ out=$(cat text.txt) $ echo $out 1 2 3 # 丢失了1、2、3中的\\n $ out=\"$(cat text.txt)\" $ echo $out 1 2 3 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:11","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"在不按下回车键的情况下读入 n 个字符 read命令提供了一种不需要按回车键就能够搞定这个任务的方法。 句从输入中读取n个字符并存入变量variable_name: read -n number_of_chars variable_name $ read -n 2 var #读入最多2个字符终止输入 $ echo $var 用无回显的方式读取密码: read -s var 使用read显示提示信息: read -p \"Enter input:\" var 在给定时限内读取输入: #read -t timeout var $ read -t 2 var #在2秒内将键入的字符串读入变量var 用特定的定界符作为输入行的结束: #read -d delim_char var $ read -d \":\" var hello: #var被设置为hello ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:12","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"持续运行命令直至执行成功 repeat() { while true do $@ \u0026\u0026 return done } #函数repeat()中包含了一个无限while循环, #该循环执行以函数参数形式(通过$@访问)传入的命令。 #如果命令执行成功,则返回,进而退出循环。 一种更快的做法 true是作为/bin中的一个二进制文件来实现的。这就意味着每执行一次之前提到的while循环,shell就不得不生成一个进程。为了避免这种情况,可以使用shell的内建命令:,该命令的退出状态总是为0: repeat() { while :; do $@ \u0026\u0026 return; done } #尽管可读性不高,但是肯定比第一种方法快 加入延时 repeat() { while :; do $@ \u0026\u0026 return; sleep 30; done } #sleep 30秒 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:13","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"字段分隔符与迭代器 内部字段分隔符(Internal Field Separator,IFS)是shell脚本编程中的一个重要概念。在处理文本数据时,它的作用可不小。 它是一个环境变量,其中保存了用于分隔的字符。 #CSV数据data data=\"name, gender,rollno,location\" oldIFS=$IFS IFS=, #IFS现在被设置为, for item in $data; do echo Item: $item done IFS=$oldIFS 注意：IFS的默认值为空白字符(换行符、制表符或者空格)。 以/etc/passwd为例,看看IFS的另一种用法。在文件/etc/passwd中,每一行包含了由冒号分隔的多个条目。该文件中的每行都对应着某个用户的相关属性。每行的最后一项指定了用户的默认shell。 利用IFS打印出用户以及他们默认的shell： #!/bin/bash #用途: 演示IFS的用法 line=\"root:x:0:0:root:/root:/bin/bash\" oldIFS=$IFS; IFS=\":\" count=0 for item in $line; do [ $count -eq 0 ] \u0026\u0026 user=$item; [ $count -eq 6 ] \u0026\u0026 shell=$item; let count++ done; IFS=$oldIFS #echo $user's shell is $shell; # unexpected EOF while looking for matching `'' #syntax error: unexpected end of file echo \"$user's shell is $shell\" 面向列表的for循环： for var in list; do commands; #使用变量$var done list可以是一个字符串,也可以是一个值序列。 echo {1..50}; #生成一个从1~50的数字序列 echo {a..z} {A..Z}; #生成大小写字母序列 迭代指定范围的数字： for((i=0;i\u003c10;i++)) #双层小括号() { commands; #使用变量$i } 循环到条件满足为止： while condition do commands; done until循环： 在Bash中还可以使用一个特殊的循环until。它会一直循环，直到给定的条件为真。 x=0; until [ $x -eq 9 ]; #条件是[$x -eq 9 ] do let x++; echo $x; done ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:14","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"比较与测试 用if、if else 以及逻辑运算符来测试。还有一个 test命令也可以用于测试。 if条件： if condition; then commands; fi else if和else： if condition; then commands; else if condition; then commands; else commands; fi if的条件判断部分可能会变得很长，但可以用 逻辑运算符将它变得简洁一些： [ condition ] \u0026\u0026 action; # 如果condition为真,则执行action [ condition ] || action; # 如果condition为假,则执行action 算术比较 [$var -eq 0 ] or [ $var -eq 0] #注意在[或]与操作数之间有一个空格 [ $var -eq 0 ] #当$var等于0时,返回真 [ $var -ne 0 ] #当$var不为0时,返回真 #-gt:大于 #-lt:小于 #-ge:大于或等于 #-le:小于或等于 [ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a [ $var1 -ne 0 -o $var2 -gt 2 ] #逻辑或-o 文件系统相关测试 [ -f $file_var ]：如果给定的变量包含正常的文件路径或文件名，则返回真。 [ -x $var ]：如果给定的变量包含的文件可执行，则返回真。 [ -d $var ]：如果给定的变量包含的是目录，则返回真。 [ -e $var ]：如果给定的变量包含的文件存在，则返回真。 [ -c $var ]：如果给定的变量包含的是一个字符设备文件的路径，则返回真。 [ -b $var ]：如果给定的变量包含的是一个块设备文件的路径，则返回真。 [ -w $var ]：如果给定的变量包含的文件可写，则返回真。 [ -r $var ]：如果给定的变量包含的文件可读，则返回真。 [ -L $var ]：如果给定的变量包含的是一个符号链接，则返回真。 fpath=\"/etc/passwd\" if [ -e $fpath ]; then echo File exists; else echo Does not exist; fi 字符串比较 进行字符串比较时,最好用双中括号，因为有时候采用单个中括号会产生错误。 注意：双中括号是Bash的一个扩展特性。如果出于性能考虑，使用ash或dash来运行脚本,那么将无法使用该特性。 常用字符比较: #测试两个字符串是否相同 [[ $str1 = $str2 ]] #当 str1等于str2时,返回真。也就是说,str1和 str2包含的文本是一模一样的。 [[ $str1 == $str2 ]] #这是检查字符串是否相同的另一种写法。 #测试两个字符串是否不同 [[ $str1 != $str2 ]] #如果str1和str2不相同,则返回真 #找出在字母表中靠后的字符串 [[ $str1 \u003e $str2 ]] #如果str1的字母序比str2大,则返回真。 [[ $str1 \u003c $str2 ]] #如果str1的字母序比str2小,则返回真。 #测试空串 [[ -z $str1 ]] #如果str1为空串,则返回真 [[ -n $str1 ]] #如果str1不为空串,则返回真 使用逻辑运算符 \u0026\u0026 和 ||组合多个条件： if [[ -n $str1 ]] \u0026\u0026 [[ -z $str2 ]] ; then commands; fi test命令可以用来测试条件，用test可以避免使用过多的括号，增强代码的可读性： if [ $var -eq 0 ]; then echo \"True\"; fi #用test写法 if test $var -eq 0 ; then echo \"True\"; fi 注意：test是一个外部程序,需要衍生出对应的进程，而 [ 是Bash的一个内部函数，因此后者的执行效率更高。test兼容于Bourne shell、ash、dash等。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:15","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"使用配置文件定制 bash Linux和Unix中能够放置定制脚本的文件不止一个。这些配置文件分为3类:登录时执行的、启动交互式shell时执行的以及调用shell处理脚本文件时执行的。 当用户登录shell时,会执行下列文件: /etc/profile, $HOME/.profile, $HOME/.bash_login, $HOME/.bash_profile / 通过图形化登录管理器登入的不会执行/etc/profile、 $HOME/.profile和$HOME/.bash_profile这3个文件的。 因为图形化窗口管理器并不会启动shell。当你打开终端窗口时才会创建shell，但这个shell也不是登录shell。 如果.bash_profile或.bash_login文件存在,则不会去读取.profile文件。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:1:16","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"命令之乐 实用的命令grep、 awk 、 sed和find。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:2:0","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":["documentation"],"content":"用 cat 进行拼接 cat命令是一个经常会用到的简单命令，它本身表示conCATenate(拼接)。 cat读取文件内容的一般语法是： cat file1 file2 file3 ... 该命令将作为命令行参数的文件内容拼接在一起并将结果发送到stdout。 #打印单个文件的内容 $ cat file.txt #打印多个文件的内容 $ cat one.txt two.txt cat命令不仅可以读取文件、拼接数据，还能够从标准输入中读取。 管道操作符可以将数据作为cat命令的标准输入: # OUTPUT_FROM_SOME COMMANDS | cat echo \"hello\" | cat cat也可以将文件内容与终端输入拼接在一起。 将stdin和另一个文件中的数据组合在一起： $ echo 'Text through stdin' | cat - file.txt # - 被作为stdin文本的文件名 去掉多余的空白行： $ cat -s file.txt #将file中连续的空白行压缩为单行空白 #可以用 tr 删除所有的空白行 将制表符显示为^I。 对于Python而言，制表符和空格是区别对待的。 cat有一个特性，可以将制表符识别出来。 用cat命令的-T选项能够将制表符标记成 ^I。 $ cat file.py def function(): var = 5 next = 6 third = 7 $ cat -T file.py def function(): ^Ivar = 5 ^I^Inext = 6 ^Ithird = 7^I cat命令的-n选项会在输出的每一行内容之前加上行号。 #!/bin/bash $ cat \u003e lines.txt line line line $ cat -n lines.txt 1 line 2 line 3 line ","date":"2024-03-22","objectID":"/zh-cn/linux-shell-script/:2:1","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell-script/"},{"categories":null,"content":"关于博客","date":"2023-10-31","objectID":"/zh-cn/about/","tags":null,"title":"关于博客","uri":"/zh-cn/about/"},{"categories":null,"content":"学编程什么时候都不晚 欢迎访问我的博客！ 这是一个记录学习编程技术的博客，详细内容可见全部文档。如读者能在这里学到知识，作者将不胜荣幸！ ","date":"2023-10-31","objectID":"/zh-cn/about/:0:0","tags":null,"title":"关于博客","uri":"/zh-cn/about/"}]