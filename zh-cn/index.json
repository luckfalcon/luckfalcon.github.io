[{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r 将此页保存为书签，以备将来参考!\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat\r像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat\r稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2023-10-31","objectID":"/zh-cn/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/zh-cn/basic-markdown-syntax/"},{"categories":["others"],"content":"搜索技术介绍","date":"2023-10-31","objectID":"/zh-cn/search-technology/","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["others"],"content":" AI Poe 免费的 AI，需要科学上网环境 ","date":"2023-10-31","objectID":"/zh-cn/search-technology/:0:0","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["others"],"content":"搜索技术介绍 为什么搜？ 知道 学习 创作 完工 知道怎么搜？ 去哪里搜？ 怎么搜？ 信息资讯 搜索效率： 谷歌 \u003e 短视频公众号 \u003e 短视频 \u003e 百度 谷歌搜索技巧 ( 谷歌搜不到微信公众号的文章 ) “\"，限定关键词,完全匹配搜索，示例 : \" 你好! \" intitle，限定标题，示例 ：intitle : 你好！ allintitle，限定多个标题，示例 ：allintitle : 你好！ 他好！ intext，限定内容 （ 可限制多个内容关键词 ），示例 ： intext : 你好！ inurl，限定网址关键字，示例 : inurl : CCTV，李子奇 inurl : CCTV site，限定网址来源，示例 ： site : zhihu.com imagesize，限定图片尺寸，示例 ： imagesize : 255 x 255 或者直接 图片名:255X255 filetype，限定文件格式， 示例 ： filetype : ppt/pdf… .. 符号,定位时间，示例：世界杯举办时间..2014 - 符号，用来屏蔽关键字，示例:中国国家税收贡献最高的省份 -广东 简单搜索，示例：牛肉面馆 附近 cache关键字，访问最近的缓存版本，示例：cache:www.blog.com 知识技能 知识存在地方： 组织内部 （ 同事的电脑、聊天记录、线上知识库 ） 组织外部 （ 网页、电子书、电子文档、学术论文、笔记、知识平台、视频网站、AI 大脑、牛人的大脑 ） 谷歌和 YouTube 是最好的知识获得平台 聚合具有某个头部的网站方法 filetype : pdf inurl : baogao SimilarSites : baogao.com，从 SimilarSites 网站获取头部相关的网站 学术论文搜索 谷歌学术 sci-hub ( 只能搜索论文的完整题目，无法关键字检索 ) 电子书搜索 鸠摩搜书 素材文件 素材类型 ：视频、音频、图片、文件 无版权视频素材网站 ( 谷歌搜索：best sites for free stock videos ) pexels pixabay ( 也包含图片音乐音效等 ) videvo mixkit YouTube 视频下载 save.tube www.9x ( YouTube 视频网址 ) 高清免费无版权图片网站 pexels pixabay ( 也包含图片音乐音效等 ) unsplash 有版权高清图片网站 gettyimages图片搜索地址 gettyimages 图片下载地址 图标 ( icons ) iconfont 阿里图片搜索库 PPT模板 iSlide canva 在线设计平台，可设计视频、PPT 等 工具软件 在线工具 –\u003e 下载软件 –\u003e 安装插件 谷歌搜索 ：需求 + online 在线抠图 在线文字转语音 腾讯智影 微软的 Azure 画脑图或概念图 miro 画脑图 canva 画概念图 影视剧台词 在线剪视频 Clipchamp FlexClip 测网速 检测陌生连接安全性 生成不存在人像头像 获取新奇的未知软件 得到 app ( 一个不错的 \" 搜索 + 学习 \" app ) ","date":"2023-10-31","objectID":"/zh-cn/search-technology/:0:1","tags":["search"],"title":"搜索技术","uri":"/zh-cn/search-technology/"},{"categories":["documentation"],"content":"more effective C++ 总结","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"基础议题 指针、引用、类型转换、数组、构造 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:0:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 1：指针与引用的区别 一个引用必须指向某个对象，任何情况下都不可以使用指向空值的引用。设计不允许变量为空时，可以把变量声明为引用。 不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。 指针可以被重新赋值以指向另一个不同的对象，引用则总是指向在初始化时被指定的对象，以后不能改变。 使用指针的情况： 考虑到存在不指向任何对象的可能 ( 在这种情况下，你能够设置指针为空 )。 需要能够在不同的时刻指向不同的对象 ( 在这种情况下，你能改变指的指向 )。 使用引用的情况： 总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。 当你重载某个操作符时，你应该使用引用。如何操作符[ ]返回对象引用 总结 当你知道你必须指向一个对象并且不想改变其指向时, 或者在重载操作符并为防止不必要的语义误解时，你不应该使用指针。而在除此之外的其他情况下，则应使用指针。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:1:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 2：尽量使用 C++ 风格的类型转换 C++ 四种类型转换操作符：static_cast，const_cast，dynamic_cast，和 reinterpret_cast。 使用格式：操作符\u003c要转换的类型\u003e(表达式)–\u003e表达式括号必需。 reinterpret_cast 使用这个操作符的类型转换，其转换结果几乎都是执行期定义 （ implementation-defined ）。因此 ，使用reinterpret_casts 的代码很难移植。 总结 新的类型转换符缺乏美感才能使它弥补了在含义精确性和可辨认性上的缺点，使用新类型转换符的程序更容易被解析，它们允许编译器检测出原来不能发现的错误。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:2:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 3：不要对数组使用多态 通过一个基类指针来删除一个含有派生类对象的数组，结果将是不确定的。 在基类内操作基类对象数组时的大小是确定的，而在使用基类指针操作派生类对象数组时则会因派生类对象大小发生改变，从而无法确定对象数组的大小。 class Base{...} class Derived : public Base{...} void Base::printarry(\u0026ostream o, Base arr[], int n) { for(int i = 0; i\u003c n; ++i) o\u003c\u003c arr[i]; } Base b[10]; printarry(cout,b,10);// n 的值是正确的 Derived d[10]; printarry(cout,d,10);//因派生类对象大小发生改变，从而导致 n 的计算错误 多态和指针算法不能混合在一起来用，所以数组与多态也不能用在一起，因为数组调用的本质是调用指针。 是如果你不从一个具体类（concrete classes），派生出另一个具体类，那么你就不太可能犯这种使用多态性数组的错误。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:3:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 4：避免无用的缺省构造函数 如果一个类没有缺省构造函数，则无法直接建立该类的对象数组，也不可以使用非堆数组 ( new 数组 )。 class Obj { public: Obj(int n):num(n){}//没用默认构造函数 private: int num; } Obj arr[10];//没有默认构造函数，无法直接建立数组 Obj arr[10] = {Obj(1),Obj(2)...};//可行，不过数组大时不现实 Obj *ptr = new Obj[10]; //没有默认构造函数，无法建立堆数组 可以指针方式避免调用构造函数。这种方法有两个缺点，第一你必须删除数组里每个指针所指向的对象。如果你忘了，就会发生内存泄漏。第二增加了内存分配量，你需要空间来容纳指针。 typedef Obj* objarr; objarr arr[10];//可行，没用调用构造函数 objarr *ptr = new objarr[10];//可行 为数组分配 raw memory ( 原始内存 )，可以避免浪费内存。使用 placement new 方法在内存中构造对象。 //operator new 函数 void *rawmemery = operator new( 10*sizeof(Obj)); Obj *best = static_cast\u003cObj*\u003e(rawmemery); //使用 placement new for (int i = 0; i \u003c 10; ++i) new(\u0026best[i])Obj(num); 使用 placement new 的缺点：当你不想让它继续存在使用时，必须手动调用数组对象的析构函数，然后调用操作符 delete[ ] 来释放 raw memory。 for (int i = 9; i \u003e= 0; --i) best[i].~Obj(); //析构对象 operator delete[](rawmemery); //回收内存 对于类里没有定义缺省构造函数所造成的第二个问题是它们无法在许多基于模板（template-based ）的容器类里使用。 在多数情况下，通过仔细设计模板可以杜绝对缺省构造函数的需求。 设计虚基类时所面临的要提供缺省构造函数还是不提供缺省构造函数 几乎所有的派生类在实例化时都必须给虚基类构造函数提供参数。 这就要求所有由没有缺省构造函数的虚基类继承下来的派生类(无论有多远)都必须知道并理解提供给虚基类构造函数的参数的含义。 提供无意义的缺省构造函数也会影响类的工作效率。 如果成员函数必须测试所有的部分是否都被正确地初始化，那么这些函数的调用者就得为此付出更多的时间。 使用这种（没有缺省构造函数的）类的确有一些限制，但是当你使用它时，它也给你提供了一种保证：你能相信这个类被正确地建立和高效地实现。 运算符 重载的运算符何时并且如何被调用，它们如何运作，它们应该如何彼此联系，以及如何获得这些方面的控制权。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:4:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 5：谨慎定义类型转换函数 C++ 编译器能够在两种数据类型之间进行隐式转换（implicit conversions）。 C++ 编译器会为内置数据类型之间进行自动的隐式转换。继承于 C 语言。 自定义类型时，可以控制选择是否提供函数让编译器进行隐式类型转换。 有两种函数允许编译器进行这些的转换： 单参数构造函数（ single-argument constructors）。 隐式类型转换运算符。即：operator 目标转换type() 注：单参数构造函数是指只用一个参数即可以调用的构造函数。该函数可以是只定义了一个参数，也可以是虽定义了多个参数但第一个参数以后的所有参数都有缺省值。 可以克服隐式类型转换运算符的缺点 – 它们的存在将导致错误的发生： 通过不声明运算符（operator）的方法。 防止编译器不加鉴别地调用单参数构造函数进行类型转换方法： 构造函数名字前加 explicit 关键字。 编译器不支持关键字 explicit 时，则不声明单一参数构造函数。 将单一单数用 proxy classes ( 代理类 ) 代替，可以阻止发生调用单一参数构造函数。 ( 编译器只能进行最多一次隐式类型转换。) ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:5:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别 前缀形式返回一个引用，后缀形式返回一个 const 类型。 C++ 规定后缀形式有一个 int 类型参数，当函数被调用时，编译器传递一个 0 做为 int 参数的值给该函数。 class Obj { public: Obj operator ++ ()//前缀形式,返回对象引用 { *this += 1; return *this; } const Obj opertor ++ ( int )//后缀形式，返回一个const 值, {//加 const 是为了与内置类型相一致，内置类型不允许执行连续两次++, 如 i++++ //返回 const 对象的意义实例 Obj old = *this; *this += 1; return old; } } ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:6:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 7：不要重载 “\u0026\u0026”, “||”, 或 “,” C++ 使用布尔表达式短路求值法( short-circuit evaluation )。这表示一旦确定了布尔表达式的真假值，即使还有部分表达式没有被测试，布尔表达式也停止运算。 C++ 语言规范没有定义函数参数的计算顺序。 不能重载的运算符 \" . “、 \" . * “、 \" : : “、 \" ? : “、 new、 delete、 sizeof、 typeid、 static_cast、 dynamic_cast、 const_cast、 reinterpret_cast 在遇到 \" \u0026\u0026 “, \" || \" 和 \" , \" 时，找到一个好理由是困难的，因为无论你怎么努力，也不能让它们的行为特性与所期望的一样。 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:7:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 8：理解各种不同含义的 new 和 delete placement new ( 需要 include\u003cnew\u003e) 在已经被分配但是尚未处理的 ( raw ) 内存中构造一个对象。此时可使用一种特殊的 operator new，被称之为 placement new。见条款 4 placement new 使用 new 操作符（new operator）与 operator new 的关系： 在堆上建立一个对象，用 new 操作符，既分配内存又为对象调用构造函数。 仅分配内存，则该调用 operator new 函数；它不会调用构造函数。 定制自己的在堆对象被建立时的内存分配过程，写你自己的 operator new 函数，然后使用 new 操作符，new 操作符会调用你定制的 operator new。 在一块已经获得指针的内存里建立一个对象，应该用 placement new。 Deletion and Memory Deallocation 为了避免内存泄漏，每个动态内存分配必须与一个等同相反的 deallocation 对应。 Arrays new 和 delete 操作符是内置的，其行为不受你的控制，凡是它们调用的内存分配和释放函数则可以控制。 异常 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:8:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"条款 9：使用析构函数防止资源泄漏 ","date":"2023-11-02","objectID":"/zh-cn/more-effective-cpp/:9:0","tags":["C++","effective"],"title":"More effective C++ 总结","uri":"/zh-cn/more-effective-cpp/"},{"categories":["documentation"],"content":"C++ primer 第五版 ","date":"2023-10-31","objectID":"/zh-cn/cppprimer5/:0:0","tags":["C++"],"title":"C++ primer总结","uri":"/zh-cn/cppprimer5/"},{"categories":["documentation"],"content":"C++ primer 第五版","date":"2023-10-31","objectID":"/zh-cn/cppprimer5/:0:1","tags":["C++"],"title":"C++ primer总结","uri":"/zh-cn/cppprimer5/"},{"categories":["Documentation"],"content":"这篇文章是对effective c++ 的总结.","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"luckfalcon 的 github page C++编程注意条款 拷贝构造函数与拷贝赋值运算符 拷贝构造函数 : 初始化 –\u003e A(B) –\u003e 只发生在对象创建时 拷贝赋值运算符 : 同类型对象值赋值给创建对象 –\u003e A=B 值传递与引用传递 值传递 ( pass-by-value ) : 调用构造函数 引用传递 (passed-by-reference) : 不调用构造函数 C++ 包含四大次级语言 c 语言部分编程 、class 类编程、template 模板编程、STL 标准库编程。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:0:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款2：尽量以 const，enum，inline 替换 #define #define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。 #define max(a,b) f((a) \u003e (b)? (a) : (b)) int a = 5,b = 0; max(++a, b); //a被累加2次 max(++a, b+10); //a被累加1次 enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。 class Test { static const int num = 1;//此处仅为声明而非定义 int arr[num]; }; const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class Test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; }; 小结 const 对象替换 define 常量 inline 函数替换 define 形似函数 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:1:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款3：尽可能使用 const 令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性 //有理数operator* class Rational{} const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs); //可以避免客户暴力行为如: Rational a,b,c; (a * b) = c;//在a*b的结果上调用赋值运算符operator = const 成员函数，可确保类的 const 对象可被操作 如过函数的返回类型是内置类型，改动函数返回值是非法的 class text { public: const \u0026char operator[](std::size_t position)const//处理const对象，不可修改对象 {return st[position];} \u0026char operator[](std::size_t position)//处理非const对象,可修改对象 {return st[position];} private: std::string st; }; 将类成员声明为 mutable 类型，可以实现在 const 对象内修改对象的值，但并能完全解决 const 与 non-const 的全部问题。 class Text { public: std::size_t length()const; private: char *ptex; mutable std::size_t textlength;//这些变量可以被修改，即使在const对象内部 mutable bool LengthIsValid; }; std::size_t Text:: length()const { if(!LengthIsValid) { textlength = strlen(ptex); LengthIsValid = true; } return textlength; } 在 const 和 non-const 成员函数中避免重复使用，策略是利用 non-const 调用 const 的版本来实现。 char operator[](std::size_t position) { return const_cast\u003cchar \u0026\u003e( //将op[]返回值去除const static_cast\u003cconst text \u0026\u003e(*this)//为this加上const，调用const op[] )//若不给this加const，则会无限递归自己 } 小结 将某些东西声明为 const 可以帮助编译器检查错误用法。const 可以被加在任何作用域内的对象、函数参数、函数返回类型、成员函数。 编译器强制 bitwise constness (位常量性)，但你编程时应使用 “概念上的常量性” ( conceptual constness ) 。 当 const 函数与 non-const 函数有等价的实现时，用 non-const 版本调用 const 版本可避免代码重复。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:2:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款4：确定对象被使用前已先被初始化 未初始化对象可导致未定义行为 ( undefined behavior )，最终导致程序错误。 永远在对象使用之前对其初始化，内置类型直接初始化，类类型由其构造函数完成初始化 ( 类成员初始化发生在构造函数体之前，构造函数体内为赋值，初始化类成员应使用类成员初始化列表 ) class Obj { public: Obj(int i_nit,char c_init,const string \u0026s_init) :i(i_nit),c(c_init),s(s_init){}//初始化，通常效率更高 Obj(int i_nit,char c_init,const string \u0026s_init) { i = i_nit;//赋值，会先调用default构造函数，再进行拷贝赋值= c = c_init; s = s_init; } private: int i; char c; string s; }; c++ 对 \" 定义于不同编译单元内的 non-local static 对象 \" 的初始化次序并无明确定义。通过设计消除这种情况，做法是，将每个 non-local static 对象搬到自己的专属函数内 ( 该对象在此函数内被声明为 static ) 。这些函数返回一个 reference 指向它所含的对象。用户调用这些函数获得 static 对象的引用，而非直接使用 static 对象本身。 编译单元 ( translation unit ) 是指产出单一目标文件 ( sigle object file ) 的源码。基本上它是单一源码文件加上其所含入的头文件 ( #include file )。 class Ob1 { public: Ob1 \u0026obj( )//在类外定义为内联函数 { static Ob1 ob; return ob;//指向static对象的reference，而不再使用static对象自身 } }; 小结 内置类型手动初始化。 构造函数使用成员的初始化列表初始化，而非构造函数体内进行赋值，成员初始化次序最好与声明次序相同。 为免除\"跨编译单元初始化次序\"问题，以 local static 对象替换 non-local static 对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:3:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款5：了解c++默默写并调用哪些函数 空类，编译器默认生成一个无实参的 default 构造函数、一个有实参拷贝构造函数、一个拷贝赋值运算符、一个析构函数。 用户自定义构造函数后，default 构造函数不指定则编译器不再提供。 对于成员类型为引用的类，编译器默认不生成拷贝赋值运算符 ( 原因是 c++不允许改变引用的对象 ) 。 小结 编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assighnment 操作符，以及析构函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:4:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款6：若不想使用编译器自动生成的函数，就该明确拒绝 为了阻止类的拷贝赋值行为，你可以通过继承一个基类的拷贝复制操作是 private 的类来实现。 class Uncopy { public: Uncopy(); ~Uncopy();//由于非虚函数，会带来多重继承的问题 private: Uncopy(const Uncopy\u0026); Uncopy \u0026operator = (const Uncopy\u0026); }; class Obj:private Uncopy{};//此时class Obj不再声明copy函数或copy assighnment操作符 小结 为阻止编译器自动提供的功能，可将相应的成员函数声明为 private 并且不予实现，如 uncopy 基类的做法。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:5:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款7：为多态基类声明 virtual 析构函数 class Base { public: Base(); virtual function();//带有虚成员函数的类才需要虚析构函数 virtual ~Base();//析构函数声明为虚函数 } class DerivedA:public Base{}; class DerivedB:protected Base{}; class DerivedC :private Base{}; 每个带有 virtual 函数的 class 都有一个相应的 vtbl ( virtual table ) ，在运行时，由 vptr ( virtual table pointer ) 指出，从而实现带 virtual 函数。将不含 virtual 函数的类的析构函数声明为 virtual 会影响类的可移植性。 基类的析构函数非 virtual 的时，不要使用基类指针指向派生类，否则在销毁基类指针时无法调用派生类的析构函数，从而造成内存泄漏。 pure virtual 析构函数的类为抽象类，无法实例化，只适合做基类。 class Obj { public: virtual ~Obj() = 0;//纯虚函数,该类为抽象类，无法实例化，只适合做基类 }; Obj::~Obj(){};//纯虚函数的定义,不做这个定义，连接器会出错 并非所有的基类设计都是为多态用途，即不是所有的基类都需要 virtual 析构函数。 小结 polymorphic ( 带有多态性质的 ) base classes应该声明一个 virtual 析构函数。如何 class 带有 virtual 函数，那么应该声明 virtual 析构函数。 classes 的设计目的如果不是作为 base classes 使用，或者不是为了具备多态性 ( polymorphically ) ，就不应该声明 virtual 析构函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:6:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款8：别让异常逃离析构函数 c++不希望在类的析构函数中抛出异常 ( 这会导致一些容器由于多个类对象析构异常而导致不明确行为 ) 转接给客户一次处理异常的机会 class Obj { public: static obj create();//返回一个obj对象 void closed();//关闭，失败会抛出异常 }; class Manageobj { public: void closed() { closed();//非析构函数抛出异常可供用户选择处理,若在析构函数内，用户无法处理，只能选择终止或者忽略异常 closed = true; } ~Manageobj() { if(!closed) { try { closed(); } catch() { //记录close调用失败 }; } } private: Obj oj; bool closed; }; 小结 析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们 ( 阻止不传播 ) 或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通的函数 ( 而非在析构函数中 ) 执行该操作。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:7:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款9：绝不在构造和析构过程中调用 virtual 函数 小结 在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class ( 比起当前执行构造函数和析构函数的那层 ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:8:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款10：令operator = 返回一个reference to *this class Obj { public: Obj \u0026operator = (const Obj\u0026rhs) { //... return *this; }//为了实现 x = y = z = Value; }; 小结 令赋值 ( assignment ) 操作符返回一个 reference to *this。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:9:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款11：在 operator = 中处理 \" 自我赋值 \" 让 operator = 具备 \" 异常安全性 \" 同时也会获得 \" 自我赋值安全 \" 。 class Op{}; class Obj { public: private: Op *ptr; //类成员含有指针或引用 }; Obj \u0026Obj::operator = (const Obj \u0026rhs) { Op *p = ptr; //记住原先的ptr ptr = new Op(rhs.ptr);//令ptr指向*ptr的一个副本 delete p; //删除原先的ptr return *this; } 复制交换 ( copy and swap ) 技术，可以作为上述方案的替代方案。 class Op{}; class Obj { public: void swap(Obj \u0026rhs); private: Op *ptr; //类成员含有指针或引用 }; Obj \u0026Obj::operator = (const Obj \u0026rhs) { Op temp(rhs);//将rhs数据制作一份副本 swap(temp);//将*this数据和上述副本的数据交换 return *this; } //值传递(passed by value)--有时候可令编译器生成高效的代码 Obj \u0026Obj::operator = (Obj rhs) { swap(ths); return *this; } 小结 确保当对象自我赋值时 perator = 有良好的行为。其中的技术包括比较 \" 来源对象 \" 和 \" 目标对象 \" 的地址、精心周到的语句顺寻、以及 copy-and-swap。 确定任何函数如何操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:10:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款12：复制对象时勿忘其每一个成分 derived class 的 base class 成分在 derived class 的构造函数中应调用 base class 的构造函数完成。 不应该令 copy assignment 操作符调用 copy 构造函数，反之也同样没有意义。 如果 copy assignment 操作符和 copy 构造函数有相同重复的代码，通常在 private 区设置一个 init 函数将相同部分代码包含进去。 小结 copy函数 ( copy assignment 操作符和 copy 构造函数统称 ) 应该确保复制 \" 对象内的所有成员变量 \" 及 \" 所有 base class 成分 \" 。 不要尝试以某个 copy 函数实现另一个 copy 函数。应该将共同机能放进第三个函数中，并由两个 copy 函数共同调用。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:11:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款13：以对象管理资源 获取资源后立即放进管理对象内，管理对象运用析构函数确保资源被释放。以对象管理资源常被称为资源取得时机便是初始化时机 ( Resource Acquisition Is Initialization, RAII ) 。 class Obj { public: Obj *create(); }; void f() { //c++11后已经弃用auto_ptr,用unique_ptr代替 //这样做的前提是绝对没有一个以上的auto_ptr同时指向该对象 std::auto_ptr\u003cObj\u003ep_Obj(create());//auto_ptr为一个类指针对象模板 //... } auto_ptrs 一个特殊性质：若通过 copy assignment 操作符和 copy 构造函数复制它们，它们会变成 null，而复制所得的指针将取得资源的唯一拥有权。 { std::auto_ptr1\u003cObj\u003ep_Obj(create());//ptr1指向create返回对象 std::auto_ptr2(ptr1); //ptr2指向该对象，ptr1被置为null ptr1 = ptr2; //ptr1指向该对象，ptr2被置为null } 克服 auto_ptr 的弊端，改用引用计数智能指针 ( reference-counting smart pointer,RCSP )，如 shared_ptr。 没有针对 \" c++动态分配数组 \" 的智能指针，因为 vector 和 string 几乎可以完全代替动态分配数组。 小结 为防止资源泄露，请使用 RAII 对象，它们在构造函数中获取资源并在析构函数中释放资源。 两个常用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr ( c++11 后用 unique_ptr ) 。前者通常是最佳选择，因为其 copy 行为比较直观。若选择 auto_ptr，复制动作会使它 ( 被复制物 ) 指向 null。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:12:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款14：在资源管理类中小心 copying 行为 小结 复制 RAII 对象必须一并复制它所管理的资源，所以资源的copying行为 ( 通常需要深拷贝 ) 决定 RAII 对象的 copying 行为。 普通而常见的 RAII class copying 行为：抑制 copying、(可用 shared_ptr) 施行引用计数方法 ( reference counting ) 。不过其他行为也都可能实现。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:13:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款15：在资源管理类中提供对原始资源的访问 小结 APIs 往往要求访问原始资源 ( raw resources )，所以每个 RAII class 应该提供一个 \" 取得其所管理之资源 \" 的办法。 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:14:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款16：成对使用 new 和 delete 时要采用相同形式 小结 new 表达式中使用 [ ]，必须在相应的 delete 表达式中也使用 [ ]。new 表达式中不使用 [ ]，一定不要在相应的 delete 表达式中使用 [ ]。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:15:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款17：以独立语句将 newed 对象置入智能指针 class Obj{}; int func1(); void func2(shared_ptr\u003cobj\u003e,int); func2(shared_ptr\u003cobj\u003e(new obj),func1()); //此处编译器要进行三个过程，new Obj、调用shared_ptr初始化指针、调用func1, //但三者没有固定顺序，若func1发生在其它两个过程之间，且发生异常，则会导致new Obj发生泄漏 小结 以独立语句将 newed 对象存入 ( 置入 ) 智能指针内。如果不这样，一旦异常被抛出，有可能导致难以察觉的资源泄漏。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:16:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款18：让接口容易被正确使用，不易被误用 尽量让你的 types 的行为与内置 types 一致。 返回 shared_ptr 让接口设计者得以阻止大部分资源泄漏错误。 智能指针管理非 new 的资源时需要手动传入一个删除器。 小结 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达到这个性质。 “促进争取使用\"的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用\"的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。 shared_ptr 支持定制型删除器 ( custom deleter )。这可防止 DLL ( 动态链接库 ) 问题，可被用来自动解除互斥锁 ( mutexes ) 等等。 所谓的 \" cross-DLL problem “，这个问题发生于 \" 对象在动态连接程序库 ( DLL ) 中被 new 创建，却在另一个 DLL 内被 delete 销毁 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:17:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款19：设计 class 犹如设计 type 新 class 设计规范问题： 新的 type 应该如何被创建和销毁？ 对象的初始化和对象的赋值该有什么样的差别？ 新 type 对象如果被 passed by value ( 以值传递 )，意味着什么？ 什么是新 type 的 \" 合法值 \" ？ 你的新 type 需要配合某个继承图系 ( inheritance graph ) 吗？ 你的新 type 需要什么样的转换？ 什么样的操作符和函数对此新 type 而言是合理的？ 什么样的标准函数应该驳回？ 谁该取用新 type 的成员？ 什么是新 type 的\"未声明接口”？ 你的新 type 有多么一般化？ 你真的需要一个新 type 吗？ 小结 class 的设计就是 type 的设计。在定义一个新type时请考虑以上问题。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:18:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value 缺省情况下 C++ 以 by value 方式传递对象至函数。 一般而言，pass by value 唯一对象是内置类型和 STL 的迭代器和函数对象。 小结 尽量以 passed-by-reference-to-const 替换 passed-by-value。前者通常高效，并可避免切割问题 (slicing problem)。 以上规则不适合内置类型，以及STL的迭代器和函数对象。对它们而已，passed-by-value往往比较适当。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:19:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款21：必须返回对象时，别妄想返回其 reference 一个 \" 必须返回新对象 \" 的正确写法： class Rational { public: Rational(int numerator = 0,int denominator = 1); private: int n;//分子(numerator) int d;//分母(denominator) friend const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.n*rhs.n,lhs.d*rhs.d); } }; 小结 绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:20:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款22：将成员变量声明为 private 小结 切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供 class 作者以充分的实现弹性。 protected 并不比 public 更具封装性。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:21:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款23：宁以 non-member、non-friend 替换 member 函数 将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以扩展这一组便利函数。 // class_def.h namespace name { class Obj { public: void fun1(); void fun2(); void fun3(); }; void do_fun1(Obj \u0026oj){oj.fun1();}//核心机能，包含客户都需要的non-member函数 void do_fun3(Obj \u0026oj){oj.fun3();}//非成员函数可以进一步提高class的封装性 } //fun1_use.h//客户扩展头文件 namespace name { void fun1(); } 小结 宁以拿 non-member、non-friend 替换 member 函数。这样可以增加封装性、包裹弹性 ( packaging flexibility ) 和机能扩充性。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:22:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款24：若所有参数皆需类型转换，请为此采用 non-member 函数 class Rational { public: Rational(int numerator = 0,int denominator = 1); int numerator()const; int denominator()const; private: int n;//分子(numerator) int d;//分母(denominator) }; //非成员友元函数声明方式 const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } 小结 如果你需要为某个函数的所有参数 ( 包括被 this 指针所指的那个隐喻参数 ) 进行类型转换，那么这个函数必须是 non-member 函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:23:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款25：考虑写出一个不抛出异常的 swap 函数 所有的 STL 容器都提供有一个 public swap 成员函数和 std::swap 特化版本 ( 用以调用前者 )。 c++ 只允许对 class template 偏特化 ( partially specialize )，但不能对 function template 偏特化。 c++ std 空间可以全特化所有内含 template，但不可以添加新的 template 进去。 namespace name_obj { class Obj { public: void swap(const Obj \u0026b){using std::swap;}; } void swap(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//合法 } namespace std//在std内特化 { template\u003c\u003e void swap\u003cObj\u003e(obj \u0026a,Obj \u0026b){a.swap(b);};//特例化某个类，合法 //Obj成为类模板的时 template\u003ctypename T\u003e void swap\u003cObj\u003cT\u003e\u003e(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//函数模板偏特化，错误，不合法 template\u003ctypename T\u003e void swap(Obj\u003cT\u003e \u0026a,Obj\u003cT\u003e \u0026b){a.swap(b);}//也不合法 } pimpl 是 “pointer to implementation” 的缩写。 swap 的版本包含，default swap (适合不含指针成员的类或类模板)、member swap、non-member swap、std::swap 特化版。 如果缺省 swap 效率不足 ( class 或 template 使用了某种 pimpl 手法 )，可试以下方法： 提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值。该函数不应抛出异常。 在你的 class 或 template 所在的命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。 如果你正编写一个 class ( 而非 class template )，为你的 class 特化 std::swap。并令它调用你的 swap 成员函数。 swap 一个最好的应用是帮助 classes( 和 class templates ) 提供强烈的异常 ( exception-safety ) 保障。 小结 当 std::swap 对你的类型效率不高时，提供一个成员 swap 函数，并确定这个函数不抛出异常。 如果你提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于 class ( 而非 template )，也请特化 std::swap。 调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何 \" 命名空间资格修饰 \" 。 为 \" 用户定义类型 \" 进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。 实现 (implementations) ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:24:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款26：尽可能延后变量定义式的出现时间 目的是减少不必要的对象构造和析构 class Obj{}; Obj oj; //A：1次构造+1次析构+n次赋值 for(int i;i \u003c n;++i) { oj = i; }; // for(int i;i \u003c n;++i) { Obj oj; //B：n次构造+n次析构，通常B比A更高效一点，除非，赋值比构造+析构成本低 oj = i; }; 小结 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:25:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款27：尽量少做转型动作 c++ 四类型转换形式 : const_cast(expression) dynamic_cast(expression) reinterpret_cast(expression) static_cast(expression) const 到 non-const 转换 运行时，安全向下类型转换 执行低级转型 除去 const 到 non-const 的转换，其他一般类型转换 小结 如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码内。 宁可使用 C++-style ( 新式 ) 转型，不要使用旧式转型。前者容易辨识出来，而且也比较有着分门别类的执掌。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:26:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款28：避免返回 handles 指向对象内部成分 小结 避免 handles ( 包括 references、指针、迭代器 ) 指向对象内部。遵守这个条款可以增加封装性，帮助 const 成员函数的行为像个 const，并将发生\"虚吊号码牌”( dangling handles ) 可能降到最低。 虚吊号码牌：使用已经销毁的对象的引用、指针或迭代器。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:27:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款29：为 \" 异常安全 \" 而努力是值得的 异常安全性两个条件： 异常抛出时，不泄漏任何资源。 异常抛出时，不允许数据败坏。 异常安全函数提供三种不同级别保证： 基本保证 强烈保证 不抛保证 异常抛出后，程序内所有事物保持有效状态，这些状态是未预知的|异常抛出后，程序状态不改变，回到被调用前状态 异常抛出后，程序状态不改变，回到被调用前状态 承诺不抛出异常，因其总能完成原有的功能。作用于内置类型所有操作应提供 nothrow 保证 小结 异常安全函数 ( Exception-safty functions ) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。 “强烈保证” 往往能够以 copy-and-swap 实现出来，但 \" 强烈保证 \" 并非对所有函数都可实现或具备现实意义。 函数提供 \" 异常安全保证 \" 通常最高只等于其所调用之各个函数的 \" 异常安全保证 \" 中的最弱者。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:28:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款30：透彻了解 inlining 的里里外外 inlining 在大多数 c++ 程序中是编译期行为。 inline 函数通常一定被置于头文件中，通常置于函数本体小的函数前，向编译器申请在调用处替换展开本体，但非强制命令，编译器可忽略。 对于函数本体较大的函数 inlining 会引发代码膨胀。 编译器通常不会对 \" 通过函数指针而进行的调用 \" 实施 inlining。 小结 将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 ( binary upgradability ) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为 function templates 出现在头文件，就将它们声明为 inline。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:29:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款31：将文件间的编译依存关系降至最低 将接口与实现分离。 编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其 他文件内的声明式 ( 而非定义式 ) 相依 – 该设计策略如下： 如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects。 如果能够，尽量以 class 声明式替换 class 定义式。 为声明式和定义式提供不同的头文件。 Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性 ( compilation dependencies ) 。 在 Handle classes 身上，成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。 至于 Interface classes，由于每个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃 ( indirect jump ) 成本 ( 见条款 7 ) 。 小结 支持 \" 编译依存性最小化 \" 的一般构想是: 相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。 程序库头文件应该以 \" 完全且仅有声明式 \" ( full and declaration-only forms ) 的形式存在。这种做法不论是否涉及 templates 都适用。 六、继承与面向对象 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:30:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款32：确定你的 public 继承塑模出 is-a 关系 以 C++ 进行面向对象编程，最重要的一个规则是：public inheritance ( 公有继承 ) 意味 \" is-a \" ( 是一种 ) 的关系。 is-a 并非是唯一存在于 classes 之间的关系。另两个常见的关系是 has-a ( 有一个 ) 和 is-implemented-in-terms-of ( 根据某物实现出 ) 。 小结 \" public 继承 \" 意味 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:31:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 33：避免遮掩继承而来的名称 内层作用域的名称会遮掩 ( 遮蔽 ) 外围作用域的名称。 编译器查找名称规则由内层作用域查找到名称后即停止查找，并不关注类型。 derived class 作用域被嵌套在 base class 作用域内。 小结 derived classes 内的名称会遮掩 base classes 内的名称。 在 public 继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数 ( forwarding functions ) 。 using 声明式和转交函数： class base{ public: virtual void fun1(int x);}; class derived1 : public base { public: using base::fun1; void fun1(); }; class derived1 : private base { public: virtual void fun1()//转交函数 { base::fun1(); } }; ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:32:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 34：区分接口继承和实现继承 pure virtual 函数有两个最突出的特性：它们必须被任何 \" 继承了它们 \" 的具象 class 重新声明，而且它们在抽象 class 中通常没有定义。 声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。 derived classes 继承其函数接口, 但 impure virtual 函数会提供一份实现代码, derived classes 可能覆写 ( override ) 它。 声明简朴的(非纯) impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。 声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。 pure virtual 函数 simple ( impure ) virtual 函数 non-virtual 函数 只继承接口 继承接口和一份缺省实现 继承接口和一份强制实现 \" 80 - 20 \" 法则：一个典型的程序有 80 % 的执行时间花费在 20 % 的代码身上 。 小结 接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。 pure virtual 函数只具体指定接口继承。 简朴的 ( 非纯 ) impure virtual 函数具体指定接口继承及缺省实现继承。 non-virtual 函数具体指定接口继承以及强制性实现继承。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:33:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 35：考虑 virtual 函数以外的其他选择 通过 Non-Virtual Interface 手法实现 Template Method 模式： class Base { public: int fun()const//这个no-virtual 函数为 virtual 函数的外覆器 (wrapper) { int relval=dofun(); return relval; } private: virtual int dofun()const{...}; }; 令客户通过 public non-virtual 成员函数间接调用 private virtual 函数 – 为 non-virtual interface ( NVI ) 手法。 derived classes 可重新定义继承而来的 private virtual 函数。 通过 Function Pointers 实现 Strategy 模式 通过 函数模板 function \u003c T \u003e 完成 Strategy 模式 trl1: :bind，可改变可调对象入口参数个数和顺序，同时返回一个新的可调对象。 古典的 Strategy 模式 (设计模式 ( design patterns ) ) 。 几种 virtual 函数替代方案如下： 使用 non-virtual interface ( NVI ) 手法，那是 Template Method 设计模式的一种特殊形式。它以 public non-virtual 成员函数包庄较低访问性 ( private 或 protected ) 的 virtual 函数。 将 virtual 函数替换为 \" 函数指针成员变量 “，这是 Strategy 设计模式的一种分解表现形式。 以 trl::function 成员变量替换 virtual 函数，因而允许使用任何可调用物 ( callable entity ) 搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。 将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 Strategy 设计模式的传统实现手法。 小结 virtual 函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式。NVI手法自身是一个特殊形式的 Template Method 设计模式。 将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public 成员。 trl::function 对象的行为就像一般函数指针。这样的对象可接纳 \" 与给定之目标签名式 ( target signature ) 兼容 \" 的所有可调用物 ( callable entities ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:34:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 36：绝不重新定义继承而来的 non-virtual 函数 derived classes 绝对不该重新定义一个继承而来的non-virtual 函数 ( 此处指的是 base class 析构函数 ) 。 小结 绝对不要重新定义继承而来的 non-virtual 函数。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:35:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 37: 绝不重新定义继承而来的缺省 ( 默认 ) 参数值 只能继承两种函数: virtual 和 non-virtual 函数。 virtual 函数系动态绑定 ( dynamically bound ) ，而缺省(默认)参数值却是静态绑定 ( statically bound ) 。 对象的所谓静态类型 ( static type ) ，就是它在程序中被声明时所采用的类型。 对象的所谓动态类型 ( dynamic tvpe ) 则是指 \" 目前所指对象的类型 “。 class base { public: virtual void set(base b = bs)const = 0;//带有默认参数 }； class derived:public base { public: virtual void set(base b = bs)const;//会出现重复定义 virtual void set(base b = ds)const;//默认参数不一样 virtual void set(base b)const;//动态绑定(base指针引用访问时)时才会继承base默认参数， //静态绑定(derived对象访问)时不会继承默认参数 }; 条款35列了不少 virtual 函数的替代设计，其中之一是 NVI ( non-virtual interface ) 手法令 base class 内的一个 public non-virtual 函数调用 private virtual 函 数，后者可被 derived classes 重新定义。 小结 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数一一你唯一应该覆写的东西一一却是动态绑定。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:36:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 38: 通过复合塑模出 has-a 或 \" 根据某物实现出 \" 复合 ( composition ) 是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系 复合 ( composition ) 这个术语有许多同义词，包括 layering ( 分层 ) ，constainment ( 内含 ) , aggregation ( 聚合 ) 和 embedding ( 内嵌 ) 。 应用域 ( appjicarion domain ) 与实现域 ( implementation domain ) 程序中的对象其实相当于你所塑造的世界中的某些事物 ( 如人、汽车 )，这样的对象属于应用域 ( appjicarion domain ) 部分。 其他对象则纯粹是实现细节上的人工制品(如缓冲区、互斥锁)，这些对象相当于你的软件的实现域。 当复合发生于应用域内的对象之间，表现出 has-a 的关系; 当它发生于实现域内则是表现 is-implemented-in-terms-of 的关系。 set 和 list 的关系非 is-a 关系，而是 is-implemented-in-terms-of 关系。 小结 复合 ( composition ) 的意义和 public 继承完全不同。 在应用域 ( application domain ) ，复合意味 has-a ( 有一个 )。在实现域 ( implementation domain ) ，复合意味 is-implemented-in-terms-of ( 根据某物实现出 ) 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:37:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 39: 明智而审慎地使用 Private 继承 Private 继承意味 is-implemented-in-terms-of ( 根据某物实现出 )。 尽可能使用复合，必要时才使用 private 继承。 private 继承主要用于 \" 当一个意欲成为 derived class 者想访问一个意欲成为 base class 者的 protected 成分，或为了重新定义一或多个 virtual 函数 “。 class empty{}; sizeof(empty) = 1; class derived:private empty { private: int x; }; sizeof(derived) == sizeof(int); //编译器 EBO (empty base optimization; 空白基类最优化)，一般发生在单一继承才可行，多继承则不会发生。 现实中的 \" empty \" classes 并不真的是 empty，往往内含 typedefs，enums， static 成员变量，或 non-virtual 函数。 许多技术用途的 empty classes，其中内含有用的成员 ( 通常是 typedefs )，包括 base classes unary_function 和 binary_function，这些是 \" 用户自定义之函数对象 \" 通常会继承的 classes。 小结 Private 继承意味 is-implemented-in-terms of ( 根据某物实现出 ) 。它通常比复合 ( composition ) 的级别低。但是当 derived class 需要访问 protected base class 的 成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。 和复合 ( composition ) 不同，private 继承可以造成 empty base 最优化。这对致力于 \" 对象尺寸最小化 \" 的程序库开发者而言，可能很重要。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:38:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 40: 明智而审慎地使用多重继承 多重继承 ( multiple inheritance；MI )，单一继承 ( single inheritance; SI ) 。 C++ 用来解析 ( resolving ) 重载函数调用的规则：在看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。 多重继承会导致二义性问题 ( 避免继承得来的成员变量重复 )，通常采用 virtual 继承: class derived:virtual public base1, virtual public base2{}; 小结 多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。 virtual 继承会增加大小、速度、初始化 ( 及赋值 ) 复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及 \" public 继承某个 Interface class \" 和 \" private 继承某个协助实现的 class \" 的两相组合。 七、模板与泛型编程 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:39:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 41：了解隐式接口和编译期多态 面向对象编程世界总是以显式接口 ( explicit interfaces ) 和运行期多态 ( runtime polymorphism ) 解决问题。 Templates 及泛型编程的世界以隐式接口 ( implicit interfaces ) 和编译期多态 ( compile-time polymorphism ) 为主。 小结 classes 和 templates 都支持接口 ( interfaces ) 和多态 ( polymorphism ) 。 对 classes 而言接口是显式的 ( explicit ), 以函数签名为中心。多态则是通过 virtual 函数发生于运行期。 对 template 参数而言，接口是隐式的 ( implicit ) ，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析 ( function overloading resolution ) 发生于编译期。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:40:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 42：了解 typename 的双重意义 C++ 有个规则可以解析 ( resoive ) 此一歧义状态：如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。 template 内出现的名称如果相依于某个 template 参数，称之为从属名称 ( dependent names ) 。 如果从属名称在 class 内呈嵌套状，我们称它为嵌套从属名称 ( nested dependent rame ) 。 只要在嵌套从属名称之前放置关键字 typename，即可告知解析器该名称为类型。 template\u003ctypename T\u003e typename T::const_iterator it();//告知解析器T::const_iterator 为类型 T t; //T 非嵌套从属名称 typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 mermber initialization list ( 成员初值列 ) 中作为 base class 修饰符。 template\u003ctypename T\u003e class derived:public base\u003cT\u003e::nested // base classes list { public: explicit derived(int x):base\u003cT\u003e::nested(x) //成员列表初始化 { typename base\u003cT\u003e::nested temp; //... } }; 小结 声明 template 参数时，前缀关键字 class 和typename 可互换。 请使用关键字 typename 标识嵌套从属类型名称; 但不得在 base class lists ( 基类列 ) 或 member initialization list ( 成员初值列 ) 内以它作为 base class 修饰符。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:41:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 43：学习处理模板化基类内的名称 模板化基类 ( templatized base classes )内的函数名称会被 derived classes 掩盖。 若基类模板存在特例化版本，则在 derived class template 的时候会发生编译错误，这时可以将 derived class template 涉及 base class template 的成员函数前加 \" this-\u003e \" 来指涉 base class template 内的函数。 小结 可在 derived class templates 内通过 \" this-\u003e \" 指涉 base class templates 内的成员名称，或通过一个明白写出的 \" base class 资格修饰符 \" 完成。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:42:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 44：将与参数无关的代码抽离 templates 共性与变性分析 ( commonality and variability analysis ) 小结 Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。 因非类型模板参数 ( non-type template parameters ) 而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。 因类型参数 ( type parameters ) 而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述 ( binary representations ) 的具现类型 ( instantiation types ) 共享实现码。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:43:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 45：运用成员函数模板接受所有兼容类型 如果以带有 base-derived 关系的 B, D 两类型分别具现化某个 template，产生出来的两个具现体并不带有 base-derived 关系。 Templates 和泛型编程 ( Generic Programming ) 泛化 ( generalized ) copy构造函数 template\u003ctypename T\u003e class SmartPtr { public: //泛化copy构造函数,并保证只根据U生成T对象,保证public继承的隐式转换 //泛化copy构造函数不等于copy构造函数，如果需要控制copy行为，还需自定义copy构造函数 SmartPtr(const SmartPtr \u0026sptr);//普通copy构造函数 template\u003ctypename U\u003e //泛化copy构造函数 SmartPtr(const SmartPtr\u003cU\u003e \u0026other):heldPtr(other.get()) {...} T *get()const {return heldPtr;} private: T *heldPtr; }; 小结 请使用 member function templates ( 成员函数模板 ) 生成 \" 可接受所有兼容类型 \" 的函数。 如果你声明 member templates 用于 \" 泛化 copy构造函数 \" 或 \" 泛化 assigmment操作 “，你还是需要声明正常的 copy 构造函数和 copy assigmmenmt 操作符。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:44:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 46：需要类型转换时请为模板定义非成员函数 在 function template 实参推导过程中从不进行隐式类型转换。 Class templates 并不倚赖 tetmplate 实参推导 ( 后者只施行于 function templates 身上 ) ，所以编译器总是能够在 class template 具现化时得知 T。 template\u003ctypename T\u003e class Rational//template class { public: Rational(T numerator = 0,T denominator = 1); T numerator()const; T denominator()const; friend const Rational operator*(const Rational \u0026lhs,const Rational \u0026rhs) { return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); }//定义在外部时，将只可通过编译却无法连接 private: T n;//分子(numerator) T d;//分母(denominator) }; 小结 当我们编写一个 class template，而它所提供之 \" 与此 template 相关的 \" 函数支持 \" 所有参数之隐式类型转换 \" 时，请将那些函数定义为 \" class template 内部的 friend 函数 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:45:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 47：请使用 traits classes 表现类型信息 STL 主要由 \" 用以表现容器、迭代器和算法 \" 的 templates 构成，以及若干工具性 templates。 STL 共有 5 种迭代器分类 Input 迭代器 Output 迭代器 Forward 迭代器 Bidirectional迭代器 Random access 迭代器 Istream_iterators Ostream_iterators 不支持linked list STL list, set, multiset, map, multimap 的迭代器 vector,deque, string 的迭代器 只能向前最多一次读操作 只能向前最多一次写操作 向前多次操作 可以向前移动，还可以向后移动 支持迭代器算术，双向 is-a关系： input、output forward : public input bidirectional : public forward random : public bidirectional advance(Iter, Disance) 设计并实现一个 traits class： 确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类 ( category ) 。 为该信息选择一个名称 ( 例如 iterator_category ) 。 提供一个 template 和一组特化版本 ( 例如稍早说的 iterator_traits ) ，内含你希望支持的类型相关信息。 如何使用一个 traits class： 建立一组重载函数 ( 身份像劳工 ) 或函数模板 ( 例如 doadvance ) ，彼此间的差异只在于各自的 traits 参数。令每个函数实现码与其接受之 traits 信息相应和。 建立一个控制函数 ( 身份像工头 ) 或函数模板 ( 例如 advance ) ，它调用上述那些 \" 劳工函数 \" 并传递 traits class 所提供的信息。 小结 Traits classes 使得 \" 类型相关信息 \" 在编译期可用。 它们以 templates 和 \" templates 特化 \" 完成实现。 整合重载技术 ( overloading ) 后，traits classes 有可能在编译期对类型执行 if…else 测试。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:46:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 48：认识 template 元编程 Template metaprogramming ( TMP，模板元编程 ) 是编写 template-based C++ 程序并执行于编译期的过程。 template metaprogram ( 模板元程序 ) 是以 C++ 写成、执行于 C++ 编译器内的程序。 //阶层(factorial)模板元编程,递归模板具现化实现循环 template\u003cunsigned n\u003e struct Factorial { enum{value = n*Factorial\u003cn-1\u003e::value}; } template\u003c\u003e struct Factorial\u003c0\u003e { enum{Value = 1}; } //main.cpp cout\u003c\u003cFactorial\u003c5\u003e::value\u003c\u003cendl;//计算5的阶层 小结 Template metaprogramming ( TMP，模板元编程 ) 可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。 TMP 可被用来生成 \" 基于政策选择组合 \" ( based on combinations of policy choices ) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 第八章 定制 new 和 delete ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:47:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 49：了解 new-handler 的行为 小结 set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具，因为它只适用于内存分配; 后继的构造函数调用还是可能抛出异常。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:48:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 50：了解 new 和 qelete 的合理替换时机 何时可在 \" 全局性的 \" 或 \" class 专属的 \" 基础上合理替换缺省的 new 和 delete: 为了检测运用错误。 为了收集动态分配内存之使用统计信息。 为了增加分配和归还的速度。 为了降低缺省内存管理器带来的空间额外开销。 为了弥补缺省分配器中的非最佳齐位 ( suboptimal atignment ) 。 为了将相关对象成簇集中。new 和 delete 的 \" placement 版本 \" ( 见条款52 ) 有可能完成这样的集簇行为。 为了获得非传统的行为。 小结 有许多理由需要写个自定的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:49:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 51：编写new 和 delete 时需固守常规 小结 OPerator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。Class 专属版本则还应该处理 \" 比正确大小更大的 ( 错误 ) 申请 \" 。 operator delete 应该在收到 null 指针时不做任何事。Class 专属版本则还应该处理 \" 比正确大小更大的 ( 错误 ) 申请 \" 。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:50:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款52：写了 placement new 也要写 placement delete 如果 operator new 接受的参数除了一定会有的那个 size_t 之外还有其他，这便是个所谓的 placerment new。 #include\u003cnew\u003e//标准库 static void* operator new(std: :size_t, void* PMemory) throw(); //纳入标准库内的pacement new //非标准 static void* operator new(std: :size_t, std::ostream \u0026) throw(std::bad_alloc); static void operator delete(void *, std::ostream \u0026) throw();//placement delete 缺省情况下 C++ 在 global 作用域内提供以下形式的 operator new： #include\u003cnew\u003e static void* operator new(std: :size_t)throw();//正常的new static void* operator new(std: :size_t, void *) throw();//placement new static void* operator new(std: :size_t, const std::nothrow_t \u0026) throw();//nothrow new 如果你在 class 内声明任何 operator news，它会遮掩上述这些标准形式。为使这些函数有着平常的行为，只要令你的 class 专属版本调用 global 版本即可： //将标准形式放在一个class中，然后让客户继承及using声明式取得标准形式 class standard { public: static void* operator new(std::size_t size)throw(std::bad_alloc) { return ::operator new(size);//分别调用标准形式 } ... } class wiget:public standard { public: using standard::operator new; //定义自己的operator new } 小结 当你写一个 placement operator new，请确定也写出了对应的 placerment operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明 placement new 和 placement delete，请确定不要无意识 ( 非故意 ) 地遮掩了它们的正常版本。 第九章杂项讨论 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:51:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 53：不要轻忽编译器的警告 警告信息天生和编译器相依，不同的编译器有不同的警告标准。 小结 严肃对待编译器发出的警告信息。努力在你的编译器的最高 ( 最严苛 ) 警告级别下争取 \" 无任何警告 \" 的荣誉 。 不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:52:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 54：让自己熟悉包括 TR1 在内的标准程序库 小结 C++ 标准程序库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。 TR1 添加了智能指针 ( 例如 trl: :shared_ptr ) 、一般化函数指针 ( trl: :function ) 、hash-based 容器、正则表达式 ( regular expressions ) 以及另外 10个组件的支持。 TR1 自身只是一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:53:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["Documentation"],"content":"条款 55：让自己熟悉 Boost Boost 是一个 C++ 开发者集结的社群, 也是一个可自由下载的 C++ 程序库群。boost网址 Boost Graph Library (用于编写任意 graph 结构)。 Boost MPL Library ( 一个元编程程序库，metaprogramming library )。 Boost 程序库内包含种类： 字符串与文本处理。 容器。 函数对象和高级编程。 泛型编程 ( Generic programming )。 模板元编程 ( Template metaprogramming，TMP ) 。 数学和数值 ( Math and numerics ) 。 正确性与测试 ( Correctness and testing ) 。 数据结构。 语言间的支持 ( Inter-language support ) 。 内存。 等等 小结 Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。 Boost 提供许多 TR1 组件实现品，以及其他许多程序库。 ","date":"2023-10-31","objectID":"/zh-cn/effective-cpp/:54:0","tags":["C++","effective"],"title":"Effective C++","uri":"/zh-cn/effective-cpp/"},{"categories":["documentation"],"content":"cmake 总结","date":"2023-11-10","objectID":"/zh-cn/cmake-sumary/","tags":["cmake"],"title":"Cmake 总结","uri":"/zh-cn/cmake-sumary/"},{"categories":["software"],"content":"Ubuntu(Linux) /Windows 配置 Linux 下编译运行命令 #切换至构建目录并编译文件 cd build cmake .. make #运行 ./demo #可执行文件名 Windows 下编译运行命令 cd build cmake -G \"MinGW Makefiles\" .. #指定生成编译文件类型为makefile，否则会调用vs编译成vs文件 mingw32-make.exe #生成可执行文件 launch.json { \"configurations\": [ { \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/demo\", #调试可执行文件所在路径及名字 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true }, { \"description\": \"Set Disassembly Flavor to Intel\", \"text\": \"-gdb-set disassembly-flavor intel\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Build\", #调试前预处理生产可执行文件 \"miDebuggerPath\": \"/usr/bin/gdb\" #调试器运行路径 } ] } tasks.json { \"version\": \"2.0.0\", \"options\": { \"cwd\": \"${workspaceFolder}/build\" #项目构建路径 }, \"tasks\": [ { \"type\": \"shell\", \"label\": \"cmake\", \"command\": \"cmake\", \"args\": [ \"..\" #cmake 工程路径 ] }, { \"label\": \"make\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, #\"command\":\"mingw32-make.exe\", \"command\":\"make\", #linux 下为 make, windows 下为 mingw32-make.exe \"args\": [ ] }, { \"label\": \"Build\", \"dependsOrder\": \"sequence\",//按列出的顺序执行任务P \"dependsOn\":[ \"cmake\", \"make\" ] } ] } ","date":"2024-01-22","objectID":"/zh-cn/vscode-config/:1:0","tags":["vscode"],"title":"Vscode运行配置","uri":"/zh-cn/vscode-config/"},{"categories":["Documentation"],"content":"设计模式 设计模式 面向对象编程优点： 可维护 可复用 可扩展 灵活性好 面向对象三大特性：封装、继承、多态降低程序的耦合度 业务逻辑和界面逻辑分开降低两者间度耦合度 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:0:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"UML类图 用一个单独的类来创造实例的过程，这个类就是简单工厂类。 UML类图\rUML类图是一种强大的工具，可用于可视化和传达软件系统的结构和关系。 类图分三层： 类名(抽象类用斜体) 类的特性(通常是字段和属性) 类的操作(通常是方法和行为) 注意: ‘+’ 表示 pubilc, ‘-’ 表示 private, ‘#’ 表示 protected。 接口图 与类图区别在于顶端有 « interface »显示。 « interface » 接口名称 接口方法 还有一种表示方法叫做棒棒糖表示法。 继承关系用空三角 + 实线来表示。 实现接口用空三角 + 虚线来表示。 关联关系用实线箭头表示。 聚合 : 表示一种弱的”拥有“关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分。空心菱形 + 实心箭头表示。 合成(组合) : 是一种强的\"拥有\"关系，体现了严格的部分与整体关系，部分和整体的生命周期一样。实心菱形 + 实心箭头表示。合成关系两端各有一个基数表示该端可以有几个实例。 依赖关系用虚线箭头表示。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:1:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"策略模式 它定义了一个算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法到用户。 策略模式结构\r它允许在运行时选择算法的行为，而不是在编译时固定使用特定算法。该模式属于行为型设计模式，它通过将一组算法封装在可互换的策略对象中，以使算法的选择和使用与客户端代码解耦。 策略模式到核心是实现算法的封装 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:2:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"单一职责原则(SRP) 就一个类而言，应该仅有一个引起它变化的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到当破坏。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。 如果你能想到多于一个动机去改变一个类，那么这个类就具有多于一个职责，就应该考虑类的职责分离。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:3:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"开放-封闭原则(开-闭原则，OCP) 开放-封闭原则，是说软件实体(类、模板、函数等等)应该可以扩展，但是不可修改。即，对于扩展是开放的，对于更改是封闭的。 无论模块是多么\"封闭\"，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须猜测出最有可能发生的变化种类(这种方式不太现实)，然后构造抽象来隔离那些变化。 在我们最初编写代码时，假设变化不发生。当变化发生时，我们就创建抽象来隔离以后发生同类的变化。 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那部分做出抽象，然而，对于应用程序中的每个部分都时刻地进行抽象同样不是一个好主意。拒绝不成熟地抽象和抽象本身一样重要。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:4:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"依赖倒转原则 依赖倒转原则： 高层模块不应该依赖低层模块。两个都应该依赖抽象。 抽象不应该依赖细节。细节应该依赖抽象。 抽象不应该依赖细节，细节应该依赖于抽象。即应针对接口编程，不应该对实现编程。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:5:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"里氏代换原则(LSP) 里氏代换原则:子类型必须能够替换掉它的父类型。即，在软件里面，把父类都替换称它的子类，程序行为没有变化。 只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类基础上增加新的行为。 依赖倒转其实可以说是面向对象设计的标志，用哪些语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象设计，反之那就是过程设计。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:6:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"装饰模式 装饰模式(Decorator): 动态地给一个对象添加额外的职责，就增加功能来说，装饰模式比生成子类更灵活。 装饰模式结构\r装饰模式是利用 SetComponent 来对对象进行包装。 每个装饰对象和如何使用这个对象分离，每个装饰对象只关心自己的功能，不需要关心如何添加到对象链当中。 装饰模式，把每个要装饰到功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需求有选择地、按顺序地使用装饰功能包装对象了。 如果只有一个 ConcreteComponent 类而没有抽象的 Component 类，那么 Decorator 类可以是 ConcreteComponent 的一个子类。同样道理，如果只有一个 ConcreteDecorator 类，那么没必要建立一个单独 Decorator 类，可以把 Decorator 和 ConcreteDecorator 的责任合并为一个类。 装饰模式的优点: 把类中的装饰功能从类中搬移去除，这样可以简化原有的类。 把核心职责和装饰功能分开来，而且可以去除相关类中重复的装饰逻辑。 装饰模式的装饰顺序很重要。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:7:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"代理模式 代理模式(Proxy)，为其他对象提供一种代理以控制对这个对象的访问。 代理模式结构\r代理模式应用 远程代理 为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。如 webservice 虚拟代理 根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。如 HTML 安全代理 用来控制真实对象访问时的权限。 智能指引 当调用真实对象时，代理处理另外一些事。 代理模式就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:8:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"工厂方法模式 简单工厂 VS 工厂方法模式 简单工厂模式最大的优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关类，对于客户端来说，去除类与具体产品的依赖。 工厂方法模式: 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 工厂方法模式结构\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:9:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"原型模式 原型模式(Prototype),用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 c++11新特性，协变返回类型 原型模式结构\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:10:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"模板方法模式 当我们要完成在某一细节层次一致一个过程或一系列步骤，但其个别步骤在更详细的层次上实现可能不同时，我们通常考虑使用模板方法模式处理。 模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法结构即可重新定义该算法到某些特定步骤。 模板方法模式\r","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:11:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"迪米特法则(LoD) 迪米特法则(LoD): 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类某一个方法的话，可以通过第三者转发这个调用。 在类的结构设计中，每一个类都应当尽量降低成员的访问权限。 迪米特法则的根本思想，是强调类之间的松耦合。 类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的造成波及。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:12:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"外观模式(Facade) 外观模式(Facade): 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式结构\r在设计初期阶段，应该要有意识的将不同的两个层分离，层与层之间建立外观 Facade。 在开发阶段，子系统往往经过不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少它们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，为新系统开发一个外观 Facade 类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与 Facade 对象交互，Facade 与遗留代码交互所有复杂的工作。 外观模式体现了依赖倒置原则和迪米特法则。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:13:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"建造者模式(Builder) 建造者模式(Builder): 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式结构\r建造者模式用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂变化。 建造者模式，使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若要改变一个产品的内部表示，只需要再定义一个建造者即可。 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:14:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"观察者模式(Observer) 观察者模式(Observer) 又叫 发布-订阅(Publish/Subscribe)模式。 观察者模式(Observer)：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象(抽象通知者)在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 观察者模式结构\r动机： 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要要维护相关对象的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用带来不便。 应用场景： 当一个对象改变需要同时改变其他对象，而它不知道具体有多少对象有待改变，应该使用观察者模式。 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的中使它们各自独立的改变和复用。 观察者模式所做的工作其实就是在解除耦合。让耦合双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 事件委托实现 事件委托产生的动机： 现实中，“抽象通知者\"由于不希望依赖\"抽象观察者”，所以\"增加\"和\"减少\"的方法就没必要了(即抽象观察者已经不存在了)。 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的\"类\"，委托的实例代表一个具体的函数。 一个委托可以搭载多个方法，所有方法被依次唤起。它可以使委托对象所搭载的方法并不需要属于同一个类。 委托对象所搭载的所有方法必须具有相同的原形和形式，也就是具有相同的参数列表和放回值类型。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:15:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"抽象工厂方法(Abstract Factory) 抽象工厂方法(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 抽象工厂方法结构\r抽象工厂的优缺点 优点： 易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实现过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。 缺点： 如果需求来自增加功能，则需要改变的类较多。 简单工厂改进抽象工厂 用反射加抽象工厂 编程方式：依赖注入(Dependency Injection) 反射技术使用格式：Assembly.Load(“程序集名称”).CreateInstance(“命名空间.类型名称”) 所有用简单工厂的地方，都可以考虑用反射技术来去除 switch 或 if，解除分支判断带来的耦合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:16:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"状态模式(State) 状态模式(State)：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像似改变了其类。 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 状态模式结构\r状态模式好处： 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。 将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在某个 ConcreteState 中，所以通过定义新的子类可以很容易的增加新的状态和转换。 消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到 State 的子类中,来减少相互间的依赖。 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:17:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"适配器模式(Adapter) 适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 当系统的数据和行为都正确，但接口不符合，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。 适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。 适配器模式分为：类适配器模式和对象适配器模式。 类适配器：通过多重继承对一个接口与另一个接口进行匹配。(C#、Java、VB.Net不支持多重继承,即它们要求一个类只有一个父类) 对象适配器结构\r使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不同时，应该考虑用适配器模式。 两个类所做的事情相同或相似，但是具有不同的接口时要使用它。 客户代码可以统一调用同一接口，可以更简单、更直接、更紧凑。 在双方都不太容易修改的时候，再使用适配器模式适配。而不是一有不同就使用它。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:18:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"备忘录模式(Memento) 备忘录模式(Memento)：在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。 备忘录模式结构\rMemento 模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，需要保存的属性只是众多属性中的一小部分时，Originator 可以根据保存的 Memento 信息还原到前一状态。 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以复杂的对象内部信息对其他的对象屏蔽起来。 当角色的状态改变的时候，有可能这个状态无效，这个时候就可以时候暂时保存起来的备忘录将状态复原。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:19:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"组合模式(Composite) 组合模式(Composite)：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式结构\r透明方式与安全方式 透明方式：在 Component 中声明所有用来管理子对象的方法，其中包括 Remove,Add 等。这样实现的 Component 接口的所有子类都具备了 Add 和 Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。缺点，Leaf 类本身不具备 Add 和 Remove 方法的功能，实现它没有意义。 安全方式：在 Component 中不去声明 Remove,Add 方法，那么子类 Leaf 也就不需要去实现它，而是在 Composite 声明所有用来管理子类对象的方法，由于不够透明，所以树叶和树枝类将不具备相同的接口，客户端调用需要做相应的判断，带来不便。 需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式。 组合模式包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断的递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象。 用户不需要关心到底是处理一个叶节点还是一个组合组件，也就用不着为定义组合而写一些选择判断语句了。 组合模式让客户可以一致地使用组合结构和单个对象。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:20:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"迭代器模式(Iterator) 迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中每个元素，而又不暴露该对象的内部表示。 当你访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式。 你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。 迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。(c# Java等已经将该模式集成在语言内部了，foreach 算法) 迭代器模式结构\r迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合内部结构，又可让外部代码透明的访问集合内部的数据。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:21:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"单例模式(Singleton) 单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认构造方法就会消失。 通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。 单例模式结构\r单例模式因为 Singleton 封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。 多线程时的单例模式，通常会加进程锁 lock，lock 是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待，直到对象被释放。 静态初始化的方式在自己被加载时就将自己实例化，称之为饿汉式单例类。不存在多线程安全问题。 要在第一次被引用时，才会将自己实例化，称之为懒汉式单例类。存在多线程安全问题。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:22:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"合成/聚合复用原则 对象的继承关系是在编译时就定义好的了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。 合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。 聚合 : 表示一种弱的”拥有“关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分。 合成 : 是一种强的\"拥有\"关系，体现了严格的部分与整体关系，部分和整体的生命周期一样。 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控的庞然大物。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:23:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"桥接模式(Bridge) 桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 抽象与它的实现分离，不是让抽象类与其派生类分离，因为这没有意思。实现指的是抽象类和它的派生类用来实现自己的对象。 桥接模式结构\r实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:24:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"命令模式(Command) 命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式结构\rinvoke:调用 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记录日志 允许接收请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他类，因此增加新的具体命令类很容易 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开 敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要急于去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:25:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"职责链模式(Chain of Responsibility) 职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 职责链模式结构\r职责链的好处 当客户提交一个请求时，请求是沿链传递直至有一个 ConcreteHandler 对象负责处理它。 接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接收者的引用。 随时地增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性。 一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:26:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"中介者模式(Mediator) 尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性。 大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。 中介者模式(Mediator)：用一个中介对象来封装一系列的对象交互。中介者使对象不需要显式地相互引用，从而使其耦度松散，而且可以独立地改变它们之间的交互。中介者模式又叫调停者模式。 中介者模式结构\r中介者模式的优缺点 优点 中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了\"多对多\"交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。 Mediator 的出现减少了各个 Colleague 的耦合，使得可以独立地改变和复用各个 Colleague 类和 Mediator，由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。 缺点 由于 ConcreteMediator 控制了集中化，于是就把交互复杂性变为了中介者复杂性，这就使得中介者会变得比任何一个 ConcreteColleague 都复杂。 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:27:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"享元模式(Flyweight) 享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。 享元模式结构\r内部状态和外部状态 内部状态：不会外部环境改变的共享部分 外部状态：随环境改变，不可以共享的状态。可以作为参数传入享元模式，达到内外状态协调。 享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够受大幅度地减少需要实例化类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。 如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:28:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"解释器模式(Interpreter) 解释器模式(Interpreter)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 如果一个特定类型的问题的发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决问题。 解释器模式结构\r当一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。 解释器模式很容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易容易实现文法，因为定义抽象语法树各个节点的类的实现大体相似，这些类都易于直接编写。 解释器模式的不足，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。 AST是抽象语法树（Abstract Syntax Tree）的缩写 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:29:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"访问者模式(Visitor) 双分派，意味着得到执行的操作取决于请求的种类和两个接收者的类型。 访问者模式(Visitor)：表示一个作用于某对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式结构\r访问者模式适合数据结构相对稳定的系统。它把数据结构和作用于数据结构的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。 访问者模式的目的是要把处理从数据结构中分离出来。有比较稳定的数据结构，又有易于变化的算法，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。 访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式的缺点其实就是使增加新的数据结构变得困难了。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:30:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"总结 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:0","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"创建型模式 抽象工厂模式 建造者模式 工厂方法模式 原型模式 单例模式 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。 原型模式 建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些。 建造者模式 将一个复杂对象的构建与它的表示分离，用同样的构建过程创建不同的产品给客户。 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。 耦合性描述的是一个例程与其他例程之间联系的紧密度。 软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合。 单例模式 对一些类来说，一个实例很重要。 让类自身负责保存它的唯一实例。 这个类可以保证没有其他实例可以被创建，并且还提供了一个访问该实例的方法。 对唯一的实例可以严格地控制客户怎样以及何时访问它。 工厂方法模式 通常设计应该是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。 创建型模式存在的意义： 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统如何使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的\"产品\"对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，即运行时再指定。 从 new 角度讲工厂方法是最好的设计，它把工厂职责都分了类，其他的创建型模式都是它的变体。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:1","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"结构型模式 适配器模式 桥接模式 解耦方式，用聚合代替继承 组合模式 装饰模式 外观模式 享元模式 代理模式 适配器模式 想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复合的类，该类可以与其他不相关的类或不可预见的类协同工作。 让这些接口不同的类通过适配器后，协同工作。 桥接模式 解耦两个或者多个不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改变为了组合关系，从而使这两者可以应对各自独立的变化。 找出变化并封装之。 装饰模式 以动态、透明的方式给单个对象添加职责。 组合模式 客户可以一致地使用组合结构和单个对象。 任何用到基本对象的地方都可以使用组合对象。 外观模式 应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体的办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障。 享元模式 对象使得内存占用过多，而如果都是大量重复的对象，那就是资源的极大浪费。 代理模式 代理和外观的主要区别在于，代理对象代表一个单一的对象而外观对象代表一个子系统，代理的客户对象无法直接访问目标对象，由于代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口。 代理一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。 适配器模式 主要为解决两个已有接口之间不匹配的问题，不需要考虑这些接口是怎么实现的，不考虑它们各自可能如何演化。 适配器这种方式不需要对两个独立设计的类中任何一个进行重新设计，就能够使它们协同工作。 外观模式较好。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:2","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["Documentation"],"content":"行为型模式 观察者模式 模板方法模式 命令模式 状态模式 职责链模式 解释器模式 中介者模式 访问者模式 策略模式 备忘录模式 迭代器模式 模板方法 代码重复是编程中最常见、最糟糕的\"坏味道\"，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合而为一，程序会变得更好。完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中。 模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法。 命令模式 将调用操作的对象与知道如何实现操作的对象解耦，在不同的时刻指定、排列和执行请求。 支持取消/重做的操作，并可记录整个操作日志，支持事物。 职责链模式 有多个对象可以处理一个请求，哪个对象处理请求事先并不知道，要在运行时刻自动确定，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这个请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 状态模式 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类就可以很容易的增加新的状态和转换。 解释器模式 如果一个特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题。 中介者模式 面向对设计鼓励将行为分布到各个对象中，这种分布肯能会导致对象之间有许多连接。也就是说，有可能一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难。将集体行为封装一个单独的中介者对象可以避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组内的对象不再相互显式引用。这些对象仅知道中介者，从而减少了相互连接的数目。 访问者模式 访问者增加具体的 Element 是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需要增加一个新的访问者即可在一个对象结构上定义一个新的操作。 策略模式 继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类 A 的子类 B、C、D，从而给它们以不同的行为。但这样会将行为硬行编制到父类 A 当中，而将算法的实现与类 A 的实现混合起来，从而使得类 A 难以理解、难以维护、难以扩展，而且还不能动态地改变算法。仔细分析发现，它们之间唯一的差别是它们所使用的算法或行为，将算法封装在独立的策略类中使得你可以独立于其类 A 改变它，使它易于切换、易于理解、易于扩展。 备忘录模式 使用备忘录可以避免暴露一些只应由对象 A 管理却又必须存储在对象 A 之外的信息。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界。 迭代器模式 迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。 只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果遵循开放-封闭原则、依赖倒置原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪个特定的对象。此时就需要\"对象管理者\"工厂来负责此事。 在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。 工厂方法的实现并不能减少工作量，但是它能够在处理新情况时，避免使已经很复杂的代码更加复杂。 面向对象设计模式体现的就是抽象的思想，类是对对象的抽象，抽象类是类的抽象，接口是对行为的抽象。 ","date":"2024-02-21","objectID":"/zh-cn/design-pattern/:31:3","tags":["design pattern"],"title":"设计模式","uri":"/zh-cn/design-pattern/"},{"categories":["documentation"],"content":" latex公式大全 读研写作latex公式相关 程序员数学 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:0:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"逻辑 逻辑 表示法 逻辑与 $A\\wedge B$ 逻辑或 $A\\vee B$ 逻辑非 $A\\neg B$ 逻辑相等 $A= B$ 逻辑异或 $A\\oplus B$ 逻辑蕴含 $A\\rightarrow B$ 逻辑蕴含 命题:若 $A$ 则 $B$ 逻辑表达式: $A\\rightarrow B$ 真值表: $A$ $B$ $A\\rightarrow B$ 0 1 1 1 0 0 0 1 1 1 1 1 逆否命题: ($\\neg B$)$\\rightarrow$($\\neg A$) ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:1:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"余数—一种问题的划分思想 奇偶校验的关键是找到合适的分类方法(完备性和排他性) 哥斯堡七桥问题 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:2:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"数学归纳法 将复杂问题简化 数学归纳法是由简单到复杂推理 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:3:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"置换、排列、组合 置换: $$P_n^n=n!$$ 排列: $$\\mathrm{P}_n^k=\\frac{n!}{(n-k)!}$$ 组合: $$\\mathrm{C}_n^k=\\frac{\\mathrm{P}_n^k}{\\mathrm{P}_k^k}=\\frac{n!}{(n-k)!(k)!}$$ 三者关系: $$\\mathrm{P}_n^k=\\mathrm{C}_n^k\\times \\mathrm{P}_k^k$$ ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:4:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"递归 将复杂问题简化 递归是将一般性前提推出个别性结论 递归思维方式：将复杂问题转为简单问题。核心是在问题中找出递归结构，建立递推公式。 斐波那契数列: $$0,1,1,2,3,5,8,13,21,34,55,89,…$$ 公式形式: $$S_n=S_{n-1}+S_{n-2}$$ 递归定义组合数: $$ \\mathrm{C_{n}^{k}}= \\begin{cases} 0,\u0026 (n=0 \\text{ 或 }k=0)\\\\ \\mathrm{C_{n-1}^{k-1}}+\\mathrm{C_{n-1}^{k}} \u0026 (0\u003ck\u003cn) \\end{cases} $$ 递归组合定义的数学理解: 从 n 个数中选 k 个包含特定数的组合等于包含特定数的组合($C_{n-1}^{k-1}$)加上不包含特定数的组合($C_{n-1}^{k}$) 找出复杂问题中隐含的递归结构步骤： 从 n 层的整体问题中隐去部分问题。 判断剩余问题是否是 n-1 层的问题。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:5:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"指数爆炸 数字急剧增长的情况称之为\"指数爆炸\"。 要一个不漏地测试设定选项的所有可能性是不现实的。 如果问题中包含指数爆炸，就不能简单的采用\"一个不漏\"的方法解决。 二分查找是利用指数爆炸的特性，每判断一次就能筛选出一半的\"有序\"查找对象。 处理庞大数字的工具–对数 利用指数爆炸加密 现在使用的密码，是用俗标\"密钥\"的随机字节流来加密的。 密码技术相关 四种处理指数爆炸问题的方法 极力求解:知道方法后极力求解。受限于计算机性能。 变相求解:转换成简单问题求解。不容易找到替换的方法。 近似求解:不求完全解答，而是找出近似解。数学层面虽不够严谨，但有利于实际应用。 概率求解:求解时使用随机数的方法。听起来虽不靠谱，不过在实际应用中却非常重要。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:6:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"不可解问题 不可解的数和无法编写的程序 反正法也称作归谬法 可数：集合的元素是有限的，或者集合中的所有元素都与正整数意义对应时，这个集合就被定义为可数。 可数集合: 有限集合 0以上所有偶数或奇数的集合 所有整数的集合 所有有理数的集合 程序的集合 不可数集合: 所有整数数列的集合，无穷个整数的排列成为整数数列。 所有实数的集合 所有函数的集合 对角论证法：为找出不包含在表中的数而选出表中对角线所有的数字。 不可解问题：原则上不能用程序解决的问题。 停机问题(Halting Problem)：判断\"某程序在给定数据下，是否会在有限时间内结束运行\"的问题。 许多判断程序运行的问题都是不可解问题。 ","date":"2024-03-06","objectID":"/zh-cn/progmmer-math/:7:0","tags":["programming math","math"],"title":"程序员数学","uri":"/zh-cn/progmmer-math/"},{"categories":["documentation"],"content":"linux shell脚本攻略 不能出现在文件名中的字符只有斜线(/)和空操作符(null)两个。 斜线用来分割构成路径名的各个文件 空操作符则用来终止一个路径名 /表示根目录，以/开头的路径为绝对路径，否则为相对路径。相对路径从工作目录开始解释 linux+shell脚本攻略 参考源码 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:0:0","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"预备知识 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:0","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"显示输出 username@hostname$或root@hostname #:$ 表示普通用户， # 表示管理员用户root。 shell 脚本通常以 shebang(也作 hashbang) 起始:#!/bin/bash shebang 是一个文本行，其中 #! 位于解释器路径之前。 /bin/bash是Bash的解释器命令路径。 bash 将以 # 符号开头的行视为注释。脚本中只有第一行可以使用shebang来定义解释该脚本所使用的解 释器。 脚本的执行方式有两种 (1) 将脚本名作为命令行参数： bash myScript.sh (2) 授予脚本执行权限，将其变为可执行文件: chmod 755 myScript.sh #chmod a+x myScript.sh #所有用户获得执行权限 ./myScript.sh $ ./sample.sh #./表示当前目录 $ /home/path/sample.sh #使用脚本的完整路径 ~ 表示主目录，它通常是 /home/user ，其中 user 是用户名，如果是root用户，则为 /root 。 shell 使用分号或换行符来分隔单个命令或命令序列。 $ cmd1;cmd2 等同于 $ cmd1 $ cmd2 echo 是用于终端打印的最基本命令。 默认情况下， echo 在每次调用后会添加一个换行符。 $ echo \"Welcome to Bash\" #$ echo Welcome to Bash 同样可以输出 Welcome to Bash $ echo 'text in quotes'#单引号也可以实现同样的效果 #双引号允许shell解释字符串中出现的特殊字符。单引号不会对其做任何解释。 如果需要打印像!这样的特殊字符，那就不要将其放入双引号中，而是使用单引号，或是在特殊字符之前加上一个反斜线（\\）： $ echo Hello world ! $ echo 'Hello world !' $ echo \"Hello world \\!\" #将转义字符放在前面 #输出结果 Hello world ! 另一个可用于终端打印的命令是 printf 。该命令使用的参数和C语言中的 printf 函数一样。 $ printf \"Hello world\" #输出结果 Hello world $ 使用 echo 和 printf 的命令选项时，要确保选项出现在命令中的所有字符串之前，否则 Bash 会将其视为另外一个字符串。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:1","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"使用变量与环境变量 变量名由一系列字母、数字和下划线组成，其中不包含空白字符。常用的惯例是在脚本中使用大写字母命名环境变量，使用驼峰命名法或小写字母命名其他变量。 所有的应用程序和脚本都可以访问环境变量。可以使用 env 或 printenv 命令查看当前shell 中所定义的全部环境变量。 $ env #要查看其他进程的环境变量，可以使用如下命令 $ cat /proc/$PID/environ #PID 是相关进程的进程ID（ PID 是一个整数） 我们可以使用 pgrep 命令获得gedit的进程ID: #查看运行程序gedit的ID数值 $ pgrep gedit 12501 特殊文件/proc/PID/environ是一个包含环境变量以及对应变量值的列表。每一个变量以 name=value 的形式来描述，彼此之间由null字符（ \\0 ）分隔。 生成一份易读的报表，可以将 cat 命令的输出通过管道传给 tr ，将其中的 \\0 替换成 \\n： $ cat /proc/12501/environ | tr '\\0' '\\n' varName 是变量名， value 是赋给变量的值。如果 value 不包含任何空白字符（例如空格），那么就不需要将其放入引号中，则必须使用单引号或双引号。 varName=value 注意：var = value 不同于 var=value 。把 var=value 写成 var = value是一个常见的错误。两边没有空格的等号是赋值操作符，加上空格的等号表示的是等量关系测试。 在变量名之前加上美元符号（$）就可以访问变量的内容。 var=\"value\" #将\"value\"赋给变量var echo $var #显示var中的值 #也可以 echo ${var} 可以在 printf 、 echo 或其他命令的双引号中引用变量值 #!/bin/bash #文件名:variables.sh fruit=apple count=5 echo \"We have $count ${fruit}(s)\" We have 5 apple(s) #输出结果 shell使用空白字符来分隔单词，所以我们需要加上一对花括号来告诉shell这里的变量名是 fruit ，而不是 fruit(s)。 在 PATH 中添加一条新路径，可以使用如下命令: #将/home/user/bin添加到了 PATH 中 export PATH=\"$PATH:/home/user/bin\" #或者 PATH=\"$PATH:/home/user/bin\" export PATH export 命令声明了将由子进程所继承的一个或多个变量。可以将一个变量设置为环境变量，使得该变量在当前 Shell 进程中可被其他子进程访问到。 注意：使用单引号时，变量不会被扩展（expand），仍依照原样显示。这意味着 $ echo '$var' 会显示 $var 。 获得字符串的长度： var=123456789 length=${#var} 识别当前所使用的shell： echo $SHELL #或者 echo $0 检查是否为超级用户： #!/bin/bash #环境变量 UID 中保存的是用户ID #它可以用于检查当前脚本是以root用户还是以普通用户的身份运行的 #root用户的 UID 是 0 # [ 实际上是一个命令，必须将其与剩余的字符串用空格隔开 If [ $UID -ne 0 ]; then echo Non root user. Please run as root. else echo Root user fi 等价于 If test $UID -ne 0:1 then echo Non root user. Please run as root. else echo Root user fi 修改Bash的提示字符串（ username@hostname:~$ ） #利用 PS1 环境变量来定义主提示字符串 #默认的提示字符串是在文件 ~/.bashrc 中的某一行设置的 #查看设置变量 PS1 的那一行 $ cat ~/.bashrc | grep PS1 PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' #修改提示字符串，可以输入 $ PS1=\"PROMPT\u003e\" #提示字符串已经改变 PROMPT\u003e Type commands here. 还有一些特殊的字符可以扩展成系统参数。例如： \\u 可以扩展为用户名， \\h 可以扩展为主机名，而 \\w 可以扩展为当前工作目录。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:2","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"使用函数添加环境变量 环境变量通常保存了可用于搜索可执行文件、库文件等的路径列表。 export PATH=/opt/myapp/bin:$PATH export LD_LIBRARY_PATH=/opt/myapp/lib; $LD_LIBRARY_PATH #结果 PATH=/opt/myapp/bin:/usr/bin:/bin # : 路径分隔符 LD_LIBRARY_PATH=/opt/myapp/lib:/usr/lib; /lib 我们可以在.bashrc文件中定义如下函数，简化路径添加操作： #定义函数 prepend() { [ -d \"$2\" ] \u0026\u0026 eval $1=\\\"$2':'\\$$1\\\" \u0026\u0026 export $1; } #用法 prepend PATH /opt/myapp/bin prepend LD_LIBRARY_PATH /opt/myapp/lib 函数 prepend() 首先确认该函数第二个参数所指定的目录是否存在。如果存在， eval 表达式将第一个参数所指定的变量值设置成第二个参数的值加上 : （路径分隔符），随后再跟上第一个参数的原始值。 在进行添加时，如果变量为空，则会在末尾留下一个 : 。要解决这个问题，可以对该函数再做一些修改： prepend() { [ -d \"$2\" ] \u0026\u0026 eval $1=\\\"$2\"\\$\\$$1\\\" \u0026\u0026 export $1; } 在这个函数中，我们引入了一种shell参数扩展的形式： ${parameter:+expression} 如果 parameter 有值且不为空，则使用 expression 的值。 通过这次修改，在向环境变量中添加新路径时，当且仅当旧值存在，才会增加 : 。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:3","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"使用 shell 进行数学运算 Bash shell使用 let 、 (( )) 和 [ ] 执行基本的算术操作。工具 expr 和 bc 可以用来执行高级操作。 let命令可以直接执行基本的算术操作。当使用 let 时，变量名之前不需要再添加 $ 。 no1=4; no2=5; let result=no1+no2; echo $result let 命令的其他用法如下： 自加操作 $ let no1++ 自减操作 $ let no1-- 简写形式 let no+=6 let no-=6 #它们分别等同于 let no=no+6 和 let no=no-6 操作符 [ ] 的使用方法和 let 命令一样： result=$[ no1 + no2 ] #注意空格[]前后位置都要有空格 result=$[ $no1 + 5 ] 也可以使用操作符 (()) 。出现在 (()) 中的变量名之前需要加上 $ ： result=$(( no1 + 50 )) expr 同样可以用于基本算术操作： result=`expr 3 + 4` result=$(expr $no1 + 5) 注意：以上这些方法不支持浮点数，只能用于整数运算。 bc 是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数： echo \"4 * 0.56\" | bc 2.24 no=54; #result=`echo \"$no * 1.5\" | bc` #反引号旧语法，推荐使用下面的$() result=$(echo \"$no * 1.5\" | bc) echo $result 81.0 bc 可以接受操作控制前缀。这些前缀之间使用分号分隔。 设定小数精度： #参数 scale=2 将小数位个数设置为 2 echo \"scale=2;22/7\" | bc 3.14 进制转换： #!/bin/bash #数字转换 no=100 echo \"obase=2;$no\" | bc #二进制,默认ibase为十进制 1100100 no=1100100 echo \"obase=10;ibase=2;$no\" | bc #obase：输出进制，ibase:输入进制 100 计算平方以及平方根： echo \"sqrt(100)\" | bc #平方根 echo \"10^10\" | bc #平方 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:4","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"文件描述符与重定向 文件描述符是与输入和输出流相关联的整数。常见的文件描述符有stdin(标准输入)、stdout(标准输出)和stderr(标准错误)。我们可以将某个文件描述符的内容重定向到另一个文件描述符中。 脚本可以使用大于号(\u003e)将输出重定向到文件中,命令产生的文本可能是正常输出，也可能是错误信息。默认情况下，正常输出（ stdout ）和错误信息（ stderr ）都会显示在屏幕上。 文件描述符是与某个打开的文件或数据流相关联的整数。文件描述符 0 、 1 以及 2 是系统预留的: 0 —— stdin （标准输入） 1 —— stdout （标准输出） 2 —— stderr （标准错误） 使用大于号(\u003e)将文本保存到文件中(若文件存在，则先清空文件内的文本，再写入文本)： $ echo \"This is a sample text 1\" \u003e temp.txt #该命令会将输出的文本保存在temp.txt中。 #如果temp.txt已经存在，大于号会清空该文件中 先前的内容。 使用双大于号(»)将文本追加到文件中(不会清空文件中的内容)： echo \"This is sample text 2\" \u003e\u003e temp.txt 使用 cat 查看文件内容： $ cat temp.txt This is sample text 1 This is sample text 2 重定向 stderr: $ ls + ls: cannot access +: No such file or directory #这里， + 是一个非法参数，因此会返回错误信息。 $ ls + \u003e out.txt #因为 stdout 并没有输出，所以out.txt的内容为空 $ ls + 2\u003e out.txt #重定向到out.txt 将 stderr 和 stdout 分别重定向到不同的文件中： $ cmd 2\u003estderr.txt 1\u003estdout.txt 将stderr 和 stdout 都重定向到同一个文件中： $ cmd 2\u003e\u00261 alloutput.txt #或者这样 $ cmd \u0026\u003e output.txt 如果你不想看到或保存错误信息，那么可以将 stderr 的输出重定向到/dev/null(一个特殊的设备文件，它会丢弃接收到的任何数据)。 我们在处理一些命令输出的同时还想将其保存下来，以备后用。 stdout 作为单数据流（single stream），可以被重定向到文件或是通过管道传入其他程序，但是无法两者兼得。 有一种方法既可以将数据重定向到文件，还可以提供一份重定向数据的副本作为管道中后续命令的 stdin 。 tee 命令从 stdin 中读取，然后将输入数据重定向到 stdout 以及一个或多个文件中。 command | tee FILE1 FILE2 | otherCommand 命令 cat -n 为从 stdin 中接收到的每一行数据前加上行号并将其写入 stdout ： $ cat a* | tee out.txt | cat -n cat: a1: Permission denied 1 A2 2 A3 使用 cat 查看out.txt的内容： $ cat out.txt A2 A3 注意：cat: a1: Permission denied 并没有在文件内容中出现，因为这些信息被发送到了 stderr ，而 tee 只能从 stdin 中读取。 默认情况下， tee 命令会将文件覆盖，但它提供了一个 -a 选项，可用于追加内容。 $ cat a* | tee -a out.txt | cat -n 带有参数的命令可以写成： command FILE1 FILE2 ... ，或者就简单地使用 command FILE 。 要发送输入内容的两份副本给 stdout ，使用 - 作为命令的文件名参数即可： #$ cmd1 | cmd2 | cmd - $ echo who is this | tee - who is this who is this 默认情况下，重定向操作针对的是标准输出。 从 stdin 读取输入的命令能以多种方式接收数据。可以用 cat 和管道来指定我们自己的文件描述符。 将文件重定向到命令： #借助小于号（ \u003c ），我们可以像使用 stdin 那样从文件中读取数据 $ cmd \u003c file 重定向脚本内部的文本块 #!/bin/bash #可以将脚本中的文本重定向到文件。 #要想将一条警告信息添加到自动生成的文件顶部，可以使用下面的代码: cat\u003c\u003cEOF\u003elog.txt #重定义文件结束符 EOF This is a generated file. Do not edit. Changes will be overwritten. EOF #出现在 cat \u003c\u003cEOF\u003elog.txt 与下一个 EOF 行之间的所有文本行都会被当作 stdin 数据。log.txt文件的内容显示如下: $ cat log.txt This is a generated file. Do not edit. Changes will be overwritten. 自定义文件描述符 文件描述符是一种用于访问文件的抽象指示器存取文件离不开被称为\"文件描述符\"的特殊数字。 0 、 1 和 2 分别是stdin 、 stdout 和 stderr 预留的描述符编号。 exec 命令创建全新的文件描述符。常用的打开模式有3种： (1)只读模式。\u003c (2)追加写入模式。» (3)截断写入模式。\u003e 创建一个用于读取文件的文件描述符： $ # exec 3\u003cinput.txt #使用文件描述符3打开并读取文件 $ echo this is a test line \u003e input.txt $ exec 3\u003cinput. \u003c\u0026：将输入重定向到指定的文件描述符。 在命令中使用文件描述符 3： $ cat\u003c\u00263 this is a test line 如果要再次读取，我们就不能继续使用文件描述符 3 了，而是需要用 exec 重新创建一个新的文件描述符（可以是 4 ）来从另一个文件中读取或是重新读取上一个文件。 创建一个用于写入（截断模式）的文件描述符： $ #exec 4\u003eoutput.txt #打开文件进行写入 $ exec 4\u003eoutput.txt $ echo newline \u003e\u00264 $ cat output.txt newline 创建一个用于写入（追加模式）的文件描述符： #$ exec 5\u003e\u003einput.txt $ exec 5\u003e\u003einput.txt $ echo appended line \u003e\u00265 $ cat input.txt newline appended line ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:5","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"数组与关联数组 Bash从4.0版本才开始支持关联数组 数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。当数据以数字顺序组织的时候，应该使用普通数组，例如一组连续的迭代。当数据以字符串组织的时候，关联数组就派上用场了，例如主机名称。 定义数组的方法 #这些值将会存储在以0为起始索引的连续位置上 array_var=(test1 test2 test3 test4) #将数组定义成一组“索引-值” array_var[0]=\"test1\" array_var[1]=\"test2\" array_var[2]=\"test3\" array_var[3]=\"test4\" 打印出特定索引的数组元素内容 echo ${array_var[0]} test1 index=3 echo ${array_var[$index]} test4 以列表形式打印出数组中的所有值 $ echo ${array_var[*]} test1 test2 test3 test4 #或者 $ echo ${array_var[@]} test1 test2 test3 test4 打印数组长度（即数组中元素的个数） $ echo ${#array_var[*]} 4 定义关联数组 #使用声明语句将一个变量定义为关联数组 $ declare -A ass_array 可以用下列两种方法将元素添加到关联数组中 使用行内\"索引 - 值\"列表 $ ass_array=([index1]=val1 [index2]=val2) 使用独立的\"索引 - 值\"进行赋值： $ ass_array[index1]=val1 $ ass_array[index2]=val2 列出数组索引(普通数组和关联数组均可使用) $ echo ${!array_var[*]} #或者 $ echo ${!array_var[@]} ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:6","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"别名 使用 alias 命令创建别名。 创建别名 #为 apt-get install 创建了一个别名 $ alias install='sudo apt-get install' alias 命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。为了使别名在所有的shell中都可用，可以将其定义放入~/.bashrc文件中。每当一个新的交互式shell进程生成时，都会执行 ~/.bashrc中的命令。 #添加别名 $ echo 'alias cmd=\"command seq\"' \u003e\u003e ~/.bashrc 删除别名 只需将其对应的定义（如果有的话）从~/.bashrc中删除，或者使用unalias 命令。也可以使用 alias example= ，这会取消别名 example。 注意：创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的设置取代。 创建别名并为原文件保留一个副本 #创建一个别名 rm ，它能够删除原始文件，同时在backup目录中保留副本 alias rm='cp $@ ~/backup \u0026\u0026 rm $@' $@ 的含义：$@ 表示所有的位置参数，每个参数都是一个独立的字符串。 在使用 $@ 时，最好将其放在双引号中以避免参数的空格和特殊字符被解释为多个参数。这样可以确保每个参数都作为独立的字符串进行处理。 $@ 和 $* 的区别：$@和 $* 都表示所有的位置参数，但在引用时有所不同。$@ 会将每个参数作为独立的引用，并保留参数中的空白和特殊字符；而 $* 会将所有参数作为单个字符串引用，并在参数之间插入第一个字符处定义的特殊字符（通常是空格）。 对别名进行转义 创建一个和原生命令同名的别名很容易，你不应该以特权用户的身份运行别名化的命令。我们可以转义要使用的命令，忽略当前定义的别名。 $ \\command 字符 \\ 可以转义命令，从而执行原本的命令。在不可信环境下执行特权命令时，在命令前加上 \\ 来忽略可能存在的别名总是一种良好的安全实践。这是因为攻击者可能已经将一些别有用心的命令利用别名伪装成了特权命令，借此来盗取用户输入的重要信息。 列举别名 alias alias ll='ls -l' alias lt='ls -t' alias la='ls -a' ... ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:7","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"采集终端信息 tput 和 stty 是两款终端处理工具。 获取终端的行数和列数： tput cols tput lines 打印出当前的终端名： tput longname 将光标移动到坐标(100,100)处： tput cup 100 100 设置终端背景色： tput setb n #n 可以在0到7之间取值 设置终端前景色： tput setf n #n 可以在0到7之间取值 注意：包括常用的 color ls 在内的一些命令可能会重置前景色和背景色。 设置文本样式为粗体： tput bold 设置下划线的起止： tput smul tput rmul 删除从当前光标位置到行尾的所有内容： tput ed 输入密码时，脚本不应该显示输入内容。在下面的例子中，我们将看到如何使用 stty 来实现这一需求： #!/bin/sh #Filename: password.sh echo -e \"Enter password: \" # 在读取密码前禁止回显 stty -echo read password # 重新允许回显 stty echo echo $password #显示输入的密码 stty 命令的选项 -echo 禁止将输出发送到终端，而选项 echo 则允许发送输出。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:8","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"获取并设置日期及延时 在系统内部，日期被存储成一个整数，其取值为自1970年1月1日0时0分0秒 起所流逝的秒数。这种计时方式称为纪元时或Unix时间。 读取日期： $ date Thu May 20 23:09:04 IST 2010 2024年 03月 21日 星期四 22:52:24 CST 打印纪元时： $ date +%s 1711032681 将日期转换成纪元时： $ date --date \"Wed mar 15 08:09:16 EDT 2017\" +%s $ date -d \"Wed mar 15 08:09:16 EDT 2017\" +%s #这条命令无法转带中文格式日期 1489579718 用带有前缀 + 的格式化字符串作为 date 命令的参数，可以按照你的选择打印出相应格式的日期： $ date \"+%d %B %Y\" 20 May 2010 设置日期和时间： ## date -s \"格式化的日期字符串\" date -s \"21 June 2009 11:01:22\" #如果系统已经联网，可以使用 ntpdate 来设置日期和时间： /usr/sbin/ntpdate -s time-b.nist.gov date 命令可以用于计算一组命令所花费的执行时间: #!/bin/bash #文件名: time_take.sh start=$(date +%s) #date 命令的最小精度是秒,对命令计时的另一种更好的方式是使用 time 命令 commands; statements; end=$(date +%s) difference=$(( end - start)) echo Time taken to execute commands is $difference seconds. 在脚本中生成延时： #!/bin/bash #文件名: sleep.sh echo Count: tput sc # 循环40秒 for count in `seq 0 40` do tput rc tput ed echo -n $count #-n,不输出尾部换行符 sleep 1 done 在上面的例子中，变量依次使用了由 seq 命令生成的一系列数字。我们用 tput sc 存储光标位置。在每次循环中，通过 tput rc 恢复之前存储的光标位置，在终端中打印出新的 count 值，然后使用 tputs ed 清除从当前光标位置到行尾之间的所有内容。行被清空之后，脚本就可以显示出新的值。 sleep 可以使脚本在每次循环迭代之间延迟1秒钟。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:9","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"调试脚本 可以利用Bash内建的调试工具或者按照易于调试的方式编写脚本。 使用选项 -x，启用shell脚本的跟踪调试功能： $ bash -x script.sh #或 sh -x script 运行带有 -x 选项的脚本可以打印出所执行的每一行命令以及当前状态。 使用 set -x 和 set +x 对脚本进行部分调试。 #!/bin/bash #文件名: debug.sh for i in {1..6}; do set -x #-x与+x包裹部分是被限制的调试区域 echo $i set +x done echo \"Script executed\" 该脚本并没有使用上例中的 seq 命令，而是用 {start..end} 来迭代从 start 到 end 之间的值。这个语言构件（construct）在执行速度上要比 seq 命令略快。 定义 _DEBUG 环境变量来启用或禁止调试及生成特定形式的信息。 #!/bin/bash #名字: debug.sh function DEBUG() { [ \"$_DEBUG\" == \"on\" ] \u0026\u0026 $@ || : #[]为真执行$@(位置参数)，[]为假执行 ||后面的:,shell空命令(这里当作占位符) } for i in {1..10} do DEBUG echo \"I is $i\" done 将调试功能设置为 on 来运行上面的脚本： _DEBUG=on ./debug.sh #需有x权限 我们在每一条需要打印调试信息的语句前加上 DEBUG 。如果没有把 _DEBUG=on 传递给脚本，那么调试信息就不会打印出来。在Bash中，命令 : 告诉shell不要进行任何操作。 set -x ：在执行时显示参数和命令。 set +x ：禁止调试。 set -v ：当命令进行读取时显示输入。 set +v ：禁止打印输入。 shebang的妙用 把shebang从 #!/bin/bash 改成 #!/bin/bash -xv ，这样一来，不用任何其他选项就可以启用调试功能了。 以将环境变量PS4设置为 '$LINENO: ' ，显示出每行的行号： PS4='$LINENO: ' ``（反引号）用于执行命令替换，将命令的输出结果作为替换结果。 ‘’（单引号）用于创建字符串字面值，保持所有字符的原样性，不进行变量替换或命令执行。 使用了 -x或 set -x ，调试输出会被发送到 stderr，可以使用下面的命令将其重定向到文件中： sh -x testScript.sh 2\u003e debugout.txt Bash 4.0以及后续版本支持对调试输出使用自定义文件描述符： exec 6\u003e /tmp/debugout.txt BASH_XTRACEFD=6 BASH_XTRACEFD=6 是一个环境变量设置，它指示Bash Shell将跟踪（trace）输出重定向到文件描述符6。通常，Bash Shell使用文件描述符2（标准错误）来输出跟踪信息，但通过将BASH_XTRACEFD设置为6，你可以将跟踪输出重定向到文件描述符6，从而将跟踪信息写入/tmp/debugout.txt 文件。 函数和参数 函数和别名乍一看很相似，不过两者在行为上还是略有不同。最大的差异在于函数参数可以在函数体中任意位置上使用，而别名只能将参数放在命令尾部。 函数的定义包括function命令、函数名、开/闭括号以及包含在一对花括号中的函数体。 函数可以这样定义： function fname() { statements; } #或者 fname() { statements; } #或者 fname() { statement; } 只需使用函数名就可以调用函数 $ fname ; #执行函数 函数参数可以按位置访问， $1 是第一个参数， $2 是第二个参数，以此类推： fname arg1 arg2 ; #传递参数 以下是函数 fname 的定义。在函数 fname 中，包含了各种访问函数参数的方法。 fname() { echo $1, $2; #访问参数1和参数2 echo \"$@\"; #以列表的方式一次性打印所有参数 echo \"$*\"; #类似于$@，但是所有参数被视为单个实体 return 0; #返回值 } 传入脚本的参数可以通过下列形式访问。 $0 是脚本名称。 $1 是第一个参数。 $2 是第二个参数。 $n 是第n个参数。 \"$@\" 被扩展成 \"$1\" \"$2\" \"$3\" 等。 \"$*\" 被扩展成 \"$1c$2c$3\" ，其中 c 是IFS的第一个字符。 $@要比$*用得多。由于$*将所有的参数当作单个字符串,因此它很少被使用。 grep命令找到的是字符串eth0,而不是IP地址。如果我们使用函数来实现的话,可以将设备名作为参数传入ifconfig,不再交给 grep : $\u003e function getIP() { /sbin/ifconfig $1 | grep 'inet '; } $\u003e getIP eth0 inet addr:192.168.1.2 Bcast:192.168.255.255 Mask:255.255.0.0 #直接方式也可以获得 $\u003e ifconfig eth0 | grep \"inet\" inet addr:192.168.1.2 Bcast:192.168.255.255 Mask:255.255.0.0 Bash函数的技巧 在Bash中,函数同样支持递归调用(可以调用自身的函数),如F() { echo $1; F hello;sleep 1; } 递归函数 Fork炸弹 :(){ :|:\u0026 };: #这个函数会一直地生成新的进程,最终形成拒绝服务攻击。 #函数调用前的 \u0026将子进程放入后台。 #这段危险的代码能够不停地衍生出进程,因而被称为Fork炸弹。 可以通过修改配置文件/etc/security/limits.conf中的 nproc 来限制可生成的最大进程数,进而阻止这种攻击。 #将所有用户可生成的进程数限制为100 hard nproc 100 导出函数 函数也能像环境变量一样用export导出,如此一来,函数的作用域就可以扩展到子进程中: export -f fname $\u003e function getIP() { /sbin/ifconfig $1 | grep 'inet '; } $\u003e echo \"getIP eth0\" \u003etest.sh $\u003e sh test.sh #sh 无法使用函数 sh: getIP: No such file or directory $\u003e export -f getIP $\u003e sh test.sh test.sh: 2: getip: not found $\u003e bash test.sh #sh 不支持export命令 inet addr: 192.168.1.2 Bcast: 192.168.255.255 Mask:255.255.0.0 读取命令返回值(状态) cmd echo $? #返回值被称为退出状态。它可用于确定命令执行成功与否。 #如果命令成功退出,那么退出状态为0,否则为非0。 下面的脚本可以报告命令是否成功结束: #!/bin/bash #文件名: success_test.sh #对命令行参数求值,比如success_test.sh ‘ls | grep txt’ eval $@ #eval $@ 是一个在Shell脚本中常见的用法，它用于执行传递给脚本的命令行参数。当使用 eval $@ 时，eval 命令会对 $@ 中的参数进行解析和执行。 if [ $? -eq 0 ]; then echo \"$CMD executed successfully\" else echo \"$CMD terminated unsuccessfully\" fi 向命令传递参数 $# 是一个特殊变量，用于获取传递给脚本的命令行参数的数量。 shift命令可以将参数依次向左移动一个位置,让脚本能够使用$1 来访问到每一个参数。下面的代码显示出了所有的命令行参数: $ cat showArgs.sh for i in `seq 1 $#` do echo $i is $1 shift done $ sh showArgs.sh a b c 1 is a 2 is b 3 is c ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:10","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"将一个命令的输出发送给另一个命令 使用管道 | 来连接多条命令 $ cmd1 | cmd2 | cmd3 组合两个命令： $ ls | cat -n \u003e out.txt # -n，加上行号 将命令序列的输出赋给变量: #这种方法叫作子shell法 cmd_output=$(ls | cat -n) echo $cmd_output #或者，反引号 cmd_output=`COMMANDS` 利用子shell生成一个独立的进程 子shell本身就是独立的进程。可以使用()操作符来定义一个子shell。 $\u003e pwd / $\u003e (cd /bin; ls) awk bash cat... $\u003e pwd / 当命令在子shell中执行时,不会对当前shell造成任何影响;所有的改变仅限于该子shell内。例如,当用cd命令改变子shell的当前目录时,这种变化不会反映到主shell环境中。 通过引用子shell的方式保留空格和换行符 $ cat text.txt 1 2 3 $ out=$(cat text.txt) $ echo $out 1 2 3 # 丢失了1、2、3中的\\n $ out=\"$(cat text.txt)\" $ echo $out 1 2 3 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:11","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"在不按下回车键的情况下读入 n 个字符 read命令提供了一种不需要按回车键就能够搞定这个任务的方法。 句从输入中读取n个字符并存入变量variable_name: read -n number_of_chars variable_name $ read -n 2 var #读入最多2个字符终止输入 $ echo $var 用无回显的方式读取密码: read -s var 使用read显示提示信息: read -p \"Enter input:\" var 在给定时限内读取输入: #read -t timeout var $ read -t 2 var #在2秒内将键入的字符串读入变量var 用特定的定界符作为输入行的结束: #read -d delim_char var $ read -d \":\" var hello: #var被设置为hello ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:12","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":["documentation"],"content":"持续运行命令直至执行成功 repeat() { while true do $@ \u0026\u0026 return done } #函数repeat()中包含了一个无限while循环, #该循环执行以函数参数形式(通过$@访问)传入的命令。 #如果命令执行成功,则返回,进而退出循环。 ","date":"2024-03-22","objectID":"/zh-cn/linux-shell/:1:13","tags":["shell","linux"],"title":"linux shell攻略","uri":"/zh-cn/linux-shell/"},{"categories":null,"content":"关于博客","date":"2023-10-31","objectID":"/zh-cn/about/","tags":null,"title":"关于博客","uri":"/zh-cn/about/"},{"categories":null,"content":"欢迎访问我的博客！ 这是一个记录学习编程技术的博客，详细内容可见全部文档。如读者能在这里学到知识，作者将不胜荣幸！ ","date":"2023-10-31","objectID":"/zh-cn/about/:0:0","tags":null,"title":"关于博客","uri":"/zh-cn/about/"}]