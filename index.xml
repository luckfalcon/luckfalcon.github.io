<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://luckfalcon.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Sep 2023 11:26:19 +0800</lastBuildDate><atom:link href="https://luckfalcon.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Effectivecpp</title>
      <link>https://luckfalcon.github.io/post/effectivecpp/</link>
      <pubDate>Wed, 13 Sep 2023 11:26:19 +0800</pubDate>
      
      <guid>https://luckfalcon.github.io/post/effectivecpp/</guid>
      <description>luckfalcon的博客 C++编程注意条款 拷贝构造函数&amp;mdash;初始化&amp;mdash;&amp;ndash;A(B)&amp;mdash;只发生在对象创建时 拷贝赋值运算符&amp;ndash;同类型对象值赋值给创建对象&amp;ndash;A=B 值传递（pass-by-value）&amp;ndash;调用构造函数 引用传递(passed-by-reference)&amp;ndash;不调用构造函数 C++四大次级语言
c语言部分编程 class类编程 template模板编程 STL标准库编程 条款2：尽量以const,enum,inline 替换#define #define 没有作用域概念，且不做类型检查，仅仅是变量替换(包括变量的前后缀，表达式代入) #define max(a,b) f((a)&amp;gt;(b)?(a):(b)) int a = 5,b = 0; max(++a,b);	//a被累加2次 max(++a,b+10);	//a被累加1次 enum hack(枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术 class test {	static const int num=1;//此处仅为声明而非定义 int arr[num]; } const int num;//此处为定义,放在实现文件中而非头文件中 enum{num = 5}//可代替上 static const int class test { private: enum {arr_size = 10};//在编译器不支持编译期间类内static初值时(仅限整数情况) static const int arr[arr_size]; } 小结
const 对象替换define 常量 inline函数替换define 形似函数 条款3：尽可能使用const 令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性 //有理数operator* class Rational{} const Rational operator*(const Rational &amp;amp;lhs,const Rational &amp;amp;rhs); //可以避免客户暴力行为如: Rational a,b,c; (a * b) = c;//在a*b的结果上调用赋值运算符operator = const成员函数，可确保类的const对象可被操作 如过函数的返回类型是内置类型，改动函数返回值是非法的 class text { public: const &amp;amp;char operator[](std::size_t position)const//处理const对象，不可修改对象 {return st[position];} &amp;amp;char operator[](std::size_t position)//处理非const对象,可修改对象 {return st[position];} private: std::string st; } 将类成员声明为mutable类型，可以实现在const对象内修改对象的值，但并能完全解决const与non-const的全部问题 class text { public: std::size_t length()const; private: char *ptex; mutable std::size_t textlength;//这些变量可以被修改，即使在const对象内部 mutable bool LengthIsValid; } std::size_t text:: length()const { if(!</description>
    </item>
    
    <item>
      <title>Hugo first post</title>
      <link>https://luckfalcon.github.io/post/firstpost/</link>
      <pubDate>Wed, 13 Sep 2023 11:23:42 +0800</pubDate>
      
      <guid>https://luckfalcon.github.io/post/firstpost/</guid>
      <description>hugo first post </description>
    </item>
    
  </channel>
</rss>
