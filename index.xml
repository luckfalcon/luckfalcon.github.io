<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>主页</title>
    <link>https://luckfalcon.github.io/</link>
    <description>Recent content on 主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Thu, 26 Oct 2023 19:49:47 +0800</lastBuildDate>
    
        <atom:link href="https://luckfalcon.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>关于博客</title>
        <link>https://luckfalcon.github.io/about/</link>
        <pubDate>Thu, 26 Oct 2023 23:05:12 +0800</pubDate>
        
        <guid>https://luckfalcon.github.io/about/</guid>
        <description>主页 https://luckfalcon.github.io/about/ -&lt;p&gt;欢迎访问我的博客！
这是一个记录学习编程技术的博客，详细内容可见归档，由于作者能力有限，只能做到尽可能的不发生记录上的错误，如读者发现文章上有错误，可以给我留言！作者将在空闲时间看到后，仔细订正错误！
如读者能在这里学到知识，作者将不胜荣幸！&lt;/p&gt;
- https://luckfalcon.github.io/about/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>Markdown</title>
        <link>https://luckfalcon.github.io/post/markdown/</link>
        <pubDate>Thu, 26 Oct 2023 19:49:47 +0800</pubDate>
        
        <guid>https://luckfalcon.github.io/post/markdown/</guid>
        <description>主页 https://luckfalcon.github.io/post/markdown/ -&lt;h2 id=&#34;主要内容&#34;&gt;主要内容&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;markdown是什么&#34;&gt;Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h4&gt;
&lt;h4 id=&#34;谁创造了它&#34;&gt;&lt;em&gt;谁&lt;/em&gt;创造了它？&lt;/h4&gt;
&lt;h4 id=&#34;为什么要使用它&#34;&gt;&lt;em&gt;为什么&lt;/em&gt;要使用它？&lt;/h4&gt;
&lt;h4 id=&#34;怎么使用&#34;&gt;&lt;em&gt;怎么&lt;/em&gt;使用？&lt;/h4&gt;
&lt;h4 id=&#34;谁在用&#34;&gt;&lt;em&gt;谁&lt;/em&gt;在用？&lt;/h4&gt;
&lt;h4 id=&#34;尝试一下&#34;&gt;尝试一下&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;h3 id=&#34;1-markdown是什么&#34;&gt;1. Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级&lt;strong&gt;标记语言&lt;/strong&gt;，它以纯文本形式(&lt;em&gt;易读、易写、易更改&lt;/em&gt;)编写文档，并最终以HTML格式发布。 &lt;br&gt;
&lt;strong&gt;Markdown&lt;/strong&gt;也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。&lt;/p&gt;
&lt;h3 id=&#34;2-谁创造了它&#34;&gt;2. &lt;em&gt;谁&lt;/em&gt;创造了它？&lt;/h3&gt;
&lt;p&gt;它由&lt;a href=&#34;http://www.aaronsw.com/&#34;&gt;&lt;strong&gt;Aaron Swartz&lt;/strong&gt;&lt;/a&gt;和&lt;strong&gt;John Gruber&lt;/strong&gt;共同设计，&lt;strong&gt;Aaron Swartz&lt;/strong&gt;就是那位于去年（&lt;em&gt;2013年1月11日&lt;/em&gt;）自杀,有着&lt;strong&gt;开挂&lt;/strong&gt;一般人生经历的程序员。维基百科对他的&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8&#34;&gt;介绍&lt;/a&gt;是：&lt;strong&gt;软件工程师、作家、政治组织者、互联网活动家、维基百科人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;他有着足以让你跪拜的人生经历：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;14岁&lt;/strong&gt;参与RSS 1.0规格标准的制订。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2004&lt;/strong&gt;年入读&lt;strong&gt;斯坦福&lt;/strong&gt;，之后退学。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2005&lt;/strong&gt;年创建&lt;a href=&#34;http://infogami.org/&#34;&gt;Infogami&lt;/a&gt;，之后与&lt;a href=&#34;http://www.reddit.com/&#34;&gt;Reddit&lt;/a&gt;合并成为其合伙人。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2010&lt;/strong&gt;年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2011&lt;/strong&gt;年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2013&lt;/strong&gt;年1月自杀身亡。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg&#34; alt=&#34;Aaron Swartz&#34;&gt;&lt;/p&gt;
&lt;p&gt;天才都有早逝的归途。&lt;/p&gt;
&lt;h3 id=&#34;3-为什么要使用它&#34;&gt;3. &lt;em&gt;为什么&lt;/em&gt;要使用它？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它是易读（看起来舒服）、易写（语法简单）、易更改&lt;strong&gt;纯文本&lt;/strong&gt;。处处体现着&lt;strong&gt;极简主义&lt;/strong&gt;的影子。&lt;/li&gt;
&lt;li&gt;兼容HTML，可以转换为HTML格式发布。&lt;/li&gt;
&lt;li&gt;跨平台使用。&lt;/li&gt;
&lt;li&gt;越来越多的网站支持Markdown。&lt;/li&gt;
&lt;li&gt;更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）&lt;/li&gt;
&lt;li&gt;摆脱Word（我不是认真的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-怎么使用&#34;&gt;4. &lt;em&gt;怎么&lt;/em&gt;使用？&lt;/h3&gt;
&lt;p&gt;如果不算&lt;strong&gt;扩展&lt;/strong&gt;，Markdown的语法绝对&lt;strong&gt;简单&lt;/strong&gt;到让你爱不释手。&lt;/p&gt;
&lt;p&gt;Markdown语法主要分为如下几大部分：
&lt;strong&gt;标题&lt;/strong&gt;，&lt;strong&gt;段落&lt;/strong&gt;，&lt;strong&gt;区块引用&lt;/strong&gt;，&lt;strong&gt;代码区块&lt;/strong&gt;，&lt;strong&gt;强调&lt;/strong&gt;，&lt;strong&gt;列表&lt;/strong&gt;，&lt;strong&gt;分割线&lt;/strong&gt;，&lt;strong&gt;链接&lt;/strong&gt;，&lt;strong&gt;图片&lt;/strong&gt;，&lt;strong&gt;反斜杠 &lt;code&gt;\&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;符号&amp;rsquo;`&amp;rsquo;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;41-标题&#34;&gt;4.1 标题&lt;/h4&gt;
&lt;p&gt;两种形式：&lt;br&gt;
1）使用&lt;code&gt;=&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;标记一级和二级标题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一级标题&lt;br&gt;
&lt;code&gt;=========&lt;/code&gt;&lt;br&gt;
二级标题 &lt;br&gt;
&lt;code&gt;---------&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&#34;一级标题&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;二级标题&#34;&gt;二级标题&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）使用&lt;code&gt;#&lt;/code&gt;，可表示1-6级标题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;# 一级标题&lt;br&gt;
## 二级标题&lt;br&gt;
### 三级标题&lt;br&gt;
#### 四级标题&lt;br&gt;
##### 五级标题&lt;br&gt;
###### 六级标题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&#34;一级标题-1&#34;&gt;一级标题&lt;/h1&gt;
&lt;h2 id=&#34;二级标题-1&#34;&gt;二级标题&lt;/h2&gt;
&lt;h3 id=&#34;三级标题&#34;&gt;三级标题&lt;/h3&gt;
&lt;h4 id=&#34;四级标题&#34;&gt;四级标题&lt;/h4&gt;
&lt;h5 id=&#34;五级标题&#34;&gt;五级标题&lt;/h5&gt;
&lt;h6 id=&#34;六级标题&#34;&gt;六级标题&lt;/h6&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;42-段落&#34;&gt;4.2 段落&lt;/h4&gt;
&lt;p&gt;段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用&lt;strong&gt;两个以上&lt;/strong&gt;空格加上回车（引用中换行省略回车）。&lt;/p&gt;
&lt;h4 id=&#34;43-区块引用&#34;&gt;4.3 区块引用&lt;/h4&gt;
&lt;p&gt;在段落的每行或者只在第一行使用符号&lt;code&gt;&amp;gt;&lt;/code&gt;,还可使用多个嵌套引用，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; 区块引用&lt;br&gt;
&amp;gt;&amp;gt; 嵌套引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嵌套引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;44-代码区块&#34;&gt;4.4 代码区块&lt;/h4&gt;
&lt;p&gt;代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如 &lt;br&gt;
普通段落：&lt;/p&gt;
&lt;p&gt;void main() &lt;br&gt;
{ &lt;br&gt;
printf(&amp;ldquo;Hello, Markdown.&amp;rdquo;); &lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;代码区块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void main()
{
    printf(&amp;quot;Hello, Markdown.&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:需要和普通段落之间存在空行。&lt;/p&gt;
&lt;h4 id=&#34;45-强调&#34;&gt;4.5 强调&lt;/h4&gt;
&lt;p&gt;在强调内容两侧分别加上&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;_&lt;/code&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*斜体*，_斜体_ &lt;br&gt;
**粗体**，__粗体__&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;，&lt;em&gt;斜体&lt;/em&gt; &lt;br&gt;
&lt;strong&gt;粗体&lt;/strong&gt;，&lt;strong&gt;粗体&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;46-列表&#34;&gt;4.6 列表&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;·&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;、或&lt;code&gt;-&lt;/code&gt;标记无序列表，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-（+*） 第一项
-（+*） 第二项
- （+*）第三项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;有序列表的标记方式是将上述的符号换成数字,并辅以&lt;code&gt;.&lt;/code&gt;，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 . 第一项&lt;br&gt;
2 . 第二项 &lt;br&gt;
3 . 第三项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;47-分割线&#34;&gt;4.7 分割线&lt;/h4&gt;
&lt;p&gt;分割线最常使用就是三个或以上&lt;code&gt;*&lt;/code&gt;，还可以使用&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;48-链接&#34;&gt;4.8 链接&lt;/h4&gt;
&lt;p&gt;链接可以由两种形式生成：&lt;strong&gt;行内式&lt;/strong&gt;和&lt;strong&gt;参考式&lt;/strong&gt;。 &lt;br&gt;
&lt;strong&gt;行内式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[younghz的Markdown库](https:://github.com/younghz/Markdown &amp;ldquo;Markdown&amp;rdquo;)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;参考式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[younghz的Markdown库1][1] &lt;br&gt;
[younghz的Markdown库2][2] &lt;br&gt;
[1]:https:://github.com/younghz/Markdown &amp;ldquo;Markdown&amp;rdquo; &lt;br&gt;
[2]:https:://github.com/younghz/Markdown &amp;ldquo;Markdown&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库1&lt;/a&gt; &lt;br&gt;
&lt;a href=&#34;https:://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;younghz的Markdown库2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：上述的&lt;code&gt;[1]:https:://github.com/younghz/Markdown &amp;quot;Markdown&amp;quot;&lt;/code&gt;不出现在区块中。&lt;/p&gt;
&lt;h4 id=&#34;49-图片&#34;&gt;4.9 图片&lt;/h4&gt;
&lt;p&gt;添加图片的形式和链接相似，只需在链接的基础上前方加一个&lt;code&gt;！&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;410-反斜杠&#34;&gt;4.10 反斜杠&lt;code&gt;\&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;相当于&lt;strong&gt;反转义&lt;/strong&gt;作用。使符号成为普通符号。&lt;/p&gt;
&lt;h4 id=&#34;411-符号&#34;&gt;4.11 符号&amp;rsquo;`&#39;&lt;/h4&gt;
&lt;p&gt;起到标记作用。如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;`ctrl+a`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ctrl+a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;5-谁在用&#34;&gt;5. &lt;em&gt;谁&lt;/em&gt;在用？&lt;/h4&gt;
&lt;p&gt;Markdown的使用者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;li&gt;简书&lt;/li&gt;
&lt;li&gt;Stack Overflow&lt;/li&gt;
&lt;li&gt;Apollo&lt;/li&gt;
&lt;li&gt;Moodle&lt;/li&gt;
&lt;li&gt;Reddit&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;6-尝试一下&#34;&gt;6. 尝试一下&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chrome&lt;/strong&gt;下的插件诸如&lt;code&gt;stackedit&lt;/code&gt;与&lt;code&gt;markdown-here&lt;/code&gt;等非常方便，也不用担心平台受限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在线&lt;/strong&gt;的dillinger.io评价也不错&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windowns&lt;/strong&gt;下的MarkdownPad也用过，不过免费版的体验不是很好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac&lt;/strong&gt;下的Mou是国人贡献的，口碑很好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt;下的ReText不错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当然，最终境界永远都是笔下是语法，心中格式化 :)。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。
虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]
(&lt;a href=&#34;http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/&#34;&gt;http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/&lt;/a&gt; )。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;以上基本是所有traditonal markdown的语法。&lt;/p&gt;
&lt;h3 id=&#34;其它&#34;&gt;其它：&lt;/h3&gt;
&lt;p&gt;列表的使用(非traditonal markdown)：&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;|&lt;/code&gt;表示表格纵向边界，表头和表内容用&lt;code&gt;-&lt;/code&gt;隔开，并可用&lt;code&gt;:&lt;/code&gt;进行对齐设置，两边都有&lt;code&gt;:&lt;/code&gt;则表示居中，若不加&lt;code&gt;:&lt;/code&gt;则默认左对齐。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码库&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MarkDown&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;https://github.com/younghz/Markdown&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;MarkDownCopy&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/younghz/Markdown&#34; title=&#34;Markdown&#34;&gt;https://github.com/younghz/Markdown&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于其它扩展语法可参见具体工具的使用说明。&lt;/p&gt;
- https://luckfalcon.github.io/post/markdown/ - This is a customized copyright.</description>
        </item>
    
    
    
        <item>
        <title>Effectivecpp</title>
        <link>https://luckfalcon.github.io/post/effectivecpp/</link>
        <pubDate>Mon, 23 Oct 2023 01:47:59 +0800</pubDate>
        
        <guid>https://luckfalcon.github.io/post/effectivecpp/</guid>
        <description>主页 https://luckfalcon.github.io/post/effectivecpp/ -&lt;p&gt;&lt;a href=&#34;http://luckfalcon.github.io&#34;&gt;luckfalcon的github page&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;c编程注意条款&#34;&gt;C++编程注意条款&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;拷贝构造函数 &amp;mdash; 初始化 &amp;mdash;&amp;ndash;A(B)&amp;mdash; 只发生在对象创建时&lt;/li&gt;
&lt;li&gt;拷贝赋值运算符 &amp;ndash; 同类型对象值赋值给创建对象 &amp;ndash;A=B&lt;/li&gt;
&lt;li&gt;值传递（pass-by-value）&amp;ndash; 调用构造函数&lt;/li&gt;
&lt;li&gt;引用传递 (passed-by-reference) &amp;ndash; 不调用构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++四大次级语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c 语言部分编程&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;class 类编程&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;template 模板编程&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;STL 标准库编程&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;条款2尽量以-constenuminline-替换-define&#34;&gt;条款2：尽量以 const，enum，inline 替换 #define&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;#define 没有作用域概念，且不做类型检查，仅仅是变量替换 (包括变量的前后缀，表达式代入)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#define max(a,b) f((a) &amp;gt; (b)? (a) : (b))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;,b = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#008b45&#34;&gt;max&lt;/span&gt;(++a, b);	&lt;span style=&#34;color:#228b22&#34;&gt;//a被累加2次
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#008b45&#34;&gt;max&lt;/span&gt;(++a, b+&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;);	&lt;span style=&#34;color:#228b22&#34;&gt;//a被累加1次
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;enum hack (枚举hack) 常用来初始化类内数组大小，是模板元编程的基础技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//此处仅为声明而非定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; arr[num];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num;&lt;span style=&#34;color:#228b22&#34;&gt;//此处为定义,放在实现文件中而非头文件中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;enum&lt;/span&gt;{num = &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;}&lt;span style=&#34;color:#228b22&#34;&gt;//可代替上 static const int 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;enum&lt;/span&gt; {arr_size = &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;};&lt;span style=&#34;color:#228b22&#34;&gt;//在编译器不支持编译期间类内static初值时(仅限整数情况)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; arr[arr_size];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;const 对象替换 define 常量&lt;/li&gt;
&lt;li&gt;inline 函数替换 define 形似函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款3尽可能使用-const&#34;&gt;条款3：尽可能使用 const&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;令函数返回一个常量值，可以降低客户错误和意外发生，而不至于放弃安全性和高效性&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//有理数operator*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Rational&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;*(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;lhs,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;rhs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//可以避免客户暴力行为如:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;Rational a,b,c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(a * b) = c;&lt;span style=&#34;color:#228b22&#34;&gt;//在a*b的结果上调用赋值运算符operator =
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;const 成员函数，可确保类的 const 对象可被操作&lt;/li&gt;
&lt;li&gt;如过函数的返回类型是内置类型，改动函数返回值是非法的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; &amp;amp;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;[](std::size_t position)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//处理const对象，不可修改对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	{&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; st[position];}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&amp;amp;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;[](std::size_t position)&lt;span style=&#34;color:#228b22&#34;&gt;//处理非const对象,可修改对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	{&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; st[position];}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::string st;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;将类成员声明为 mutable 类型，可以实现在 const 对象内修改对象的值，但并能完全解决 const 与 non-const 的全部问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Text&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::size_t length()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *ptex;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;mutable&lt;/span&gt; std::size_t textlength;&lt;span style=&#34;color:#228b22&#34;&gt;//这些变量可以被修改，即使在const对象内部
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;mutable&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; LengthIsValid;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::size_t Text:: length()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!LengthIsValid)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		textlength = strlen(ptex);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		LengthIsValid = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; textlength;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在 const 和 non-const 成员函数中避免重复使用，策略是利用 non-const 调用 const 的版本来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;[](std::size_t position)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; &amp;amp;&amp;gt;(		&lt;span style=&#34;color:#228b22&#34;&gt;//将op[]返回值去除const
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; text &amp;amp;&amp;gt;(*&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;)&lt;span style=&#34;color:#228b22&#34;&gt;//为this加上const，调用const op[]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		)&lt;span style=&#34;color:#228b22&#34;&gt;//若不给this加const，则会无限递归自己
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将某些东西声明为 const 可以帮助编译器检查错误用法。const 可以被加在任何作用域内的对象、函数参数、函数返回类型、成员函数。&lt;/li&gt;
&lt;li&gt;编译器强制 bitwise constness (位常量性)，但你编程时应使用 &amp;ldquo;概念上的常量性&amp;rdquo; (conceptual constness)。&lt;/li&gt;
&lt;li&gt;当 const 函数与 non-const 函数有等价的实现时，用 non-const 版本调用 const 版本可避免代码重复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款4确定对象被使用前已先被初始化&#34;&gt;条款4：确定对象被使用前已先被初始化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;未初始化对象可导致未定义行为 (undefined behavior)，最终导致程序错误。&lt;/li&gt;
&lt;li&gt;永远在对象使用之前对其初始化，内置类型直接初始化，类类型由其构造函数完成初始化(类成员初始化发生在构造函数体之前，构造函数体内为赋值，初始化类成员应使用类成员初始化列表)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Obj(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i_nit,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c_init,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; string &amp;amp;s_init)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		:i(i_nit),c(c_init),s(s_init){}&lt;span style=&#34;color:#228b22&#34;&gt;//初始化，通常效率更高
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	Obj(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i_nit,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c_init,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; string &amp;amp;s_init)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		i = i_nit;&lt;span style=&#34;color:#228b22&#34;&gt;//赋值，会先调用default构造函数，再进行拷贝赋值=
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		c = c_init;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		s = s_init;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	string s;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;c++对&amp;quot;定义于不同编译单元内的 non-local static 对象&amp;quot;的初始化&lt;strong&gt;次序&lt;/strong&gt;并无明确定义。通过设计消除这种情况，做法是，将每个 non-local static 对象搬到自己的专属函数内(该对象在此函数内被声明为 static)。这些函数返回一个 reference 指向它所含的对象。用户调用这些函数获得 static 对象的引用，而非直接使用 static 对象本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编译单元 (translation unit) 是指产出单一目标文件 (sigle object file) 的源码。基本上它是单一源码文件加上其所含入的头文件 (#include file)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Ob1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Ob1 &amp;amp;obj()&lt;span style=&#34;color:#228b22&#34;&gt;//在类外定义为内联函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Ob1 ob;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ob;&lt;span style=&#34;color:#228b22&#34;&gt;//指向static对象的reference，而不再使用static对象自身
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内置类型手动初始化。&lt;/li&gt;
&lt;li&gt;构造函数使用成员的初始化列表初始化，而非构造函数体内进行赋值，成员初始化次序最好与声明次序相同。&lt;/li&gt;
&lt;li&gt;为免除&amp;quot;跨编译单元初始化次序&amp;quot;问题，以 local static 对象替换 non-local static 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款5了解c默默写并调用哪些函数&#34;&gt;条款5：了解c++默默写并调用哪些函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空类，编译器默认生成一个无实参的 default 构造函数、一个有实参拷贝构造函数、一个拷贝赋值运算符、一个析构函数。&lt;/li&gt;
&lt;li&gt;用户自定义构造函数后，default 构造函数不指定则编译器不再提供。&lt;/li&gt;
&lt;li&gt;对于成员类型为引用的类，编译器默认不生成拷贝赋值运算符(原因是 c++不允许改变引用的对象)。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assighnment 操作符，以及析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款6若不想使用编译器自动生成的函数就该明确拒绝&#34;&gt;条款6：若不想使用编译器自动生成的函数，就该明确拒绝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为了阻止类的拷贝赋值行为，你可以通过继承一个基类的拷贝复制操作是 private 的类来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Uncopy&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Uncopy();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	~Uncopy();&lt;span style=&#34;color:#228b22&#34;&gt;//由于非虚函数，会带来多重继承的问题
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Uncopy(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Uncopy&amp;amp;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Uncopy &amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Uncopy&amp;amp;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Uncopy{};&lt;span style=&#34;color:#228b22&#34;&gt;//此时class Obj不再声明copy函数或copy assighnment操作符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为驳回编译器自动提供的技能，可将相应的成员函数声明为 private 并且不予实现，如 uncopy 基类的做法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款7为多态基类声明virtual析构函数&#34;&gt;条款7：为多态基类声明virtual析构函数&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Base&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Base();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;function&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//带有虚成员函数的类才需要虚析构函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; ~Base();&lt;span style=&#34;color:#228b22&#34;&gt;//析构函数声明为虚函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DerivedA&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Base{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DerivedB&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;protected&lt;/span&gt; Base{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;DerivedC&lt;/span&gt; :&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Base{};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;每个带有 virtual 函数的 class 都有一个相应的 vtbl(virtual table)，在运行时，由 vptr(virtual table pointer) 指出，从而实现带 virtual 函数。将不含 virtual 函数的类的析构函数声明为 virtual 会影响类的可移植性。&lt;/li&gt;
&lt;li&gt;基类的析构函数非 virtual 的时，不要使用基类指针指向派生类，否则在销毁基类指针时无法调用派生类的析构函数，从而造成内存泄漏。&lt;/li&gt;
&lt;li&gt;pure virtual 析构函数的类为抽象类，无法实例化，只适合做基类。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; ~Obj() = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//纯虚函数,该类为抽象类，无法实例化，只适合做基类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obj::~Obj(){};&lt;span style=&#34;color:#228b22&#34;&gt;//纯虚函数的定义,不做这个定义，连接器会出错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;并非所有的基类设计都是为多态用途，即不是所有的基类都需要 virtual 析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;polymorphic (带有多态性质的) base classes应该声明一个 virtual 析构函数。如何 class 带有 virtual 函数，那么应该声明 virtual 析构函数。&lt;/li&gt;
&lt;li&gt;classes 的设计目的如果不是作为 base classes 使用，或者不是为了具备多态性 (polymorphically) ，就不应该声明 virtual 析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款8别让异常逃离析构函数&#34;&gt;条款8：别让异常逃离析构函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;c++不希望在类的析构函数中抛出异常(这会导致一些容器由于多个类对象析构异常而导致不明确行为)&lt;/li&gt;
&lt;li&gt;转接给客户一次处理异常的机会&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; obj create();&lt;span style=&#34;color:#228b22&#34;&gt;//返回一个obj对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;closed&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//关闭，失败会抛出异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Manageobj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; closed()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		closed();&lt;span style=&#34;color:#228b22&#34;&gt;//非析构函数抛出异常可供用户选择处理,若在析构函数内，用户无法处理，只能选择终止或者忽略异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		closed = &lt;span style=&#34;color:#658b00&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	~Manageobj()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(!closed)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				closed();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#228b22&#34;&gt;//记录close调用失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Obj oj;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;bool&lt;/span&gt; closed;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(阻止不传播)或结束程序。&lt;/li&gt;
&lt;li&gt;如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通的函数(而非在析构函数中)执行该操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款9绝不在构造和析构过程中调用virtual函数&#34;&gt;条款9：绝不在构造和析构过程中调用virtual函数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class (比起当前执行构造函数和析构函数的那层)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款10令operator--返回一个reference-to-this&#34;&gt;条款10：令operator = 返回一个reference to *this&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Obj &amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Obj&amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}&lt;span style=&#34;color:#228b22&#34;&gt;//为了实现 x = y = z = Value;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;令赋值(assignment)操作符返回一个reference to *this。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款11在-operator--中处理自我赋值&#34;&gt;条款11：在 operator = 中处理“自我赋值”&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;让 operator = 具备&amp;quot;异常安全性&amp;quot;同时也会获得&amp;quot;自我赋值安全&amp;quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Op&lt;/span&gt;{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Op *ptr; &lt;span style=&#34;color:#228b22&#34;&gt;//类成员含有指针或引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obj &amp;amp;Obj::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Obj &amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Op *p = ptr;		&lt;span style=&#34;color:#228b22&#34;&gt;//记住原先的ptr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	ptr = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Op(rhs.ptr);&lt;span style=&#34;color:#228b22&#34;&gt;//令ptr指向*ptr的一个副本
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; p;			&lt;span style=&#34;color:#228b22&#34;&gt;//删除原先的ptr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;复制交换 (copy and swap) 技术，可以作为上述方案的替代方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Op&lt;/span&gt;{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; swap(Obj &amp;amp;rhs);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Op *ptr; &lt;span style=&#34;color:#228b22&#34;&gt;//类成员含有指针或引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obj &amp;amp;Obj::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Obj &amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Op &lt;span style=&#34;color:#008b45&#34;&gt;temp&lt;/span&gt;(rhs);&lt;span style=&#34;color:#228b22&#34;&gt;//将rhs数据制作一份副本
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	swap(temp);&lt;span style=&#34;color:#228b22&#34;&gt;//将*this数据和上述副本的数据交换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//值传递(passed by value)--有时候可令编译器生成高效的代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;Obj &amp;amp;Obj::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; = (Obj rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	swap(ths);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;确保当对象自我赋值时 perator = 有良好的行为。其中的技术包括比较&amp;quot;来源对象&amp;quot;和&amp;quot;目标对象&amp;quot;的地址、精心周到的语句顺寻、以及 copy-and-swap。&lt;/li&gt;
&lt;li&gt;确定任何函数如何操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款12复制对象时勿忘其每一个成分&#34;&gt;条款12：复制对象时勿忘其每一个成分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;derived class 的 base class 成分在 derived class 的构造函数中应调用 base class 的构造函数完成。&lt;/li&gt;
&lt;li&gt;不应该令 copy assignment 操作符调用 copy 构造函数，反之也同样没有意义。&lt;/li&gt;
&lt;li&gt;如果 copy assignment 操作符和 copy 构造函数有相同重复的代码，通常在 private 区设置一个 init 函数将相同部分代码包含进去。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;copy&lt;/strong&gt;&lt;/em&gt;函数 (copy assignment 操作符和 copy 构造函数统称) 应该确保复制&amp;quot;对象内的所有成员变量&amp;quot;及&amp;quot;所有 base class 成分&amp;quot;。&lt;/li&gt;
&lt;li&gt;不要尝试以某个 copy 函数实现另一个 copy 函数。应该将共同机能放进第三个函数中，并由两个 copy 函数共同调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款13以对象管理资源&#34;&gt;条款13：以对象管理资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取资源后立即放进管理对象内，管理对象运用析构函数确保资源被释放。以对象管理资源常被称为资源取得时机便是初始化时机 (Resource Acquisition Is Initialization,&lt;em&gt;&lt;strong&gt;RAII&lt;/strong&gt;&lt;/em&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Obj *create();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;f&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{		&lt;span style=&#34;color:#228b22&#34;&gt;//c++11后已经弃用auto_ptr,用unique_ptr代替
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//这样做的前提是绝对没有一个以上的auto_ptr同时指向该对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	std::auto_ptr&amp;lt;Obj&amp;gt;p_Obj(create());&lt;span style=&#34;color:#228b22&#34;&gt;//auto_ptr为一个类指针对象模板
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;auto_ptrs 一个特殊性质：若通过 (copy assignment 操作符和 copy 构造函数复制它们，它们会变成 null，而复制所得的指针将取得资源的唯一拥有权。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::auto_ptr1&amp;lt;Obj&amp;gt;p_Obj(create());&lt;span style=&#34;color:#228b22&#34;&gt;//ptr1指向create返回对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	std::auto_ptr2(ptr1);		&lt;span style=&#34;color:#228b22&#34;&gt;//ptr2指向该对象，ptr1被置为null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	ptr1 = ptr2;			&lt;span style=&#34;color:#228b22&#34;&gt;//ptr1指向该对象，ptr2被置为null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;克服 auto_ptr 的弊端，改用引用计数智能指针 (reference-counting smart pointer,RCSP)，如 shared_ptr。&lt;/li&gt;
&lt;li&gt;没有针对 &amp;ldquo;c++动态分配数组&amp;rdquo; 的智能指针，因为 vector 和 string 几乎可以完全代替动态分配数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为防止资源泄露，请使用RAII对象，它们在构造函数中获取资源并在析构函数中释放资源。&lt;/li&gt;
&lt;li&gt;两个常用的 RAII classes 分别是 tr1::shared_ptr 和 auto_ptr(c++11后用 unique_ptr)。前者通常是最佳选择，因为其 copy 行为比较直观。若选择 auto_ptr，复制动作会使它 (被复制物) 指向 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款14在资源管理类中小心coping行为&#34;&gt;条款14：在资源管理类中小心coping行为&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为 (通常需要深拷贝) 决定 RAII 对象的 copying 行为。&lt;/li&gt;
&lt;li&gt;普通而常见的 RAII class copying 行为：抑制 copying、(可用 shared_ptr) 施行引用计数方法 (reference counting)。不过其他行为也都可能实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款15在资源管理类中提供对原始资源的访问&#34;&gt;条款15：在资源管理类中提供对原始资源的访问&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;APIs 往往要求访问原始资源 (raw resources)，所以每个 RAII class 应该提供一个&amp;quot;取得其所管理之资源&amp;quot;的办法。&lt;/li&gt;
&lt;li&gt;对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款16成对使用new和delete时要采用相同形式&#34;&gt;条款16：成对使用new和delete时要采用相同形式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;new 表达式中使用 []，必须在相应的 delete 表达式中也使用[]。new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款17以独立语句将-newed-对象置入智能指针&#34;&gt;条款17：以独立语句将 newed 对象置入智能指针&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;func1&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;func2&lt;/span&gt;(shared_ptr&amp;lt;obj&amp;gt;,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;func2(shared_ptr&amp;lt;obj&amp;gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; obj),func1());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//此处编译器要进行三个过程，new Obj、调用shared_ptr初始化指针、调用func1,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//但三者没有固定顺序，若func1发生在其它两个过程之间，且发生异常，则会导致new Obj发生泄漏
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;以独立语句将 newed 对象存入(置入)智能指针内。如果不这样，一旦异常被抛出，有可能导致难以察觉的资源泄漏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款18让接口容易被正确使用不易被误用&#34;&gt;条款18：让接口容易被正确使用，不易被误用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量让你的 types 的行为与内置 types 一致。&lt;/li&gt;
&lt;li&gt;返回 shared_ptr 让接口设计者得以阻止大部分资源泄漏错误。&lt;/li&gt;
&lt;li&gt;智能指针管理非 new 的资源时需要手动传入一个删除器。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达到这个性质。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;促进争取使用&amp;quot;的办法包括接口的一致性，以及与内置类型的行为兼容。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;阻止误用&amp;quot;的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。&lt;/li&gt;
&lt;li&gt;shared_ptr 支持定制型删除器 (custom deleter)。这可防止 DLL (动态链接库)问题，可被用来自动解除互斥锁 (mutexes) 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓的 &amp;ldquo;cross-DLL problem&amp;rdquo;，这个问题发生于&amp;quot;对象在动态连接程序库 (DLL) 中被 new 创建，却在另一个 DLL 内被 delete
销毁&amp;rdquo;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款19设计-class-犹如设计-type&#34;&gt;条款19：设计 class 犹如设计 type&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;新 class 设计规范问题：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;新的 type 应该如何被创建和销毁？&lt;/li&gt;
&lt;li&gt;对象的初始化和对象的赋值该有什么样的差别？&lt;/li&gt;
&lt;li&gt;新 type 对象如果被 passed by value (以值传递)，意味着什么？&lt;/li&gt;
&lt;li&gt;什么是新 type 的&amp;quot;合法值&amp;rdquo;？&lt;/li&gt;
&lt;li&gt;你的新 type 需要配合某个继承图系 (inheritance graph) 吗？&lt;/li&gt;
&lt;li&gt;你的新 type 需要什么样的转换？&lt;/li&gt;
&lt;li&gt;什么样的操作符和函数对此新 type 而言是合理的？&lt;/li&gt;
&lt;li&gt;什么样的标准函数应该驳回？&lt;/li&gt;
&lt;li&gt;谁该取用新 type 的成员？&lt;/li&gt;
&lt;li&gt;什么是新 type 的&amp;quot;未声明接口&amp;quot;？&lt;/li&gt;
&lt;li&gt;你的新 type 有多么一般化？&lt;/li&gt;
&lt;li&gt;你真的需要一个新 type 吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;class 的设计就是 type 的设计。在定义一个新type时请考虑以上问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款20宁可以-passed-by-reference-to-const-替换-passed-by-value&#34;&gt;条款20：宁可以 passed-by-reference-to-const 替换 passed-by-value&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;缺省情况下 C++ 以 by value 方式传递对象至函数。&lt;/li&gt;
&lt;li&gt;一般而言，pass by value 唯一对象是内置类型和 STL 的迭代器和函数对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;尽量以 passed-by-reference-to-const 替换 passed-by-value。前者通常高效，并可避免切割问题 (slicing problem)。&lt;/li&gt;
&lt;li&gt;以上规则不适合内置类型，以及STL的迭代器和函数对象。对它们而已，passed-by-value往往比较适当。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款21必须返回对象时别妄想返回其reference&#34;&gt;条款21：必须返回对象时，别妄想返回其reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个&amp;quot;必须返回新对象&amp;quot;的正确写法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Rational&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 Rational(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; numerator = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; denominator = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n;&lt;span style=&#34;color:#228b22&#34;&gt;//分子(numerator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; d;&lt;span style=&#34;color:#228b22&#34;&gt;//分母(denominator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;*(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;lhs,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Rational&lt;/span&gt;(lhs.n*rhs.n,lhs.d*rhs.d);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款22将成员变量声明为-private&#34;&gt;条款22：将成员变量声明为 private&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。&lt;/li&gt;
&lt;li&gt;protected 并不比 public 更具封装性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款23宁以-non-membernon-friend-替换-member-函数&#34;&gt;条款23：宁以 non-member、non-friend 替换 member 函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以扩展这一组便利函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// class_def.h
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; fun1();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fun2&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fun3&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;do_fun1&lt;/span&gt;(Obj &amp;amp;oj){oj.fun1();}&lt;span style=&#34;color:#228b22&#34;&gt;//核心机能，包含客户都需要的non-member函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;do_fun3&lt;/span&gt;(Obj &amp;amp;oj){oj.fun3();}&lt;span style=&#34;color:#228b22&#34;&gt;//非成员函数可以进一步提高class的封装性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//fun1_use.h//客户扩展头文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fun1&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;宁以拿 non-member、non-friend 替换 member 函数。这样可以增加封装性、包裹弹性 (packaging flexibility) 和机能扩充性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款24若所有参数皆需类型转换请为此采用-non-member-函数&#34;&gt;条款24：若所有参数皆需类型转换，请为此采用 non-member 函数&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Rational&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 Rational(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; numerator = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; denominator = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;numerator&lt;/span&gt;()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;denominator&lt;/span&gt;()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n;&lt;span style=&#34;color:#228b22&#34;&gt;//分子(numerator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; d;&lt;span style=&#34;color:#228b22&#34;&gt;//分母(denominator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//非成员友元函数声明方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;*(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;lhs,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Rational&lt;/span&gt;(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果你需要为某个函数的所有参数 (包括被 this 指针所指的那个隐喻参数) 进行类型转换，那么这个函数必须是 non-member 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款25考虑写出一个不抛出异常的-swap-函数&#34;&gt;条款25：考虑写出一个不抛出异常的 swap 函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;所有的 STL 容器都提供有一个 public swap 成员函数和 std::swap 特化版本 (用以调用前者)。&lt;/li&gt;
&lt;li&gt;c++ 只允许对 class template 偏特化 (partially specialize)，但不能对 function template 偏特化。&lt;/li&gt;
&lt;li&gt;c++ std 空间可以全特化所有内含 template，但不可以添加新的 template 进去。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; name_obj
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; swap(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Obj &amp;amp;b){&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; std::swap;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;swap&lt;/span&gt;(Obj&amp;lt;T&amp;gt; &amp;amp;a,Obj&amp;lt;T&amp;gt; &amp;amp;b){a.swap(b);}&lt;span style=&#34;color:#228b22&#34;&gt;//合法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std&lt;span style=&#34;color:#228b22&#34;&gt;//在std内特化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; swap&amp;lt;Obj&amp;gt;(obj &amp;amp;a,Obj &amp;amp;b){a.swap(b);};&lt;span style=&#34;color:#228b22&#34;&gt;//特例化某个类，合法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//Obj成为类模板的时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; swap&amp;lt;Obj&amp;lt;T&amp;gt;&amp;gt;(Obj&amp;lt;T&amp;gt; &amp;amp;a,Obj&amp;lt;T&amp;gt; &amp;amp;b){a.swap(b);}&lt;span style=&#34;color:#228b22&#34;&gt;//函数模板偏特化，错误，不合法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; swap(Obj&amp;lt;T&amp;gt; &amp;amp;a,Obj&amp;lt;T&amp;gt; &amp;amp;b){a.swap(b);}&lt;span style=&#34;color:#228b22&#34;&gt;//也不合法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;pimpl 是 &amp;ldquo;pointer to implementation&amp;rdquo; 的缩写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;swap 的版本包含，default swap (适合不含指针成员的类或类模板)、member swap、non-member swap、std::swap 特化版。&lt;/li&gt;
&lt;li&gt;如果缺省 swap 效率不足 (class 或 template 使用了某种 pimpl 手法)，可试以下方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值。该函数不应抛出异常。&lt;/li&gt;
&lt;li&gt;在你的 class 或 template 所在的命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。&lt;/li&gt;
&lt;li&gt;如果你正编写一个 class (而非 class template)，为你的 class 特化 std::swap。并令它调用你的 swap 成员函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;swap 一个最好的应用是帮助 classes( 和 class templates) 提供强烈的异常 (exception-safety) 保障。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当 std::swap 对你的类型效率不高时，提供一个成员 swap 函数，并确定这个函数不抛出异常。&lt;/li&gt;
&lt;li&gt;如果你提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于 class (而非 template)，也请特化 std::swap。&lt;/li&gt;
&lt;li&gt;调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何&amp;quot;命名空间资格修饰&amp;quot;。&lt;/li&gt;
&lt;li&gt;为&amp;quot;用户定义类型&amp;quot;进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;&lt;em&gt;&lt;strong&gt;实现 (implementations)&lt;/strong&gt;&lt;/em&gt;&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款26尽可能延后变量定义式的出现时间&#34;&gt;条款26：尽可能延后变量定义式的出现时间&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目的是减少不必要的对象构造和析构&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Obj&lt;/span&gt;{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Obj oj;	&lt;span style=&#34;color:#228b22&#34;&gt;//A：1次构造+1次析构+n次赋值				
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i;i &amp;lt; n;++i)	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	oj = i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i;i &amp;lt; n;++i)	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Obj oj;	&lt;span style=&#34;color:#228b22&#34;&gt;//B：n次构造+n次析构，通常B比A更高效一点，除非，赋值比构造+析构成本低
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	oj = i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款27尽量少做转型动作&#34;&gt;条款27：尽量少做转型动作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;c++ 类型转换形式 :&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;const_cast&lt;!-- raw HTML omitted --&gt;(expression)&lt;/th&gt;
&lt;th&gt;dynamic_cast&lt;!-- raw HTML omitted --&gt;(expression)&lt;/th&gt;
&lt;th&gt;reinterpret_cast&lt;!-- raw HTML omitted --&gt;(expression)&lt;/th&gt;
&lt;th&gt;static_cast&lt;!-- raw HTML omitted --&gt;(expression)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;const 到 non-const 转换&lt;/td&gt;
&lt;td&gt;运行时，安全向下类型转换&lt;/td&gt;
&lt;td&gt;执行低级转型&lt;/td&gt;
&lt;td&gt;除去 const 到 non-const 的转换，其他一般类型转换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。&lt;/li&gt;
&lt;li&gt;如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码内。&lt;/li&gt;
&lt;li&gt;宁可使用 C++-style (新式) 转型，不要使用旧式转型。前者容易辨识出来，而且也比较有着分门别类的执掌。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款28避免返回-handles-指向对象内部成分&#34;&gt;条款28：避免返回 handles 指向对象内部成分&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;避免 handles (包括 references、指针、迭代器)指向对象内部。遵守这个条款可以增加封装性，帮助 const 成员函数的行为像个 const，并将发生&amp;quot;虚吊号码牌&amp;quot;(dangling handles) 可能降到最低。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;虚吊号码牌：使用已经销毁的对象的引用、指针或迭代器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款29为异常安全而努力是值得的&#34;&gt;条款29：为&amp;quot;异常安全&amp;quot;而努力是值得的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;异常安全性两个条件：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;异常抛出时，不泄漏任何资源。&lt;/li&gt;
&lt;li&gt;异常抛出时，不允许数据败坏。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;异常安全函数提供三种不同级别保证：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本保证&lt;/th&gt;
&lt;th&gt;强烈保证&lt;/th&gt;
&lt;th&gt;不抛保证&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;异常抛出后，程序内所有事物保持有效状态，这些状态是未预知的&lt;/td&gt;
&lt;td&gt;异常抛出后，程序状态不改变，回到被调用前状态&lt;/td&gt;
&lt;td&gt;承诺不抛出异常，因其总能完成原有的功能。作用于内置类型所有操作应提供 nothrow 保证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;异常安全函数 (Exception-safty functions) 即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;强烈保证&amp;rdquo; 往往能够以 copy-and-swap 实现出来，但&amp;quot;强烈保证&amp;quot;并非对所有函数都可实现或具备现实意义。&lt;/li&gt;
&lt;li&gt;函数提供 &amp;ldquo;异常安全保证&amp;rdquo; 通常最高只等于其所调用之各个函数的&amp;quot;异常安全保证&amp;quot;中的最弱者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款30透彻了解-inlining-的里里外外&#34;&gt;条款30：透彻了解 inlining 的里里外外&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;inlining 在大多数 c++ 程序中是编译期行为。&lt;/li&gt;
&lt;li&gt;inline 函数通常一定被置于头文件中，通常置于函数本体小的函数前，向编译器申请在调用处替换展开本体，但非强制命令，编译器可忽略。&lt;/li&gt;
&lt;li&gt;对于函数本体较大的函数 inlining 会引发代码膨胀。&lt;/li&gt;
&lt;li&gt;编译器通常不会对 &amp;ldquo;通过函数指针而进行的调用&amp;rdquo; 实施 inlining。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级 (binary upgradability) 更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。&lt;/li&gt;
&lt;li&gt;不要只因为 function templates 出现在头文件，就将它们声明为 inline。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款31将文件间的编译依存关系降至最低&#34;&gt;条款31：将文件间的编译依存关系降至最低&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将接口与实现分离。&lt;/li&gt;
&lt;li&gt;编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其
他文件内的声明式〈而非定义式) 相依 &amp;ndash; 该设计策略如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果使用 object references 或 object pointers 可以完成任务，就不要使用
objects。&lt;/li&gt;
&lt;li&gt;如果能够，尽量以 class 声明式替换 class 定义式。&lt;/li&gt;
&lt;li&gt;为声明式和定义式提供不同的头文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性〈compilation dependencies) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在 Handle classes 身上，成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。&lt;/li&gt;
&lt;li&gt;至于 Interface classes，由于每个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃 〈indirect jump) 成本(见条款 7) 。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;支持 &amp;quot; 编译依存性最小化 &amp;quot; 的一般构想是: 相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。&lt;/li&gt;
&lt;li&gt;程序库头文件应该以 &amp;quot; 完全且仅有声明式 &amp;quot; (full and declaration-only forms) 的形式存在。这种做法不论是否涉及templates 都适用。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;六、继承与面向对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款32确定你的-public-继承塑模出-is-a-关系&#34;&gt;条款32：确定你的 public 继承塑模出 is-a 关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以 C++ 进行面向对象编程，最重要的一个规则是：public inheritance (公开继承) 意味 &amp;ldquo;is-a&amp;rdquo;〈是一种) 的关系。&lt;/li&gt;
&lt;li&gt;is-a 并非是唯一存在于 classes 之间的关系。另两个常见的关系是 has-a(有一个) 和 is-implemented-in-terms-of (根据某物实现出)。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;public 继承&amp;quot;意味 is-a。适用于 base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-33避免遮掩继承而来的名称&#34;&gt;条款 33：避免遮掩继承而来的名称&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;内层作用域的名称会遮掩 (遮蔽) 外围作用域的名称。&lt;/li&gt;
&lt;li&gt;编译器查找名称规则由内层作用域查找到名称后即停止查找，并不关注类型。&lt;/li&gt;
&lt;li&gt;derived class 作用域被嵌套在 base class 作用域内。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;derived classes 内的名称会遮掩 base classes 内的名称。 在 public 继承下从来没有人希望如此。&lt;/li&gt;
&lt;li&gt;为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数 (forwarding functions) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;using 声明式和转交函数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;base&lt;/span&gt;{ &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; fun1(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x);};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived1&lt;/span&gt; : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; base
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; base::fun1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;fun1&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived1&lt;/span&gt; : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; base
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; fun1()&lt;span style=&#34;color:#228b22&#34;&gt;//转交函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;   {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   	base::fun1();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;条款-34区分接口继承和实现继承&#34;&gt;条款 34：区分接口继承和实现继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pure virtual 函数有两个最突出的特性：它们必须被任何 &amp;quot; 继承了它们 &amp;quot; 的具象 class 重新声明，而且它们在抽象 class 中通常没有定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;derived classes 继承其函数接口, 但 impure virtual 函数会提供一份实现代码, derived classes 可能覆写 (override) 它。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;声明简朴的(非纯) impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;pure virtual 函数&lt;/th&gt;
&lt;th&gt;simple (impure) virtual 函数&lt;/th&gt;
&lt;th&gt;non-virtual 函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;只继承接口&lt;/td&gt;
&lt;td&gt;继承接口和一份缺省实现&lt;/td&gt;
&lt;td&gt;继承接口和一份强制实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot; 80 - 20 &amp;quot; 法则：一个典型的程序有 80% 的执行时间花费在 20 % 的代码身上。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;接口继承和实现继承不同。在 public 继承之下，derived classes 总是继承 base class 的接口。&lt;/li&gt;
&lt;li&gt;pure virtual 函数只具体指定接口继承。&lt;/li&gt;
&lt;li&gt;简朴的(非纯) impure virtual 函数具体指定接口继承及缺省实现继承。&lt;/li&gt;
&lt;li&gt;non-virtual 函数具体指定接口继承以及强制性实现继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-35考虑-virtual-函数以外的其他选择&#34;&gt;条款 35：考虑 virtual 函数以外的其他选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 Non-Virtual Interface 手法实现 Template Method 模式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Base&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; fun()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//这个no-virtual 函数为 virtual 函数的外覆器 (wrapper)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; relval=dofun();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; relval;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; dofun()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;{...};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;令客户通过 public non-virtual 成员函数间接调用 private virtual 函数 &amp;ndash; 为 non-virtual interface (NVI) 手法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;derived classes 可重新定义继承而来的 private virtual 函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通过 Function Pointers 实现 Strategy 模式&lt;/li&gt;
&lt;li&gt;通过 函数模板 function &amp;lt; T &amp;gt; 完成 Strategy 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;trl1: :bind，可改变可调对象入口参数个数和顺序，同时返回一个新的可调对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;古典的 Strategy 模式 (设计模式 (design patterns))。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;几种 virtual 函数替代方案如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用 non-virtual interface (NVI) 手法，那是 Template Method 设计模式的一种特殊形式。它以 public non-virtual 成员函数包庄较低访问性(private 或 protected)的 virtual 函数。&lt;/li&gt;
&lt;li&gt;将 virtual 函数替换为 &amp;quot; 函数指针成员变量 &amp;ldquo;，这是 Strategy 设计模式的一种分解表现形式。&lt;/li&gt;
&lt;li&gt;以 trl::function 成员变量替换 virtual 函数，因而允许使用任何可调用物(callable entity ) 搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。&lt;/li&gt;
&lt;li&gt;将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。这是 Strategy 设计模式的传统实现手法。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;virtual 函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式。NVI手法自身是一个特殊形式的 Template Method 设计模式。&lt;/li&gt;
&lt;li&gt;将机能从成员函数移到 class 外部函数，带来的一个缺点是，非成员函数无法访问 class 的 non-public 成员。&lt;/li&gt;
&lt;li&gt;trl::function 对象的行为就像一般函数指针。这样的对象可接纳 &amp;quot; 与给定之目标签名式 (target signature) 兼容 &amp;quot; 的所有可调用物(callable entities)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-36绝不重新定义继承而来的-non-virtual-函数&#34;&gt;条款 36：绝不重新定义继承而来的 non-virtual 函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;derived classes 绝对不该重新定义一个继承而来的non-virtual 函数〈此处指的是 base class 析构函数) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绝对不要重新定义继承而来的 non-virtual 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-37-绝不重新定义继承而来的缺省默认参数值&#34;&gt;条款 37: 绝不重新定义继承而来的缺省(默认)参数值&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;只能继承两种函数: virtual 和 non-virtual 函数。&lt;/li&gt;
&lt;li&gt;virtual 函数系动态绑定(dynamically bound) ，而缺省(默认)参数值却是静态绑定〈statically bound) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对象的所谓静态类型 〈static type) ，就是它在程序中被声明时所采用的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;对象的所谓动态类型(dynamic tvpe) 则是指 &amp;quot; 目前所指对象的类型 &amp;ldquo;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;base&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; set(base b = bs)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//带有默认参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;；&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; base
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; set(base b = bs)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//会出现重复定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;set&lt;/span&gt;(base b = ds)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//默认参数不一样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;set&lt;/span&gt;(base b)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;&lt;span style=&#34;color:#228b22&#34;&gt;//动态绑定(base指针引用访问时)时才会继承base默认参数，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//静态绑定(derived对象访问)时不会继承默认参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;条款35列了不少 virtual 函数的替代设计，其中之一是 NVI (non-virtual interface) 手法令 base class 内的一个 public non-virtual 函数调用 private virtual 函
数，后者可被 derived classes 重新定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数一一你唯一应该覆写的东西一一却是动态绑定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-38-通过复合塑模出-has-a-或--根据某物实现出-&#34;&gt;条款 38: 通过复合塑模出 has-a 或 “ 根据某物实现出 ”&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;复合(composition) 是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;复合(composition) 这个术语有许多同义词，包括 layering (分层) ，constainment(内含) , aggregation (聚合) 和 embedding (内嵌)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用域(appjicarion domain)与实现域(implementation domain)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;程序中的对象其实相当于你所塑造的世界中的某些事物(如人、汽车)，这样的对象属于应用域 (appjicarion domain) 部分。&lt;/li&gt;
&lt;li&gt;其他对象则纯粹是实现细节上的人工制品(如缓冲区、互斥锁)，这些对象相当于你的软件的实现域。&lt;/li&gt;
&lt;li&gt;当复合发生于应用域内的对象之间，表现出 has-a 的关系; 当它发生于实现域内则是表现 is-implemented-in-terms-of 的关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;set 和 list 的关系非 is-a 关系，而是 is-implemented-in-terms-of 关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;复合(composition) 的意义和 public 继承完全不同。&lt;/li&gt;
&lt;li&gt;在应用域 (application domain) ，复合意味 has-a (有一个)。在实现域(implementation domain) ，复合意味 is-implemented-in-terms-of (根据某物实现出) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-39-明智而审慎地使用-private-继承&#34;&gt;条款 39: 明智而审慎地使用 Private 继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Private 继承意味 is-implemented-in-terms-of (根据某物实现出)。&lt;/li&gt;
&lt;li&gt;尽可能使用复合，必要时才使用 private 继承。&lt;/li&gt;
&lt;li&gt;private 继承主要用于 &amp;quot; 当一个意欲成为 derived class 者想访问一个意欲成为 base class 者的 protected 成分，或为了重新定义一或多个 virtual 函数 &amp;ldquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;empty&lt;/span&gt;{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(empty) = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; empty
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(derived)==&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//编译器 EBO (empty base optimization; 空白基类最优化)，一般发生在单一继承才可行，多继承则不会发生。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;现实中的 &amp;quot; empty &amp;quot; classes 并不真的是 empty，往往内含 typedefs，enums， static 成员变量，或 non-virtual 函数。&lt;/li&gt;
&lt;li&gt;许多技术用途的 empty classes，其中内含有用的成员 (通常是 typedefs)，包括 base classes unary_function 和 binary_function，这些是 &amp;quot; 用户自定义之函数对象 &amp;quot; 通常会继承的 classes。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Private 继承意味 is-implemented-in-terms of (根据某物实现出) 。它通常比复合(composition) 的级别低。但是当 derived class 需要访问 protected base class 的
成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。&lt;/li&gt;
&lt;li&gt;和复合(composition) 不同，private 继承可以造成 empty base 最优化。这对致力于 &amp;quot; 对象尺寸最小化 &amp;quot; 的程序库开发者而言，可能很重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-40-明智而审慎地使用多重继承&#34;&gt;条款 40: 明智而审慎地使用多重继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多重继承(multiple inheritance；MI)，单一继承 (single inheritance; SI)。&lt;/li&gt;
&lt;li&gt;C++ 用来解析 (resolving)重载函数调用的规则：在看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。&lt;/li&gt;
&lt;li&gt;多重继承会导致二义性问题(避免继承得来的成员变量重复)，通常采用 virtual 继承:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; base1, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; base2{};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。&lt;/li&gt;
&lt;li&gt;virtual 继承会增加大小、速度、初始化〈及赋值) 复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。&lt;/li&gt;
&lt;li&gt;多重继承的确有正当用途。其中一个情节涉及 &amp;quot; public 继承某个 Interface class &amp;quot; 和 &amp;quot; private 继承某个协助实现的 class &amp;quot; 的两相组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;七、模板与泛型编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款-41了解隐式接口和编译期多态&#34;&gt;条款 41：了解隐式接口和编译期多态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;面向对象编程世界总是以显式接口 (explicit interfaces) 和运行期多态 (runtime polymorphism) 解决问题。&lt;/li&gt;
&lt;li&gt;Templates 及泛型编程的世界以隐式接口 (implicit interfaces) 和编译期多态 (compile-time polymorphism) 为主。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;classes 和 templates 都支持接口 (interfaces) 和多态 (polymorphism) 。&lt;/li&gt;
&lt;li&gt;对 classes 而言接口是显式的(explicit), 以函数签名为中心。多态则是通过 virtual 函数发生于运行期。&lt;/li&gt;
&lt;li&gt;对 template 参数而言，接口是隐式的 (implicit) ，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析 (function overloading resolution ) 发生于编译期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-42了解-typename-的双重意义&#34;&gt;条款 42：了解 typename 的双重意义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ 有个规则可以解析 (resoive) 此一歧义状态：如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;template 内出现的名称如果相依于某个 template 参数，称之为从属名称 (dependent names)。&lt;/li&gt;
&lt;li&gt;如果从属名称在 class 内呈嵌套状，我们称它为嵌套从属名称 (nested dependent rame) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;只要在嵌套从属名称之前放置关键字 typename，即可告知解析器该名称为类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T::const_iterator it();&lt;span style=&#34;color:#228b22&#34;&gt;//告知解析器T::const_iterator 为类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;T t;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//T 非嵌套从属名称
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;typename 不可以出现在 base classes list 内的嵌套从属类型名称之前，也不可在 mermber initialization list (成员初值列) 中作为 base class 修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;derived&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; base&amp;lt;T&amp;gt;::nested &lt;span style=&#34;color:#228b22&#34;&gt;// base classes list
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;explicit&lt;/span&gt; derived(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x):base&amp;lt;T&amp;gt;::nested(x)	&lt;span style=&#34;color:#228b22&#34;&gt;//成员列表初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt;  base&amp;lt;T&amp;gt;::nested temp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;声明 template 参数时，前缀关键字 class 和typename 可互换。&lt;/li&gt;
&lt;li&gt;请使用关键字 typename 标识嵌套从属类型名称; 但不得在 base class lists (基类列) 或 member initialization list (成员初值列) 内以它作为 base class 修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-43学习处理模板化基类内的名称&#34;&gt;条款 43：学习处理模板化基类内的名称&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模板化基类 (templatized base classes )内的函数名称会被 derived classes 掩盖。&lt;/li&gt;
&lt;li&gt;若基类模板存在特例化版本，则在 derived class template 的时候会发生编译错误，这时可以将 derived class template 涉及 base class template 的成员函数前加 &amp;quot; this-&amp;gt; &amp;quot; 来指涉 base class template 内的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;可在 derived class templates 内通过 &amp;ldquo;this-&amp;gt;&amp;rdquo; 指涉 base class templates 内的成员名称，或通过一个明白写出的 &amp;quot; base class 资格修饰符 &amp;quot; 完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-44将与参数无关的代码抽离-templates&#34;&gt;条款 44：将与参数无关的代码抽离 templates&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;共性与变性分析 (commonality and variability analysis)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。&lt;/li&gt;
&lt;li&gt;因非类型模板参数 (non-type template parameters) 而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。&lt;/li&gt;
&lt;li&gt;因类型参数 (type parameters) 而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述 (binary representations) 的具现类型 (instantiation types) 共享实现码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-45运用成员函数模板接受所有兼容类型&#34;&gt;条款 45：运用成员函数模板接受所有兼容类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果以带有 base-derived 关系的 B, D 两类型分别具现化某个 template，产生出来的两个具现体并不带有 base-derived 关系。&lt;/li&gt;
&lt;li&gt;Templates 和泛型编程 ( Generic Programming )&lt;/li&gt;
&lt;li&gt;泛化(generalized) copy构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;SmartPtr&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//泛化copy构造函数,并保证只根据U生成T对象,保证public继承的隐式转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//泛化copy构造函数不等于copy构造函数，如果需要控制copy行为，还需自定义copy构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	SmartPtr(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; SmartPtr &amp;amp;sptr);&lt;span style=&#34;color:#228b22&#34;&gt;//普通copy构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; U&amp;gt;		&lt;span style=&#34;color:#228b22&#34;&gt;//泛化copy构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	SmartPtr(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; SmartPtr&amp;lt;U&amp;gt; &amp;amp;other):heldPtr(other.get())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{...}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	T *&lt;span style=&#34;color:#008b45&#34;&gt;get&lt;/span&gt;()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; {&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; heldPtr;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	T *heldPtr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;请使用 member function templates (成员函数模板) 生成 &amp;quot; 可接受所有兼容类型 &amp;quot; 的函数。&lt;/li&gt;
&lt;li&gt;如果你声明 member templates 用于 &amp;quot; 泛化 copy构造函数 &amp;quot; 或 &amp;quot; 泛化 assigmment操作 &amp;ldquo;，你还是需要声明正常的 copy 构造函数和 copy assigmmenmt 操作符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-46需要类型转换时请为模板定义非成员函数&#34;&gt;条款 46：需要类型转换时请为模板定义非成员函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 function template 实参推导过程中从不进行隐式类型转换。&lt;/li&gt;
&lt;li&gt;Class templates 并不倚赖 tetmplate 实参推导 ( 后者只施行于 function templates 身上) ，所以编译器总是能够在 class template 具现化时得知 T。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typename&lt;/span&gt; T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Rational&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//template class
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 Rational(T numerator = &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,T denominator = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 T &lt;span style=&#34;color:#008b45&#34;&gt;numerator&lt;/span&gt;()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 T &lt;span style=&#34;color:#008b45&#34;&gt;denominator&lt;/span&gt;()&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt;*(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;lhs,&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; Rational &amp;amp;rhs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Rational&lt;/span&gt;(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}&lt;span style=&#34;color:#228b22&#34;&gt;//定义在外部时，将只可通过编译却无法连接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	T n;&lt;span style=&#34;color:#228b22&#34;&gt;//分子(numerator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	T d;&lt;span style=&#34;color:#228b22&#34;&gt;//分母(denominator)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当我们编写一个 class template，而它所提供之 &amp;quot; 与此 template 相关的 &amp;quot; 函数支持 &amp;quot; 所有参数之隐式类型转换 &amp;quot; 时，请将那些函数定义为 &amp;quot; class template 内部的 friend 函数 &amp;ldquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-47请使用-traits-classes-表现类型信息&#34;&gt;条款 47：请使用 traits classes 表现类型信息&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;STL 主要由 &amp;quot; 用以表现容器、迭代器和算法 &amp;quot; 的 templates 构成，以及若干工具性 templates。&lt;/li&gt;
&lt;li&gt;STL 共有 5 种迭代器分类&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Input 迭代器&lt;/th&gt;
&lt;th&gt;Output 迭代器&lt;/th&gt;
&lt;th&gt;Forward 迭代器&lt;/th&gt;
&lt;th&gt;Bidirectional迭代器&lt;/th&gt;
&lt;th&gt;Random access 迭代器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Istream_iterators&lt;/td&gt;
&lt;td&gt;Ostream_iterators&lt;/td&gt;
&lt;td&gt;不支持linked list&lt;/td&gt;
&lt;td&gt;STL list, set, multiset, map, multimap 的迭代器&lt;/td&gt;
&lt;td&gt;vector,deque, string 的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只能向前最多一次读操作&lt;/td&gt;
&lt;td&gt;只能向前最多一次写操作&lt;/td&gt;
&lt;td&gt;向前多次操作&lt;/td&gt;
&lt;td&gt;可以向前移动，还可以向后移动&lt;/td&gt;
&lt;td&gt;支持迭代器算术，双向&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;is-a关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input、output&lt;/li&gt;
&lt;li&gt;forward : public input&lt;/li&gt;
&lt;li&gt;bidirectional : public forward&lt;/li&gt;
&lt;li&gt;random : public bidirectional&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;advance(Iter, Disance)&lt;/li&gt;
&lt;li&gt;设计并实现一个 traits class：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类 (category) 。&lt;/li&gt;
&lt;li&gt;为该信息选择一个名称 ( 例如 iterator_category) 。&lt;/li&gt;
&lt;li&gt;提供一个 template 和一组特化版本 ( 例如稍早说的 iterator_traits) ，内含你希望支持的类型相关信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如何使用一个 traits class：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;建立一组重载函数 (身份像劳工) 或函数模板 (例如 doadvance) ，彼此间的差异只在于各自的 traits 参数。令每个函数实现码与其接受之 traits 信息相应和。&lt;/li&gt;
&lt;li&gt;建立一个控制函数〈身份像工头) 或函数模板 (例如 advance) ，它调用上述那些 &amp;quot; 劳工函数 &amp;quot; 并传递 traits class 所提供的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Traits classes 使得 &amp;quot; 类型相关信息 &amp;quot; 在编译期可用。 它们以 templates 和 &amp;quot; templates 特化 &amp;quot; 完成实现。&lt;/li&gt;
&lt;li&gt;整合重载技术 (overloading ) 后，traits classes 有可能在编译期对类型执行 if&amp;hellip;else 测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-48认识-template-元编程&#34;&gt;条款 48：认识 template 元编程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Template metaprogramming (TMP，模板元编程) 是编写 template-based C++ 程序并执行于编译期的过程。&lt;/li&gt;
&lt;li&gt;template metaprogram (模板元程序) 是以 C++ 写成、执行于 C++ 编译器内的程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//阶层(factorial)模板元编程,递归模板具现化实现循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; n&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Factorial&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;enum&lt;/span&gt;{value = n*Factorial&amp;lt;n-&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;&amp;gt;::value};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;template&lt;/span&gt;&amp;lt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Factorial&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;enum&lt;/span&gt;{Value = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//main.cpp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;cout&amp;lt;&amp;lt;Factorial&amp;lt;&lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;&amp;gt;::value&amp;lt;&amp;lt;endl;&lt;span style=&#34;color:#228b22&#34;&gt;//计算5的阶层
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Template metaprogramming (TMP，模板元编程) 可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。&lt;/li&gt;
&lt;li&gt;TMP 可被用来生成 &amp;quot; 基于政策选择组合 &amp;quot; (based on combinations of policy choices) 的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第八章 定制 new 和 delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款-49了解-new-handler-的行为&#34;&gt;条款 49：了解 new-handler 的行为&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;set_new_handler 允许客户指定一个函数，在内存分配无法获得满足时被调用。&lt;/li&gt;
&lt;li&gt;Nothrow new是一个颇为局限的工具，因为它只适用于内存分配; 后继的构造函数调用还是可能抛出异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-50了解-new-和-qelete-的合理替换时机&#34;&gt;条款 50：了解 new 和 qelete 的合理替换时机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;何时可在 &amp;quot; 全局性的 &amp;quot; 或 &amp;quot; class 专属的 &amp;quot; 基础上合理替换缺省的 new 和 delete:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为了检测运用错误。&lt;/li&gt;
&lt;li&gt;为了收集动态分配内存之使用统计信息。&lt;/li&gt;
&lt;li&gt;为了增加分配和归还的速度。&lt;/li&gt;
&lt;li&gt;为了降低缺省内存管理器带来的空间额外开销。&lt;/li&gt;
&lt;li&gt;为了弥补缺省分配器中的非最佳齐位 (suboptimal atignment) 。&lt;/li&gt;
&lt;li&gt;为了将相关对象成簇集中。new 和 delete 的 &amp;quot; placement 版本 &amp;quot; (见条款52) 有可能完成这样的集簇行为。&lt;/li&gt;
&lt;li&gt;为了获得非传统的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;有许多理由需要写个自定的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-51编写new-和-delete-时需固守常规&#34;&gt;条款 51：编写new 和 delete 时需固守常规&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OPerator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。Class 专属版本则还应该处理 &amp;quot; 比正确大小更大的( 错误 ) 申请 &amp;quot; 。&lt;/li&gt;
&lt;li&gt;operator delete 应该在收到 null 指针时不做任何事。Class 专属版本则还应该处理 &amp;quot; 比正确大小更大的 ( 错误 ) 申请 &amp;quot; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款52写了-placement-new-也要写-placement-delete&#34;&gt;条款52：写了 placement new 也要写 placement delete&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果 operator new接受的参数除了一定会有的那个 size_t之外还有其他，这便是个所谓的 placerment new。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;new&amp;gt;//标准库&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;new&lt;/span&gt;(std: :size_t, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* PMemory) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;(); &lt;span style=&#34;color:#228b22&#34;&gt;//纳入标准库内的pacement new
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//非标准
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;new&lt;/span&gt;(std: :size_t, std::ostream &amp;amp;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;(std::bad_alloc);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;delete&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *, std::ostream &amp;amp;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//placement delete
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;缺省情况下 C++ 在 global 作用域内提供以下形式的 operator new：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;new&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;new&lt;/span&gt;(std: :size_t)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//正常的new
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;new&lt;/span&gt;(std: :size_t, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//placement new
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;new&lt;/span&gt;(std: :size_t, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt; std::nothrow_t &amp;amp;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;();&lt;span style=&#34;color:#228b22&#34;&gt;//nothrow new
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;如果你在 class 内声明任何 operator news，它会遮掩上述这些标准形式。为使这些函数有着平常的行为，只要令你的 class 专属版本调用 global 版本即可：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;//将标准形式放在一个class中，然后让客户继承及using声明式取得标准形式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;standard&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt;* &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;(std::size_t size)&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt;(std::bad_alloc)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;(size);&lt;span style=&#34;color:#228b22&#34;&gt;//分别调用标准形式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;wiget&lt;/span&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; standard
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;using&lt;/span&gt; standard::&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;//定义自己的operator new
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当你写一个 placement operator new，请确定也写出了对应的 placerment operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。&lt;/li&gt;
&lt;li&gt;当你声明 placement new 和 placement delete，请确定不要无意识 ( 非故意 )  地遮掩了它们的正常版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第九章杂项讨论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;条款-53不要轻忽编译器的警告&#34;&gt;条款 53：不要轻忽编译器的警告&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;警告信息天生和编译器相依，不同的编译器有不同的警告标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;严肃对待编译器发出的警告信息。努力在你的编译器的最高 ( 最严苛 ) 警告级别下争取 &amp;quot; 无任何警告 &amp;quot; 的荣誉 。&lt;/li&gt;
&lt;li&gt;不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-54让自己熟悉包括-tr1-在内的标准程序库&#34;&gt;条款 54：让自己熟悉包括 TR1 在内的标准程序库&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;C++ 标准程序库的主要机能由 STL、iostreams、locales 组成。并包含 C99 标准程序库。&lt;/li&gt;
&lt;li&gt;TR1 添加了智能指针 (例如 trl: :shared_ptr) 、一般化函数指针 (trl: :function) 、hash-based 容器、正则表达式 (regular expressions) 以及另外 10个组件的支持。&lt;/li&gt;
&lt;li&gt;TR1 自身只是一份规范。为获得 TR1 提供的好处，你需要一份实物。一个好的实物来源是 Boost。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;条款-55让自己熟悉-boost&#34;&gt;条款 55：让自己熟悉 Boost&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Boost 是一个 C++ 开发者集结的社群, 也是一个可自由下载的 C++ 程序库群。&lt;a href=&#34;http://boost.org&#34;&gt;boost网址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Boost Graph Library (用于编写任意 graph 结构)。&lt;/li&gt;
&lt;li&gt;Boost MPL Library (一个元编程程序库，metaprogramming library)。&lt;/li&gt;
&lt;li&gt;Boost 程序库内包含种类：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;字符串与文本处理。&lt;/li&gt;
&lt;li&gt;容器。&lt;/li&gt;
&lt;li&gt;函数对象和高级编程。&lt;/li&gt;
&lt;li&gt;泛型编程 (Generic programming)。&lt;/li&gt;
&lt;li&gt;模板元编程(Template metaprogramming，TMP)。&lt;/li&gt;
&lt;li&gt;数学和数值 (Math and numerics)。&lt;/li&gt;
&lt;li&gt;正确性与测试 (Correctness and testing)。&lt;/li&gt;
&lt;li&gt;数据结构。&lt;/li&gt;
&lt;li&gt;语言间的支持 (Inter-language support)。&lt;/li&gt;
&lt;li&gt;内存。&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Boost 是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的 C++ 程序库开发。Boost 在 C++ 标准化过程中扮演深具影响力的角色。&lt;/li&gt;
&lt;li&gt;Boost 提供许多 TR1 组件实现品，以及其他许多程序库。&lt;/li&gt;
&lt;/ul&gt;
- https://luckfalcon.github.io/post/effectivecpp/ - This is a customized copyright.</description>
        </item>
    
    
  </channel>
</rss> 